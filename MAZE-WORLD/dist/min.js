const correctRoundError=(num,estimation=4)=>Math.round(num*10**estimation)/10**estimation;const tweakColor=({r,g,b})=>{const randSaturation=Math.random()*0.1+0.95;const randBrightness=Math.random()*0.1+0.95;r=Math.round(r*randSaturation*randBrightness);g=Math.round(g*randSaturation*randBrightness);b=Math.round(b*randSaturation*randBrightness);return{r,g,b};};const getMod=(number,mod)=>(mod+(number%mod))%mod;const debounce=(fn,timeout=10)=>{let timer;return(...args)=>{clearTimeout(timer);timer=setTimeout(()=>{fn.apply(this,args);},timeout);};};const isPointOutside=(point,canvasHeight,canvasWidth)=>point.x<1||point.y<1||point.x>canvasWidth-1||point.y>canvasHeight-1;const getPosDistance=(pos1,pos2)=>Math.sqrt((pos1.i-pos2.i)**2+(pos1.j-pos2.j)**2);const getRandomFloat=(min,max)=>Math.random()*(max-min)+min;const getRandomInt=(max)=>Math.floor(getRandomFloat(0,max));let GRID=([]);const INITIAL_POS=({i:0,j:0});const getCell=({i,j})=>GRID[i]?.[j];const addCell=({i,j},cell)=>{GRID[i]=GRID[i]||[];GRID[i][j]=cell;};const resetGrid=()=>(GRID=[]);const KNOWN_POLYGONS={TRIANGLE:3,SQUARE:4,HEXAGON:6,};const POLYGONS_IMAGES={[KNOWN_POLYGONS.TRIANGLE]:"images/tools/triangle.png",[KNOWN_POLYGONS.SQUARE]:"images/tools/square.png",[KNOWN_POLYGONS.HEXAGON]:"images/tools/hexagon.png",};const KNOWN_POLYGONS_VALUES=Object.values(KNOWN_POLYGONS);const MAP_GENERATION={MIX:"MIX",DISTANCE:"DISTANCE",};const MENU_CONFIG={debugMode:false,passTime:true,rotationAnimation:true,showPos:false,showChunks:false,usePerspective:false,showSelectedCell:true,rain:false,clouds:true,digitalClock:false,music:false,fishingMazeSolved:false,mapGeneration:MAP_GENERATION.DISTANCE,};const RENDER_INFO=({currentPoly:KNOWN_POLYGONS.HEXAGON,cellHeight:24,iOffset:0,jOffset:0,rotationTurns:0,});const POLYS_INFO=({});const getPolyInfo=()=>POLYS_INFO[RENDER_INFO.currentPoly];const calculatePointBasedOnPos=({i,j},isInverted,baseCell)=>{const{calcX,calcY,ySide,shouldIntercalate}=getPolyInfo();i-=RENDER_INFO.iOffset||0;j-=RENDER_INFO.jOffset||0;let x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=baseCell?.pos.j%2?-ySide:ySide;return applyRotation({x,y},isInverted,baseCell);};const getPosByIndex=(cell,index)=>cell.adjacentPos[RENDER_INFO.currentPoly][getMod(index||0,RENDER_INFO.currentPoly)];const applyRotation=({x,y},isInverted,baseCell)=>{if(!RENDER_INFO.rotationTurns)return{x,y};const{cx,cy,ySide,xSide,hasInverted}=getPolyInfo();const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;const radians=(Math.PI/180)*angle;const cos=Math.cos(radians);const sin=Math.sin(radians);let nx=correctRoundError(cos*(x-cx)+sin*(y-cy)+cx);let ny=correctRoundError(cos*(y-cy)-sin*(x-cx)+cy);if(hasInverted&&isInverted!==baseCell?.isInverted&&angle){const oddTurn=!!(RENDER_INFO.rotationTurns%2);ny+=ySide*(baseCell?.isInverted?1:-1);nx+=(xSide/2)*(baseCell?.isInverted===oddTurn?-1:1);}return{x:nx,y:ny};};const createWallPoints=(points,height)=>{let centerAndBottomPoints=points.filter((p)=>p.y>=0);if(centerAndBottomPoints.length<=1)centerAndBottomPoints=points.sort((a,b)=>a.x-b.x);const firstPoint=centerAndBottomPoints[0];const lastPoint=centerAndBottomPoints[centerAndBottomPoints.length-1];return[{x:firstPoint.x,y:firstPoint.y-height},...centerAndBottomPoints,{x:lastPoint.x,y:lastPoint.y-height},];};const getXFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(j)=>j*(polySide/2)+xSide;case KNOWN_POLYGONS.HEXAGON:return(j)=>j*(xSide+polySide/2)+xSide;case KNOWN_POLYGONS.SQUARE:default:return(j)=>j*xSide*2+xSide;}};const configPoly=(polySides,cellHeight)=>{let radiusFromSide=0;let radiusFromCorner=0;let polySide=0;const hasInverted=polySides%2===1;const ySide=correctRoundError(cellHeight/2);if(hasInverted){polySide=correctRoundError(Math.sqrt(cellHeight**2/(1-1/4)));radiusFromSide=correctRoundError((polySide/2)*(1/Math.tan(Math.PI/polySides)));}else{radiusFromSide=ySide;polySide=correctRoundError(2*radiusFromSide*Math.tan(Math.PI/polySides));}radiusFromCorner=correctRoundError(radiusFromSide*(1/Math.cos(Math.PI/polySides)));const shouldIntercalate=polySides>KNOWN_POLYGONS.SQUARE;const yCoeficient=hasInverted?correctRoundError(-cellHeight/6):0;const coeficient=(polySides/2+1)/2;const points=[];const sideRad=(2*Math.PI)/polySides;for(let i=0;i<polySides;i++){const nI=i-coeficient;const rad=sideRad*nI;const x=correctRoundError(radiusFromCorner*Math.cos(rad));const y=correctRoundError(radiusFromCorner*Math.sin(rad)+yCoeficient,1);points.push({x,y});}const xSide=points.reduce((acc,{x})=>(x>acc?x:acc),0);const invertedPoints=points.map((p)=>({x:-p.x,y:-p.y}));const wallPoints=createWallPoints(points,ySide);const wallInvertedPoints=createWallPoints(invertedPoints,ySide);const slopSide=correctRoundError(Math.sqrt(Math.abs(polySide**2-radiusFromSide**2)));const{innerHeight,innerWidth}=window;const rows=Math.floor(innerHeight/cellHeight);let columns=innerWidth/(xSide*2);if(hasInverted)columns=((innerWidth-2)*2-polySide)/polySide;if(shouldIntercalate)columns=((innerWidth-slopSide)*2)/(radiusFromCorner*2+polySide);columns=Math.floor(columns);if(columns%2===0)columns-=1;if(shouldIntercalate&&((columns+1)/2)%2===0)columns-=2;const canvasHeight=innerHeight;let canvasWidth=columns*(xSide*2);if(hasInverted)canvasWidth=(columns*polySide)/2+polySide/2+2;if(shouldIntercalate)canvasWidth=(columns*(radiusFromCorner*2+polySide))/2+slopSide;canvasWidth=Math.round(canvasWidth);return{polySide,xSide,ySide,points,invertedPoints,wallPoints,wallInvertedPoints,rows,columns,canvasHeight,canvasWidth,calcX:getXFn(polySides,polySide,xSide),calcY:(i)=>i*ySide*2+ySide,cx:correctRoundError(canvasWidth/2),cy:correctRoundError((canvasHeight-ySide*3)/2),shouldIntercalate,hasInverted,};};const configPolys=()=>{for(const p of KNOWN_POLYGONS_VALUES){POLYS_INFO[p]=configPoly(p,RENDER_INFO.cellHeight);}};const MOVEMENT={UP:Symbol("UP"),DOWN:Symbol("DOWN"),LEFT:Symbol("LEFT"),RIGHT:Symbol("RIGHT"),};const ENTITY_TYPES={PLAYER:"PLAYER",BOAT:"BOAT",TREE:"TREE",ENEMY:"ENEMY",FIRE:"FIRE",RABBIT:"RABBIT",};const IMG_MAP_TYPES={DEFAULT:"DEFAULT",RUNNING:"RUNNING",};const BIOME_TYPES={SNOW:"SNOW",DESERT:"DESERT",};const ENTITY_INFO=({timeOfDay:0,});const ENTITY_ACTIONS_CONFIG={delayToBurn:1000,};const FIRE_IMG_MAP=({[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.UP]:"images/enemies/fire.png",[MOVEMENT.DOWN]:"images/enemies/fire.png",[MOVEMENT.LEFT]:"images/enemies/fire.png",[MOVEMENT.RIGHT]:"images/enemies/fire.png",},});const getClosestTarget=(entity)=>{let minDistance=Infinity;let selectedTarget=(null);ENTITIES.forEach((targetEntity)=>{entity.movementOptions.targets.forEach((t)=>{if(targetEntity.cell&&targetEntity.type===t){const distance=getPosDistance(entity.cell.pos,targetEntity.cell.pos);if(distance<minDistance){selectedTarget=targetEntity;minDistance=distance;}}});});return selectedTarget;};const getClosestCell=(entity,cell,targetCell)=>{let minDistance=Infinity;let selectedCell=(null);let selectedIndex=0;const aPos=cell.adjacentPos[RENDER_INFO.currentPoly];for(let index=0;index<aPos.length;index++){const pos=aPos[index];const aCell=getCell(pos);if(cellIsBlocked(aCell,entity))continue;const distance=getPosDistance(aCell.pos,targetCell.pos);if(distance<minDistance){selectedCell=aCell;selectedIndex=index;minDistance=distance;}}return{cell:selectedCell,index:selectedIndex};};const moveEntities=(baseCell)=>{const{indexToMove}=getMovementMaps(baseCell);ENTITIES.forEach((e)=>{if(!e.cell||e.deleted||!e.movementOptions?.speed)return;const{targets,speed,random}=e.movementOptions;let nextCell=e.cell;let nextIndex=0;for(let index=0;index<speed;index++){if(targets){const target=getClosestTarget(e);if(!target)return;const nextCellInfo=getClosestCell(e,nextCell,target.cell);nextCell=nextCellInfo.cell;nextIndex=nextCellInfo.index;if(!nextCell)return;}else if(random){nextIndex=getRandomInt(RENDER_INFO.currentPoly);const aPos=nextCell.adjacentPos[RENDER_INFO.currentPoly];nextCell=getCell(aPos[nextIndex]);for(let i=0;i<aPos.length;i++){if(!cellIsBlocked(nextCell,e))break;nextIndex=getMod(nextIndex+1,RENDER_INFO.currentPoly);nextCell=getCell(aPos[nextIndex]);}}}if(cellIsBlocked(nextCell,e))return;nextIndex=getMod(nextIndex,RENDER_INFO.currentPoly);updateEntityImage(e,indexToMove[nextIndex]);moveEntityToCell(e,nextCell);});};const getMovementMaps=(baseCell,useDiagonal)=>{let topI=RENDER_INFO.rotationTurns;let bottomI=topI+Math.floor(RENDER_INFO.currentPoly/2);let topLeftI=topI+RENDER_INFO.currentPoly-1;let topRightI=topI+1;let bottomLeftI=bottomI+1;let bottomRightI=bottomI-1;if(getPolyInfo().hasInverted){const isInverted=baseCell.isInverted;topLeftI=bottomLeftI=topI+(isInverted?1:2);topRightI=bottomRightI=topI+(isInverted?2:1);bottomI=isInverted?topI:undefined;topI=isInverted?undefined:topI;}return{moveToIndex:{[MOVEMENT.UP]:topI,[MOVEMENT.DOWN]:bottomI,[MOVEMENT.LEFT]:useDiagonal?bottomLeftI:topLeftI,[MOVEMENT.RIGHT]:useDiagonal?bottomRightI:topRightI,},indexToMove:{[topI]:MOVEMENT.UP,[bottomI]:MOVEMENT.DOWN,[bottomLeftI]:MOVEMENT.LEFT,[topLeftI]:MOVEMENT.LEFT,[bottomRightI]:MOVEMENT.RIGHT,[topRightI]:MOVEMENT.RIGHT,},};};const getMovementMap=(baseCell,useDiagonal)=>getMovementMaps(baseCell,useDiagonal).moveToIndex;const killEntitiesByTimeOfDay=()=>{if(MENU_CONFIG.rain)return;const entitiesToKill=([]);ENTITIES.forEach((e)=>{if(!e.cell||!e.minTime||e.deleted||e.minTime<=ENTITY_INFO.timeOfDay)return;const fireEntity=createEntity(e.cell,e.id,ENTITY_TYPES.FIRE,FIRE_IMG_MAP,{zIndex:3});e.connectedEntities[ENTITY_TYPES.FIRE]=fireEntity;e.deleted=true;entitiesToKill.push(e);});setTimeout(()=>{entitiesToKill.forEach(removeEntity);},ENTITY_ACTIONS_CONFIG.delayToBurn);};const BOAT_IMG_MAP=({[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.UP]:"images/boat/up.png",[MOVEMENT.DOWN]:"images/boat/down.png",[MOVEMENT.LEFT]:"images/boat/left.png",[MOVEMENT.RIGHT]:"images/boat/right.png",},});const BOAT_ENTITIES=({});const getInBoat=(entity)=>{if(!BOAT_ENTITIES[entity.id])addBoat(entity.cell,entity);BOAT_ENTITIES[entity.id].isConnected=true;entity.connectedEntities[ENTITY_TYPES.BOAT]=BOAT_ENTITIES[entity.id];};const getOutBoat=(entity)=>{if(entity.connectedEntities[ENTITY_TYPES.BOAT]){delete entity.connectedEntities[ENTITY_TYPES.BOAT];BOAT_ENTITIES[entity.id].isConnected=false;moveEntityToCell(BOAT_ENTITIES[entity.id],entity.cell);}};const addBoat=(cell,entity)=>{let boatEntity=BOAT_ENTITIES[entity.id];if(!boatEntity)boatEntity=BOAT_ENTITIES[entity.id]=createEntity(cell,entity.id,ENTITY_TYPES.BOAT,BOAT_IMG_MAP,{zIndex:1,movementsToCut:[MOVEMENT.UP,MOVEMENT.DOWN],});moveEntityToCell(boatEntity,cell);};const ENEMY_IMG_MAP=({[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.UP]:"images/enemies/zombie/up.png",[MOVEMENT.DOWN]:"images/enemies/zombie/down.png",[MOVEMENT.LEFT]:"images/enemies/zombie/left.png",[MOVEMENT.RIGHT]:"images/enemies/zombie/right.png",},});const ENEMY_MIN_TIME=40;const addEnemy=(cell)=>{if(ENTITY_INFO.timeOfDay<ENEMY_MIN_TIME)return;const enemyEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.ENEMY,ENEMY_IMG_MAP,{defaultDirection:MOVEMENT.DOWN,defaultImgMapType:cell.block?.biomeType,minTime:ENEMY_MIN_TIME,movementOptions:{speed:1,targets:new Set([ENTITY_TYPES.PLAYER]),},});if(cell.block.isFluid)getInBoat(enemyEntity);};const spawnEntity=(entityType,cell)=>{switch(entityType){case ENTITY_TYPES.TREE:return addTree(cell);case ENTITY_TYPES.RABBIT:return addRabbit(cell);case ENTITY_TYPES.ENEMY:return addEnemy(cell);}};const PLAYER_IMG_MAP=({[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.UP]:"images/player/up.png",[MOVEMENT.DOWN]:"images/player/down.png",[MOVEMENT.LEFT]:"images/player/left.png",[MOVEMENT.RIGHT]:"images/player/right.png",},[IMG_MAP_TYPES.RUNNING]:{[MOVEMENT.UP]:"images/player/up-walk.gif",[MOVEMENT.DOWN]:"images/player/down-walk.gif",[MOVEMENT.LEFT]:"images/player/left-walk.gif",[MOVEMENT.RIGHT]:"images/player/right-walk.gif",},});const PLAYER_ENTITY=({id:"PLAYER_1",type:ENTITY_TYPES.PLAYER,imageMap:PLAYER_IMG_MAP,cell:null,img:document.getElementById("player"),connectedEntities:{},selectedCellIndex:0,pickedCells:[],});const RABBIT_IMG_MAP=({[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.UP]:"images/map/rabbit.png",[MOVEMENT.DOWN]:"images/map/rabbit-right.png",[MOVEMENT.LEFT]:"images/map/rabbit.png",[MOVEMENT.RIGHT]:"images/map/rabbit-right.png",},});const addRabbit=(cell)=>{const rabbitEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.RABBIT,RABBIT_IMG_MAP,{isGenerated:true,movementOptions:{speed:1,random:true},defaultImgMapType:cell.block?.biomeType,});if(cell.block.isFluid)getInBoat(rabbitEntity);};const TREE_IMG_MAP=({[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.UP]:"images/map/tree.png",[MOVEMENT.DOWN]:"images/map/tree.png",[MOVEMENT.LEFT]:"images/map/tree.png",[MOVEMENT.RIGHT]:"images/map/tree.png",},[BIOME_TYPES.DESERT]:{[MOVEMENT.UP]:"images/map/tree-desert.png",[MOVEMENT.DOWN]:"images/map/tree-desert.png",[MOVEMENT.LEFT]:"images/map/tree-desert.png",[MOVEMENT.RIGHT]:"images/map/tree-desert.png",},[BIOME_TYPES.SNOW]:{[MOVEMENT.UP]:"images/map/tree-snow.png",[MOVEMENT.DOWN]:"images/map/tree-snow.png",[MOVEMENT.LEFT]:"images/map/tree-snow.png",[MOVEMENT.RIGHT]:"images/map/tree-snow.png",},});const addTree=(cell)=>{const treeEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.TREE,TREE_IMG_MAP,{isGenerated:true,defaultImgMapType:cell.block?.biomeType});if(cell.block.isFluid)getInBoat(treeEntity);};const ENTITIES=(new Set());const addEntity=(entity)=>ENTITIES.add(entity);const moveEntityToCell=(entity,cell)=>{if(!cell)return;const previousType=entity.cell?.entityType||cell.entityType;if(entity.cell)entity.cell.entityType=null;entity.cell=cell;entity.cell.entityType=previousType||entity.type;updateEntityPoint(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach((e)=>moveEntityToCell(e,cell));};const removeEntity=(entity)=>{entity.cell.entityType=null;removeEntityImage(entity);ENTITIES.delete(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach(removeEntity);};const removeEntitiesFromCell=(cell)=>{const removedEntities=([]);ENTITIES.forEach((entity)=>{if(entity.cell===cell){removeEntity(entity);removedEntities.push(entity);}});return removedEntities;};const createEntity=(cell,id,type,imageMap,entityParams={})=>{const entity=({id:`${type}_${id}`,type,imageMap,connectedEntities:{},...entityParams,});createEntityImage(entity);moveEntityToCell(entity,cell);addEntity(entity);return entity;};const setEntitiesSize=()=>ENTITIES.forEach(setEntitySize);const removeGeneratedEntities=()=>{ENTITIES.forEach((e)=>{if(e.isGenerated)removeEntity(e);});};const updateEntities=()=>ENTITIES.forEach((e)=>updateEntityPoint(e));const cellIsBlocked=(cell,entity)=>!MENU_CONFIG.debugMode&&(!cell||!cell.block||!!cell.wall||!!cell.entityType||(entity.connectedEntities[ENTITY_TYPES.BOAT]?!cell.block.isFluid:cell.block.isFluid));const getSelectedCell=(entity)=>getCell(getPosByIndex(entity.cell,entity.selectedCellIndex));const updateEntityDirection=(entity,direction)=>{updateEntityImage(entity,direction);Object.values(entity.connectedEntities).forEach((e)=>{updateEntityImage(e,MOVEMENT.RIGHT);});};const makeEntityRun=(entity,direction)=>{const connectedEntities=(Object.values(entity.connectedEntities));if(!connectedEntities.length){updateEntityImage(entity,direction,IMG_MAP_TYPES.RUNNING);return;}updateEntityImage(entity,direction);connectedEntities.forEach((e)=>{updateEntityImage(e,direction);cutEntityImage(e,direction);});};const CUT_MOVEMENTS_MAP={[MOVEMENT.UP]:"marginTop",[MOVEMENT.DOWN]:"marginTop",[MOVEMENT.LEFT]:"marginLeft",[MOVEMENT.RIGHT]:"marginRight",};const container=document.getElementById("entities");const createEntityImage=(entity)=>{const img=document.createElement("img");img.id=entity.id;img.style.zIndex=`${entity.zIndex ||2}`;img.src=getImgMap(entity,entity.defaultImgMapType)[entity.defaultDirection||MOVEMENT.RIGHT];container.appendChild(img);entity.img=img;setEntitySize(entity);};const removeEntityImage=(entity)=>{if(entity.img)container.removeChild(entity.img);entity.img=null;};const updateEntityPoint=(entity,parentPoint)=>{if(!parentPoint&&entity.isConnected)return;const{hasInverted,canvasHeight,canvasWidth}=getPolyInfo();const point=parentPoint||calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);if(isPointOutside(point,canvasHeight,canvasWidth)){if(entity.img)removeEntityImage(entity);}else if(!entity.img){createEntityImage(entity);}if(entity.img)setImagePoint(entity.img,point);verifyEntityHeight(entity);Object.values(entity.connectedEntities).forEach((e)=>updateEntityPoint(e,point));};const getEntitySize=()=>Math.round(getPolyInfo().ySide*2.5);const setEntitySize=(entity)=>entity.img?.style.setProperty("--entity-size",`${getEntitySize()}px`);const setImagePoint=(img,point)=>{const entitySize=getEntitySize();img.style.setProperty("--entity-top",`${point.y -entitySize /1.25}px`);img.style.setProperty("--entity-left",`${point.x -entitySize /2}px`);};const verifyEntityHeight=(entity)=>{if(!entity?.cell||!entity?.img)return;const{hasInverted}=getPolyInfo();const downI=hasInverted&&entity.cell.isInverted?RENDER_INFO.rotationTurns:RENDER_INFO.rotationTurns+Math.floor(RENDER_INFO.currentPoly/2);const downPos=getPosByIndex(entity.cell,downI);const downCell=getCell(downPos);if(!downCell)return;while(entity.img.classList.length>0)entity.img.classList.remove(entity.img.classList.item(0));const connectedEntities=(Object.values(entity.connectedEntities));if(hasInverted&&!entity.cell.isInverted){const rightCell=downCell;const leftI=RENDER_INFO.rotationTurns+RENDER_INFO.currentPoly-1;const leftPos=getPosByIndex(entity.cell,leftI);const leftCell=getCell(leftPos);if(rightCell.wall&&leftCell.wall){entity.img.classList.add("not-inverted-both-walls");}else if(rightCell.wall){entity.img.classList.add("not-inverted-right-wall");}else if(leftCell.wall){entity.img.classList.add("not-inverted-left-wall");}}else if(downCell.wall){entity.img.classList.add("behind-wall");}if(connectedEntities.length)entity.img.classList.add("behind-wall");};const getImgMap=(entity,imgMapType)=>entity.imageMap[imgMapType]||entity.imageMap[IMG_MAP_TYPES.DEFAULT];const updateEntityImage=(entity,direction,imgMapType)=>{if(!entity.img)return;const newSrc=getImgMap(entity,imgMapType)[direction]||entity.img.src;if(!entity.img.src.endsWith(newSrc))entity.img.src=newSrc;entity.img.style.marginTop=null;entity.img.style.marginLeft=null;entity.img.style.marginRight=null;};const cutEntityImage=(entity,direction)=>{if(entity.movementsToCut?.length){if(entity.movementsToCut.includes(direction)){const{ySide}=getPolyInfo();entity.img.style[CUT_MOVEMENTS_MAP[direction]]=`${ySide}px`;}}};const GENERATION_CONFIG={chunkSize:50,};const getRange=(n,range)=>Math.floor(n/range)*range;const getChunkStart=(pos,height,width)=>({i:getRange(pos.i,height),j:getRange(pos.j,width),});const hexToRgb=(hexColor)=>{let hex=hexColor.trim().slice(1);let r=parseInt(hex.substring(0,2),16);let g=parseInt(hex.substring(2,4),16);let b=parseInt(hex.substring(4,6),16);return{r,g,b};};const TRACK_TYPES={TRACK1:"TRACK1",TRACK2:"TRACK2",TRACK3:"TRACK3",TRACK4:"TRACK4",TRACK5:"TRACK5",TRACK6:"TRACK6",TRACK7:"TRACK7",TRACK8:"TRACK8",TRACK9:"TRACK9",TRACK11:"TRACK11",TRACK10:"TRACK10",TRACK12:"TRACK12",TRACK13:"TRACK13",TRACK14:"TRACK14",TRACK15:"TRACK15",TRACK16:"TRACK16",};const ENEMY_SPAWN={probability:0.00001,entityType:ENTITY_TYPES.ENEMY,spawnOnMove:true,increaseWithTime:true,};const WATER_SPAWNS=[{probability:0.0005,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const FOREST_SPAWNS=[{probability:0.01,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const SNOW_PROPS={biomeType:BIOME_TYPES.SNOW,spawnableEntities:[{probability:0.01,entityType:ENTITY_TYPES.TREE},ENEMY_SPAWN,],};const DESERT_PROPS={biomeType:BIOME_TYPES.DESERT,spawnableEntities:[{probability:0.001,entityType:ENTITY_TYPES.TREE},{...ENEMY_SPAWN,probability:0.00005,},],};const EMPTY_BLOCK=({layer:0,color:{r:-1,g:-1,b:-1},});const BLOCKS=({DEEP_WATER:{color:hexToRgb("#256299"),layer:0,isFluid:true,spawnableEntities:WATER_SPAWNS,trackType:TRACK_TYPES.TRACK5,},WATER:{color:hexToRgb("#2375b4"),layer:0,isFluid:true,trackType:TRACK_TYPES.TRACK4,},BEACH_SAND:{color:hexToRgb("#ab976a"),layer:0,spawnableEntities:[ENEMY_SPAWN],trackType:TRACK_TYPES.TRACK3,},LOW_GRASS:{color:hexToRgb("#457950"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK2,},MID_GRASS:{color:hexToRgb("#2d673e"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK1,},HIGH_GRASS:{color:hexToRgb("#2d673e"),layer:1,trackType:TRACK_TYPES.TRACK1,},DIRT:{color:hexToRgb("#3F573A"),layer:1,trackType:TRACK_TYPES.TRACK6,},ROCK:{color:hexToRgb("#CBC0BB"),layer:1},FROZEN_WATER:{color:hexToRgb("#94F2F4"),layer:0,trackType:TRACK_TYPES.TRACK11,...SNOW_PROPS,},FROZEN_SEA_SHORE:{color:hexToRgb("#A0E6EC"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},SLUSH:{color:hexToRgb("#D0ECEB"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},ICE:{color:hexToRgb("#ECFFFD"),layer:0,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},HIGH_ICE:{color:hexToRgb("#ECFFFD"),layer:1,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},DUST:{color:hexToRgb("#DAA98B"),layer:0,trackType:TRACK_TYPES.TRACK16,...DESERT_PROPS,},SAND:{color:hexToRgb("#EC912E"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},DARK_SAND:{color:hexToRgb("#CC7025"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},TERRACOTA:{color:hexToRgb("#9F561A"),layer:0,trackType:TRACK_TYPES.TRACK15,...DESERT_PROPS,},HIGH_TERRACOTA:{color:hexToRgb("#9F561A"),layer:1,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},});const addPropsToBlock=(block,props)=>({...block,...props});const BIOMES_RAW=({FOREST:{name:"FOREST",mapColor:BLOCKS.MID_GRASS.color,minValue:-1,minDistance:0,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.WATER,{max:-0.4}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:-0.2}),addPropsToBlock(BLOCKS.MID_GRASS,{max:0.4}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.5}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},OCEAN:{name:"OCEAN",mapColor:BLOCKS.WATER.color,minValue:-0.2,minDistance:100,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.DEEP_WATER,{max:-0.1}),addPropsToBlock(BLOCKS.WATER,{max:0.3}),addPropsToBlock(BLOCKS.BEACH_SAND,{max:0.5}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:0.7}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.8}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},SNOW:{name:"SNOW",mapColor:BLOCKS.ICE.color,minValue:0.2,minDistance:300,higherGroundBlock:BLOCKS.ICE,negativeJ:false,ranges:[addPropsToBlock(BLOCKS.FROZEN_WATER,{max:-0.2}),addPropsToBlock(BLOCKS.FROZEN_SEA_SHORE,{max:0}),addPropsToBlock(BLOCKS.SLUSH,{max:0.1}),addPropsToBlock(BLOCKS.HIGH_ICE,{max:1}),],},DESERT:{name:"DESERT",mapColor:BLOCKS.SAND.color,minValue:0,minDistance:300,higherGroundBlock:BLOCKS.TERRACOTA,negativeJ:true,ranges:[addPropsToBlock(BLOCKS.DUST,{max:-0.4}),addPropsToBlock(BLOCKS.SAND,{max:-0.2}),addPropsToBlock(BLOCKS.DARK_SAND,{max:0}),addPropsToBlock(BLOCKS.TERRACOTA,{max:0.2}),addPropsToBlock(BLOCKS.HIGH_TERRACOTA,{max:1}),],},});const BIOMES=Object.values(BIOMES_RAW).sort((a,b)=>b.minDistance-a.minDistance);let BIOME_MAPS=([]);const resetBiomes=()=>(BIOME_MAPS=[]);const getPosBiomeOffset=({i,j})=>({i:i/GENERATION_CONFIG.chunkSize,j:j/GENERATION_CONFIG.chunkSize,});const addBiomeToMap=(pos,biome)=>{const{i,j}=getPosBiomeOffset(pos);if(!BIOME_MAPS[i])BIOME_MAPS[i]=[];if(BIOME_MAPS[i][j])return;BIOME_MAPS[i][j]=biome;};const getBiomeFromMap=(pos)=>{pos=getChunkStart(pos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const{i,j}=getPosBiomeOffset(pos);return BIOME_MAPS[i]?.[j];};const getBiomeMap=()=>BIOME_MAPS;const isCellInverted=({i,j})=>(i+j)%2!==0;const getAdjacentPos=({i,j},isInverted)=>{return{[KNOWN_POLYGONS.TRIANGLE]:isInverted?[{i:i+1,j},{i,j:j-1},{i,j:j+1},]:[{i:i-1,j},{i,j:j+1},{i,j:j-1},],[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j},{i,j:j+1},{i:i+1,j},{i,j:j-1},],[KNOWN_POLYGONS.HEXAGON]:j%2?[{i:i-1,j},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},]:[{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j},{i,j:j-1},{i:i-1,j:j-1},],};};const createCellProps=(pos)=>{const isInverted=isCellInverted(pos);return{pos,isInverted,adjacentPos:getAdjacentPos(pos,isInverted)};};const createCell=(pos,block)=>{let cell=getCell(pos);if(!cell){cell=({});cell.entityType=null;if(block){cell.block=block;cell.layer=block.layer;cell.color=tweakColor(block.color);}}return{...createCellProps(pos),...cell};};const createEntitiesForCell=(cell,onMove=false)=>{if(!cell.block.spawnableEntities?.length)return;for(const sEntity of cell.block.spawnableEntities){const canSpawn=onMove?sEntity.spawnOnMove:!sEntity.spawnOnMove;let probability=sEntity.probability;if(sEntity.increaseWithTime)probability*=ENTITY_INFO.timeOfDay/2;if(canSpawn&&Math.random()<probability){spawnEntity(sEntity.entityType,cell);return;}}};const getBiome=(pos)=>{switch(MENU_CONFIG.mapGeneration){case MAP_GENERATION.MIX:const biomeValue=getValue(pos.i,pos.j,VECTORS.BIOME);return BIOMES.find((b)=>biomeValue>=b.minValue);default:case MAP_GENERATION.DISTANCE:const distance=getPosDistance(INITIAL_POS,pos);return BIOMES.filter((b)=>(b.negativeJ===undefined||b.negativeJ===pos.j<0)&&(b.negativeI===undefined||b.negativeI===pos.i<0)).find((b)=>distance>=b.minDistance);}};const loadChunk=(initialPos)=>{const offsetPos=getChunkStart(initialPos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const biomeMap=({});for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){const nI=i+offsetPos.i;for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){const nJ=j+offsetPos.j;const pos={i:nI,j:nJ};const biome=getBiome(pos);biomeMap[biome.name]=(biomeMap[biome.name]||0)+1;const value=getValue(nI,nJ,VECTORS.BLOCK);const originalBlock=biome.ranges.find((r)=>value<=r.max);const isHighBlock=originalBlock.layer>0;const cellBlock=isHighBlock?biome.higherGroundBlock:originalBlock;const cell=createCell(pos,cellBlock);addCell(pos,cell);if(isHighBlock)cell.wall={block:originalBlock,color:tweakColor(originalBlock.color),};else createEntitiesForCell(cell);}}const biomeName=Object.entries(biomeMap).sort(([_,a],[__,b])=>b-a)[0][0];addBiomeToMap(offsetPos,BIOMES.find((b)=>b.name===biomeName));};const loadAndGetCell=(pos)=>{if(!getCell(pos))loadChunk(pos);return getCell(pos);};const getCenterCell=()=>{const{rows,columns}=getPolyInfo();const{iOffset,jOffset}=RENDER_INFO;const i=Math.floor(rows/2)+iOffset;const j=Math.floor(columns/2)+jOffset;return loadAndGetCell({i,j});};const getBorderCells=(baseCell)=>{const{rows,columns}=getPolyInfo();const halfR=Math.floor(rows/2);const halfC=Math.floor(columns/2);const{i,j}=baseCell.pos;const tI=i-halfR;const bI=i+halfR;const lJ=j-halfC;const rJ=j+halfC;const positions=([]);for(let index=lJ;index<=rJ;index++){positions.push({i:tI,j:index});positions.push({i:bI,j:index});}for(let index=tI;index<=bI;index++){positions.push({i:index,j:lJ});positions.push({i:index,j:rJ});}return positions.map(getCell);};const spawnEntities=(baseCell)=>{getBorderCells(baseCell).forEach((cell)=>{if(!!cell?.block&&!cell.wall&&!cell.entityType)createEntitiesForCell(cell,true);});};const createMazeObj=(mazeInfos,mazeCircleInfos)=>{let MAZE_GRID=([]);const MAZE_POLYS_INFO=({});const getMazePolyInfo=()=>MAZE_POLYS_INFO[RENDER_INFO.currentPoly];const CIRCLE_INFO=({cellHeight:0,center:null,rows:0,columns:0,});const MAZE_INFO=({rows:0,columns:0,isCircle:false,currentCell:null,queue:[],});const getMazeCell=({i,j})=>MAZE_GRID[i]?.[j];const resetMazeGrid=()=>(MAZE_GRID=[]);const createMazeGrid=()=>{resetMazeGrid();const rows=getMazeRows();for(let i=0;i<rows;i++){const numCells=getNumCellsPerMazeRow(i);for(let j=0;j<numCells;j++){MAZE_GRID[i]=MAZE_GRID[i]||[];MAZE_GRID[i][j]=createCellMaze({i,j});}}};const createCellMaze=(pos)=>{const cell=(createCellProps(pos));cell.visited=false;cell.solved=false;cell.path=false;cell.borders=[...new Array(RENDER_INFO.currentPoly)].map(()=>true);if(MAZE_INFO.isCircle)createCircleCellMaze(cell);else cell.point=calculateMazePoint(pos);return cell;};const calculateMazePoint=({i,j})=>{const{calcX,calcY,ySide,shouldIntercalate}=getMazePolyInfo();const x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=ySide;return{x,y};};const getMazeRows=()=>MAZE_INFO.isCircle?CIRCLE_INFO.rows:MAZE_INFO.rows;const getNumCellsPerMazeRow=(rowIndex)=>MAZE_INFO.isCircle?CIRCLE_INFO.columns-Math.floor((rowIndex+1)/2):MAZE_INFO.columns;const createCircleCellMaze=(cell)=>{const{i,j}=cell.pos;const topRadius=(CIRCLE_INFO.rows-i)*CIRCLE_INFO.cellHeight;const bottomRadius=topRadius-CIRCLE_INFO.cellHeight;const topAngle=Math.atan2(-topRadius,0);const bottomAngle=bottomRadius?topAngle:0;const numCells=getNumCellsPerMazeRow(i);const parts=(Math.PI*1.5-topAngle)/numCells;const leftBorder=j*parts;const rightBorder=(j+1)*parts;const topLeftAngle=topAngle+leftBorder;const topRightAngle=topAngle+rightBorder;const bottomLeftAngle=bottomAngle+leftBorder;const bottomRightAngle=bottomAngle+rightBorder;cell.circleProps={topLeftPoint:getMazePoint(topRadius,topLeftAngle),topRightPoint:getMazePoint(topRadius,topRightAngle),bottomLeftPoint:getMazePoint(bottomRadius,bottomLeftAngle),bottomRightPoint:getMazePoint(bottomRadius,bottomRightAngle),topRadius,bottomRadius,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,adjacentPos:cell.adjacentPos[KNOWN_POLYGONS.SQUARE].map((aPos)=>({i:aPos.i,j:aPos.j<0?numCells-1:aPos.j>=numCells?0:aPos.j,})),};};const getMazePoint=(radius,angle)=>({x:CIRCLE_INFO.center.x+Math.cos(angle)*radius,y:CIRCLE_INFO.center.y+Math.sin(angle)*radius,});const buildMaze=()=>{createMazeGrid();setCurrentCell(getMazeCell(INITIAL_POS));while(MAZE_INFO.currentCell)setCurrentCell(buildCellMaze(MAZE_INFO.currentCell));setCurrentCell(getMazeCell(INITIAL_POS));};const setCurrentCell=(cell)=>{if(MAZE_INFO.currentCell)MAZE_INFO.currentCell.active=false;MAZE_INFO.currentCell=cell;if(MAZE_INFO.currentCell)MAZE_INFO.currentCell.active=true;};const buildCellMaze=(cell)=>{cell.visited=true;const nextCell=getNextCellMaze(cell,(c)=>!!c&&!c.visited,true);if(!nextCell)return null;const adjacentIndex=getNextCellMazeAdjacentIndex(cell,nextCell);const nextAdjacentIndex=getNextCellMazeAdjacentIndex(nextCell,cell);cell.borders[adjacentIndex]=false;nextCell.borders[nextAdjacentIndex]=false;return nextCell;};const isMazeSolved=()=>!MAZE_INFO.currentCell||(MAZE_INFO.isCircle?MAZE_INFO.currentCell.pos.i===CIRCLE_INFO.rows-1:MAZE_INFO.currentCell.pos.i===MAZE_INFO.rows-1&&MAZE_INFO.currentCell.pos.j===MAZE_INFO.columns-1);const solveMaze=()=>{while(!isMazeSolved())setCurrentCell(solveCellMaze(MAZE_INFO.currentCell));solveCellMaze(MAZE_INFO.currentCell);setCurrentCell(getMazeCell(INITIAL_POS));};const solveCellMaze=(cell)=>{if(!cell)return;cell.solved=true;cell.path=true;const prevLength=MAZE_INFO.queue.length;const nextCell=getNextCellMaze(cell,(c)=>{if(!c||c.solved)return false;const nextIndex=getNextCellMazeAdjacentIndex(cell,c);return!cell.borders[nextIndex];});if(prevLength>MAZE_INFO.queue.length)cell.path=false;return nextCell;};const getAdjPos=(cell)=>cell.circleProps?.adjacentPos||cell.adjacentPos[RENDER_INFO.currentPoly];const getNextCellMaze=(cell,cellFilter,isRandom=false)=>{const adjacentPos=getAdjPos(cell);const aCells=adjacentPos.map(getMazeCell).filter(cellFilter);if(!aCells.length){if(!MAZE_INFO.queue.length)return null;const prevPos=MAZE_INFO.queue.pop();return getMazeCell(prevPos);}MAZE_INFO.queue.push(cell.pos);return aCells[isRandom?getRandomInt(aCells.length):aCells.length-1];};const getNextCellMazeAdjacentIndex=(cell,nextCell)=>{let nextIndex=0;const adjacentPos=getAdjPos(cell);while(nextIndex<adjacentPos.length){const{i,j}=adjacentPos[nextIndex];if(nextCell.pos.i===i&&nextCell.pos.j===j)break;nextIndex++;}return nextIndex;};const mazeMove=(posIndex)=>{if(posIndex===undefined||MAZE_INFO.currentCell.borders[posIndex])return;const adjacentPos=getAdjPos(MAZE_INFO.currentCell);const nextCell=getMazeCell(adjacentPos[posIndex]);if(!nextCell)return;const oldCell=MAZE_INFO.currentCell;setCurrentCell(nextCell);const prevCell=MAZE_INFO.queue[MAZE_INFO.queue.length-1];if(nextCell.pos===prevCell){oldCell.path=false;MAZE_INFO.queue.pop();}else{oldCell.path=true;MAZE_INFO.queue.push(oldCell.pos);}return isMazeSolved();};const initMaze=()=>{for(const p of KNOWN_POLYGONS_VALUES){MAZE_POLYS_INFO[p]=configPoly(p,mazeInfos.cellHeight);}MAZE_INFO.rows=mazeInfos.rows;MAZE_INFO.columns=mazeInfos.columns;CIRCLE_INFO.cellHeight=mazeCircleInfos?.cellHeight||mazeInfos.cellHeight;CIRCLE_INFO.rows=mazeCircleInfos?.rows||MAZE_INFO.rows*2;CIRCLE_INFO.columns=mazeCircleInfos?.columns||MAZE_INFO.columns*2;const center=(CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2)/2;CIRCLE_INFO.center={x:center,y:center};};const getMazeSize=()=>{let{ySide,xSide,shouldIntercalate,hasInverted,polySide}=getMazePolyInfo();let height=MAZE_INFO.rows*mazeInfos.cellHeight;let width=MAZE_INFO.columns*(xSide*2);if(MAZE_INFO.isCircle)height=width=CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2;else{if(hasInverted)width=(MAZE_INFO.columns*polySide)/2+polySide/2+2;if(shouldIntercalate){height+=ySide;width=width*0.8;}}return{height,width};};initMaze();return{getMazeSize,mazeMove,buildMaze,solveMaze,setIsCircle:(isCircle)=>(MAZE_INFO.isCircle=isCircle),getCirclePoint:()=>(MAZE_INFO.isCircle?CIRCLE_INFO.center:null),getMazeRows,getNumCellsPerMazeRow,getMazeCell,getMazePolyInfo,};};const VECTORS={BIOME:Symbol("BIOME"),BLOCK:Symbol("BLOCK"),};const PERLIN_CONFIG={noiseResolutionBiome:75,noiseResolution:10,};const getSizeFromNoise=(size,resolution)=>{const numVectorsX=Math.floor(size/resolution)+1;const extraVectorX=size%resolution==0?0:1;return numVectorsX+extraVectorX;};const initializeVector=(vector)=>{return{width:getSizeFromNoise(vector.width,vector.resolution),height:getSizeFromNoise(vector.height,vector.resolution),vectors:[],resolution:vector.resolution,};};const vectors=({[VECTORS.BIOME]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolutionBiome,}),[VECTORS.BLOCK]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolution,}),});const updateVector=(i,j,vector)=>{const offsetPos=getChunkStart({i,j},vector.height,vector.width);for(let i=0;i<=vector.height-1;i++){const nI=i+offsetPos.i;vector.vectors[nI]=vector.vectors[nI]||[];for(let j=0;j<=vector.width-1;j++){const nJ=j+offsetPos.j;vector.vectors[nI][nJ]=getRandUnitVect();}}};const getRandUnitVect=()=>{const theta=Math.random()*2*Math.PI;return{x:Math.cos(theta),y:Math.sin(theta)};};const getValue=(i,j,vectorType)=>{const vector=vectors[vectorType];const offset=0.5/vector.resolution;const x=i/vector.resolution+offset;const y=j/vector.resolution+offset;const xF=Math.floor(x);const yF=Math.floor(y);const tlv=dotProduct(vector,x,y,xF,yF);const trv=dotProduct(vector,x,y,xF+1,yF);const blv=dotProduct(vector,x,y,xF,yF+1);const brv=dotProduct(vector,x,y,xF+1,yF+1);const lerpTop=lerp(tlv,trv,x-xF);const lerpBottom=lerp(blv,brv,x-xF);const value=lerp(lerpTop,lerpBottom,y-yF);return value;};const dotProduct=(vector,x,y,vx,vy)=>{if(!vector.vectors[vy]?.[vx])updateVector(vy,vx,vector);return dot({x:x-vx,y:y-vy},vector.vectors[vy][vx]);};const dot=(v1,v2)=>v1.x*v2.x+v1.y*v2.y;const lerp=(a,b,c)=>a+smootherstep(c)*(b-a);const smootherstep=(x)=>6*x**5-15*x**4+10*x**3;const DRAW_CONFIG={maxLayer:2,};const blockToWall=(block,point,wallParams={})=>{const polyInfo=getPolyInfo();const points=wallParams.isInverted?polyInfo.invertedPoints:polyInfo.points;const layer=wallParams.layer||0;const wallLayer=layer+1;const wallPoints=wallParams.isInverted?polyInfo.wallInvertedPoints:polyInfo.wallPoints;const commonInfos={color:block.color,shoulApplyDark:wallParams.shoulApplyDark,pos:wallParams.pos,isInverted:wallParams.isInverted,isSelectedCell:wallParams.isSelectedCell,};return{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*layer},points:wallPoints,topInfo:{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*wallLayer},points,},borderMap:wallParams.borderMap,};};const drawContainer=document.getElementById("draw-container");const canvasContainer=document.getElementById("canvas-container");const CANVAS_CONFIG={fluidSpeed:500,};const resetCanvas=()=>{const polyInfo=getPolyInfo();setCanvasSize(polyInfo.canvasHeight,polyInfo.canvasWidth);setFavicon();};const updateCanvasCss=()=>{updateConfigs();updateWeather();updateWidgets();};let filledThisRound=(new Set());let tracksCount=({});const addToTrackCount=(block)=>{if(block?.trackType)tracksCount[block.trackType]=(tracksCount[block.trackType]||0)+1;};const drawEveryCell=(baseEntity)=>{wallLayers=[];fluids=[];filledThisRound=new Set();tracksCount={};const offsetCell=baseEntity.cell.pos.j%2;const{rows,columns,shouldIntercalate}=getPolyInfo();const size=rows+columns;for(let i=-columns;i<size;i++){const baseI=i+RENDER_INFO.iOffset;for(let j=-rows;j<size;j++){let nI=baseI;const nJ=j+RENDER_INFO.jOffset;const pos={i:nI,j:nJ};if(shouldIntercalate&&offsetCell&&nJ%2===0)nI=nI+1;drawCell(loadAndGetCell(pos),contextsLayers[0],baseEntity);}}drawWalls();updateEntities();tweakFluids();updateBiomeMap();updateTracks(tracksCount);};let wallLayers=([]);const drawWalls=()=>{for(let i=1;i<DRAW_CONFIG.maxLayer;i++){const walls=wallLayers[i];clearCanvas(canvasLayers[i]);if(!walls)continue;walls.forEach((w)=>drawWall(w,contextsLayers[i]));walls.forEach((w)=>drawWallTop(w,contextsLayers[i]));}wallLayers=[];};let fluidInterval=null;let fluids=([]);const tweakFluids=debounce(()=>{clearInterval(fluidInterval);if(!fluids.length)return;const context=contextsLayers[0];fluidInterval=setInterval(()=>{fluids.forEach((fluid)=>{drawItem(context,{...fluid,color:tweakColor(fluid.color),});});},CANVAS_CONFIG.fluidSpeed);},CANVAS_CONFIG.fluidSpeed);const drawCell=(cell,context,baseEntity)=>{const polyInfo=getPolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const point=calculatePointBasedOnPos(cell.pos,isInverted,baseEntity.cell);if(isPointOutside(point,polyInfo.canvasHeight,polyInfo.canvasWidth))return;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const aCells=cell.adjacentPos[RENDER_INFO.currentPoly].map(getCell);const shoulApplyDark=cell!==baseEntity.cell&&aCells.every((c)=>c!==baseEntity.cell);const isSelectedCell=MENU_CONFIG.showSelectedCell&&cell===getSelectedCell(baseEntity);addToTrackCount(cell.wall?.block||cell.block);if(cell.wall){const wallLayer=cell.layer+1;const shouldOffset=polyInfo.hasInverted&&!cell.isInverted;if(!wallLayers[wallLayer])wallLayers[wallLayer]=[];wallLayers[wallLayer].push(blockToWall(cell.wall,point,{layer:cell.layer,isInverted,shoulApplyDark,isSelectedCell,pos:cell.pos,borderMap:aCells.reduce((acc,c,i)=>{let index=i-RENDER_INFO.rotationTurns;if(shouldOffset)index=RENDER_INFO.currentPoly-1-index;acc[getMod(index,RENDER_INFO.currentPoly)]=!c?.wall;return acc;},[]),}));return;}if(!cell.block){const aFluid=aCells.find((c)=>c?.block?.isFluid);if(aFluid&&!filledThisRound.has(aFluid.pos)){filledThisRound.add(cell.pos);cell.block=aFluid.block;cell.color=aFluid.color;}}const drawable=({point,points,isInverted,pos:cell.pos,color:cell.color,shoulApplyDark,isSelectedCell,});if(cell.block?.isFluid)fluids.push(drawable);drawItem(context,drawable);};const MAZE_CANVAS_CONFIG={strokeColor:"black",defaultColor:"white",visitedColor:"grey",pathColor:"green",currentColor:"cyan",};const drawMaze=(context,mazeObj)=>{context.strokeStyle=MAZE_CANVAS_CONFIG.strokeColor;context.lineWidth=1;const rows=mazeObj.getMazeRows();for(let i=0;i<rows;i++){const numCells=mazeObj.getNumCellsPerMazeRow(i);for(let j=0;j<numCells;j++)drawCellMaze(context,mazeObj,mazeObj.getMazeCell({i,j}));}};const drawCellMaze=(context,mazeObj,cell)=>{context.fillStyle=MAZE_CANVAS_CONFIG.defaultColor;if(cell.visited)context.fillStyle=MAZE_CANVAS_CONFIG.visitedColor;if(cell.path)context.fillStyle=MAZE_CANVAS_CONFIG.pathColor;if(cell.active)context.fillStyle=MAZE_CANVAS_CONFIG.currentColor;const circlePoint=mazeObj.getCirclePoint();if(circlePoint)drawCellMazeCircle(context,cell,circlePoint);else drawCellMazePolygon(context,mazeObj,cell);};const drawCellMazePolygon=(context,mazeObj,cell)=>{const polyInfo=mazeObj.getMazePolyInfo();const points=polyInfo.hasInverted&&cell.isInverted?polyInfo.invertedPoints:polyInfo.points;fillPolygon(context,cell.point,points);applyBorders(context,cell.point,points,cell.borders);};const drawCellMazeCircle=(context,cell,circlePoint)=>{const{topRadius,bottomRadius,topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,}=cell.circleProps;context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.closePath();context.fill();if(cell.borders[0]){context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.stroke();}if(cell.borders[1]){context.beginPath();context.moveTo(topRightPoint.x,topRightPoint.y);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.stroke();}if(cell.borders[2]){context.beginPath();context.moveTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.stroke();}if(cell.borders[3]){context.beginPath();context.moveTo(bottomLeftPoint.x,bottomLeftPoint.y);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.stroke();}};const RENDER_CONFIG ={selectedBorderColor:"white",borderColor:"black",emptyColor:"black",lineWidth:1,wallDarkness:0.5,};const canvasLayers =([]);const contextsLayers =([]);for (let i =0;i <DRAW_CONFIG.maxLayer;i++){const canvas =document.createElement("canvas");canvasContainer.appendChild(canvas);canvasLayers.push(canvas);contextsLayers.push(canvas.getContext("2d"));}const setCanvasSize =(height,width)=>{drawContainer.style.setProperty("--canvas-height",`${height}px`);canvasLayers.forEach((canvas)=>(canvas.height =height));drawContainer.style.setProperty("--canvas-width",`${width}px`);canvasLayers.forEach((canvas)=>(canvas.width =width));};const setFavicon =()=>{const link =(document.querySelector("link[rel~='icon']"));link.href=POLYGONS_IMAGES[RENDER_INFO.currentPoly];};const updateConfigs=()=>{canvasContainer.classList[MENU_CONFIG.usePerspective?"add":"remove"]("perspective");};const clearCanvas=(canvas)=>{canvas.width=canvas.width;};const drawWall=(wall,context)=>{if(!wall.borderMap||wall.borderMap.find((b)=>!!b))drawItem(context,wall,RENDER_CONFIG.wallDarkness);};const drawWallTop=(wall,context)=>{drawItem(context,wall.topInfo);context.strokeStyle=wall.isSelectedCell?RENDER_CONFIG.selectedBorderColor:RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,wall.topInfo.point,wall.topInfo.points,wall.borderMap);};const drawItem=(context,{point,points,pos,isInverted,color,shoulApplyDark,isSelectedCell},modifier)=>{context.fillStyle=color?getFillStyle(color,shoulApplyDark,modifier):RENDER_CONFIG.emptyColor;fillPolygon(context,point,points);if(MENU_CONFIG.showPos&&pos)showPos(context,pos,point,isInverted,getPolyInfo().ySide);if(isSelectedCell){context.strokeStyle=RENDER_CONFIG.selectedBorderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}else if(MENU_CONFIG.showChunks&&pos)showChunks(context,pos,point,points);};const getFillStyle=(color,shoulApplyDark=false,modifier=1)=>{if(color===EMPTY_BLOCK.color)return"transparent";if(ENTITY_INFO.timeOfDay&&shoulApplyDark)modifier=(1-ENTITY_INFO.timeOfDay/100)*modifier;const{r,g,b}=color;return`rgb(${r *modifier},${g *modifier},${b *modifier})`;};const fillPolygon=(context,{x,y},points)=>{context.beginPath();for(const point of points){context.lineTo(x+point.x,y+point.y);}context.closePath();context.fill();};const applyBorders=(context,{x,y},points,map,ignoreLast)=>{for(let i=0;i<points.length;i++){if(!map?.length||map[i]){const point=points[i];let nextPoint=points[i+1];if(!nextPoint){if(ignoreLast)return;nextPoint=points[0];}context.beginPath();context.moveTo(x+point.x,y+point.y);context.lineTo(x+nextPoint.x,y+nextPoint.y);context.stroke();}}};const showPos=(context,pos,point,isInverted,ySide)=>{context.fillStyle="black";context.font=`bold ${ySide /2}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${pos.i},${pos.j}`,point.x,isInverted?point.y+ySide/2:point.y);};const showChunks=(context,pos,point,points)=>{if(pos.i%GENERATION_CONFIG.chunkSize===0||pos.j%GENERATION_CONFIG.chunkSize===0){context.strokeStyle=RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}};const audios=({});const TRACK_FILES={[TRACK_TYPES.TRACK1]:"sounds/blocks/track1.wav",[TRACK_TYPES.TRACK2]:"sounds/blocks/track2.wav",[TRACK_TYPES.TRACK3]:"sounds/blocks/track3.wav",[TRACK_TYPES.TRACK4]:"sounds/blocks/track4.wav",[TRACK_TYPES.TRACK5]:"sounds/blocks/track5.wav",[TRACK_TYPES.TRACK6]:"sounds/blocks/track6.wav",[TRACK_TYPES.TRACK7]:"sounds/blocks/track7.wav",[TRACK_TYPES.TRACK8]:"sounds/blocks/track8.wav",[TRACK_TYPES.TRACK11]:"sounds/blocks/track11.wav",[TRACK_TYPES.TRACK14]:"sounds/blocks/track14.wav",[TRACK_TYPES.TRACK15]:"sounds/blocks/track15.wav",[TRACK_TYPES.TRACK16]:"sounds/blocks/track16.wav",};Object.entries(TRACK_FILES).forEach(([track,path])=>{const pan=+track.replace("TRACK","")%2?-1:1;const ctx=new AudioContext();const srcNode=ctx.createBufferSource();const gainNode=ctx.createGain();gainNode.gain.value=0;gainNode.connect(ctx.destination);const ambientPan=ctx.createStereoPanner();ambientPan.pan.value=pan;ambientPan.connect(gainNode);audios[track]={srcNode,gainNode};fetch(path,{mode:"cors"}).then((resp)=>resp.arrayBuffer()).then((buffer)=>ctx.decodeAudioData(buffer,(abuffer)=>{srcNode.buffer=abuffer;srcNode.connect(ambientPan);srcNode.loop=true;}));});const audiosList=Object.values(audios);const TRACK_LIST=Object.keys(TRACK_FILES);let audioStarted=false;const updateTracks=(tracksCount)=>{if(MENU_CONFIG.music){const polyInfo=getPolyInfo();if(!audioStarted){audioStarted=true;audiosList.forEach((a)=>a.srcNode.start());}const max=polyInfo.rows*polyInfo.columns*1.2;TRACK_LIST.forEach((track)=>{const{gainNode}=audios[track];gainNode.gain.value=(tracksCount[track]||0)/max;});}else{if(audioStarted){audioStarted=false;audiosList.forEach((a)=>a.srcNode.stop());}}};const fishingCanvas=(document.getElementById("fishing-canvas"));const FISHING_CONFIG={mazeSize:7,cellHeight:30,circleMazeSize:7,circleCellHeight:30,isCircleProbability:0.5,};const fishingContext=fishingCanvas.getContext("2d");let fishingMazeObj=(null);const setMazeCanvasSize=()=>{const size=fishingMazeObj.getMazeSize();fishingCanvas.height=size.height;fishingCanvas.width=size.width;};const startFishing=()=>{if(!fishingMazeObj)fishingMazeObj=createMazeObj({cellHeight:FISHING_CONFIG.cellHeight,rows:FISHING_CONFIG.mazeSize,columns:FISHING_CONFIG.mazeSize,},{cellHeight:FISHING_CONFIG.circleCellHeight,rows:FISHING_CONFIG.circleMazeSize,columns:FISHING_CONFIG.circleMazeSize,});fishingCanvas.classList.remove("hide");fishingMazeObj.setIsCircle(Math.random()>FISHING_CONFIG.isCircleProbability);setMazeCanvasSize();fishingMazeObj.buildMaze();if(MENU_CONFIG.fishingMazeSolved)fishingMazeObj.solveMaze();drawMaze(fishingContext,fishingMazeObj);drawMaze(fishingContext,fishingMazeObj);};const MAP_CONFIG={currentPosRatio:5,posRatio:5,fullScreenPosRatio:50,playerColor:({r:212,g:172,b:156,}),xRatio:0,yRatio:0,};const mapCanvas=(document.getElementById("map-canvas"));const mapContext=mapCanvas.getContext("2d");const resetBiomeMap=()=>{let size=0;if(fullMap){size=Math.min(window.innerWidth,window.innerHeight)*0.96;MAP_CONFIG.currentPosRatio=MAP_CONFIG.fullScreenPosRatio;}else{size=mapCanvas.parentElement.offsetWidth;MAP_CONFIG.currentPosRatio=MAP_CONFIG.posRatio;}mapCanvas.width=size;mapCanvas.height=size;MAP_CONFIG.xRatio=mapCanvas.width/(MAP_CONFIG.currentPosRatio*2+1);MAP_CONFIG.yRatio=mapCanvas.height/(MAP_CONFIG.currentPosRatio*2+1);};const updateBiomeMap=()=>{clearCanvas(mapCanvas);const biomes=getBiomeMap();const iOffset=Math.round(RENDER_INFO.iOffset/GENERATION_CONFIG.chunkSize);const jOffset=Math.round(RENDER_INFO.jOffset/GENERATION_CONFIG.chunkSize);const iNegLimit=iOffset-MAP_CONFIG.currentPosRatio;const iPosLimit=iOffset+MAP_CONFIG.currentPosRatio+1;const jNegLimit=jOffset-MAP_CONFIG.currentPosRatio;const jPosLimit=jOffset+MAP_CONFIG.currentPosRatio+1;for(let i=iNegLimit;i<=iPosLimit;i++){const nI=i-iOffset;for(let j=jNegLimit;j<=jPosLimit;j++){const nJ=j-jOffset;const biome=biomes[i]?.[j];if(!biome)continue;createRect({i:nI,j:nJ},biome.mapColor);}}createRect({i:0,j:0},MAP_CONFIG.playerColor);};let fullMap=false;const toggleFullMap=(toggle=!fullMap)=>{fullMap=toggle;if(toggle){mapCanvas.classList.add("full-screen");resetBiomeMap();updateBiomeMap();}else{mapCanvas.classList.remove("full-screen");resetBiomeMap();updateBiomeMap();}};const createRect=(pos,color)=>{mapContext.fillStyle=getFillStyle(color);mapContext.fillRect((MAP_CONFIG.currentPosRatio+pos.j)*MAP_CONFIG.xRatio,(MAP_CONFIG.currentPosRatio+pos.i)*MAP_CONFIG.yRatio,MAP_CONFIG.xRatio,MAP_CONFIG.yRatio);};const placeCanvas=(document.getElementById("place-canvas"));const placeContext=placeCanvas.getContext("2d");const resetPlace=()=>{placeCanvas.width=placeCanvas.parentElement.offsetWidth;placeCanvas.height=placeCanvas.parentElement.offsetHeight;};const addBlockToToolbar=(block)=>{const isEmptyBlock=!block;clearCanvas(placeCanvas);if(isEmptyBlock)block={color:EMPTY_BLOCK.color,block:EMPTY_BLOCK};const polyInfo=getPolyInfo();const wall=blockToWall(block,{x:placeCanvas.width/2,y:placeCanvas.height/1.75},{isInverted:polyInfo.hasInverted});drawWall(wall,placeContext);applyBorders(placeContext,wall.point,wall.points,[],true);drawWallTop(wall,placeContext);};const resetToolbar=()=>{resetBiomeMap();resetPlace();};const CLOUDS_CONFIG={num:4,rows:3,columns:3,durationMult:30,offsetSize:6,offset:0,};const POLYGONS_CLASS_MAP={[KNOWN_POLYGONS.TRIANGLE]:"triangle",[KNOWN_POLYGONS.SQUARE]:"square",[KNOWN_POLYGONS.HEXAGON]:"hex",};const CLOUDS_DIRECTION_MAP={[MOVEMENT.RIGHT]:-CLOUDS_CONFIG.offsetSize,[MOVEMENT.LEFT]:CLOUDS_CONFIG.offsetSize,};const cloudsContainer=document.getElementById("clouds-container");let clouds=([]);const updateClouds=(direction)=>{if(MENU_CONFIG.clouds){if(!clouds.length){createClouds();offsetClouds(MOVEMENT.RIGHT);}setCloudShape();offsetClouds(direction);}else{cloudsContainer.classList.add("off");}};const setCloudShape=()=>{const{currentPoly,cellHeight}=RENDER_INFO;const size=Math.min(cellHeight*4,cloudsContainer.offsetWidth/(CLOUDS_CONFIG.num*CLOUDS_CONFIG.columns*1.5));cloudsContainer.className=POLYGONS_CLASS_MAP[currentPoly];cloudsContainer.style.setProperty("--clouds-default-size",`${size}px`);};const offsetClouds=(direction)=>{const offsetSize=CLOUDS_DIRECTION_MAP[direction];if(!offsetSize)return;CLOUDS_CONFIG.offset+=offsetSize;const offsetLeft=getMod(CLOUDS_CONFIG.offset,cloudsContainer.offsetWidth);const width=cloudsContainer.offsetWidth/CLOUDS_CONFIG.num;const defaultOffsetLeft=cloudsContainer.offsetWidth/4;cloudsContainer.style.setProperty("--clouds-offset-left",`${getMod(CLOUDS_CONFIG.offset,width)-defaultOffsetLeft}px`);const offset=Math.floor(offsetLeft/width);for(let index=0;index<clouds.length;index++){clouds[index].style.setProperty("--clouds-order",`${getMod(index +offset,CLOUDS_CONFIG.num)+1}`);}};const createClouds=()=>{const min=1-CLOUDS_CONFIG.num/10;const max=Math.min(min+0.5,1);for(let i=0;i<CLOUDS_CONFIG.num;i++){const cloud=document.createElement("div");cloud.className="cloud";const scale=correctRoundError(getRandomFloat(min,max),2);const duration=Math.round(scale*CLOUDS_CONFIG.durationMult);cloud.style.setProperty("--clouds-scale",`${scale}`);cloud.style.setProperty("--clouds-animation-duration",`${duration}s`);cloudsContainer.appendChild(cloud);clouds.push(cloud);for(let j=0;j<CLOUDS_CONFIG.rows;j++){const cloudRow=document.createElement("div");cloudRow.className="cloud-row";cloud.appendChild(cloudRow);for(let z=0;z<CLOUDS_CONFIG.columns;z++){const cloudShape=document.createElement("div");cloudShape.className="cloud-shape";cloudRow.appendChild(cloudShape);}}}};const rainContainer =document.getElementById("rain-container");const BIOME_RAIN_MAP ={DEFAULT:"../images/weather/rain.gif",[BIOME_TYPES.SNOW]:"../images/weather/snow.gif",};const rainAudio =new Audio("sounds/weather/rain.mp3");rainAudio.volume =0.25;rainAudio.loop =true;const lightningAudio =new Audio("sounds/weather/lightning.mp3");lightningAudio.volume =0.25;let isRainOn =false;const updateRain =()=>{if (MENU_CONFIG.rain){if (!isRainOn){clearLightning();isRainOn =true;rainAudio.play();rainContainer.classList.remove("hide");const size =RENDER_INFO.cellHeight *10;rainContainer.style.setProperty("--rain-size",`${size}px`);createLightining();}updateRainImg();}else {if (isRainOn){clearLightning();isRainOn =false;rainAudio.pause();rainContainer.classList.add("hide");}}};let lightningInterval =null;const createLightining =()=>{clearTimeout(lightningInterval);const secs =getRandomFloat(10000,30000);lightningInterval =setTimeout(()=>{rainContainer.classList.remove("lightning");rainContainer.offsetHeight;rainContainer.classList.add("lightning");lightningAudio.play();createLightining();},secs);};const clearLightning =()=>{clearTimeout(lightningInterval);rainContainer.classList.remove("lightning");};const updateRainImg =()=>{const gif =`url("${BIOME_RAIN_MAP[PLAYER_ENTITY.cell.block.biomeType]||BIOME_RAIN_MAP.DEFAULT }")`;const currentGif=rainContainer.style.getPropertyValue("--rain-img");if(gif!==currentGif)rainContainer.style.setProperty("--rain-img",gif);};const updateWeather=(direction)=>{updateRain();updateClouds(direction);};const CLOCK_CONFIG={passHour:0.25,midNightHour:60,};const analogClock=document.getElementById("analog-clock");const digitalClock=document.getElementById("digital-clock");const hourTensSegments=document.querySelectorAll("#digital-clock-hours .digit-tens .segment");const hourUnitsSegments=document.querySelectorAll("#digital-clock-hours .digit-units .segment");const minuteTensSegments=document.querySelectorAll("#digital-clock-minutes .digit-tens .segment");const minuteUnitsSegments=document.querySelectorAll("#digital-clock-minutes .digit-units .segment");const colons=document.getElementById("digital-clock-colons");setInterval(()=>{colons.classList.toggle("active");},750);const updateClock=()=>{const{hour,hour24,minute}=getTime();if(MENU_CONFIG.digitalClock){digitalClock.classList.remove("hide");analogClock.classList.add("hide");setNumber(hourTensSegments,Math.floor(hour24/10));setNumber(hourUnitsSegments,Math.floor(hour24%10));setNumber(minuteTensSegments,Math.floor(minute/10));setNumber(minuteUnitsSegments,Math.floor(minute%10));}else{analogClock.classList.remove("hide");digitalClock.classList.add("hide");analogClock.style.setProperty("--clock-hour-rotate",`${hour *30 +minute *0.5}deg`);analogClock.style.setProperty("--clock-minute-rotate",`${minute *6}deg`);}};const passTime=()=>{ENTITY_INFO.timeOfDay+=CLOCK_CONFIG.passHour;if(ENTITY_INFO.timeOfDay>=CLOCK_CONFIG.midNightHour||ENTITY_INFO.timeOfDay<=0){CLOCK_CONFIG.passHour=-CLOCK_CONFIG.passHour;}updateClock();};const getTime=()=>{const hourRaw=(12*ENTITY_INFO.timeOfDay)/CLOCK_CONFIG.midNightHour;let hour=Math.floor(hourRaw);let minute=Math.round((hourRaw-hour)*100);minute=Math.floor(minute*0.6);minute=CLOCK_CONFIG.passHour>0?minute:60-minute;minute=getMod(minute,60);if(CLOCK_CONFIG.passHour<0)hour=Math.max((minute?11:12)-hour,0);const hour24=CLOCK_CONFIG.passHour>0?hour+12:hour;return{hour,hour24,minute};};const setNumber=(segments,value)=>{segments.forEach((el)=>{el.classList[el.classList.contains(`n${value}`)?"add":"remove"]("active");});};const compass=document.getElementById("compass");const COMPASS_CONFIG={rotateDelay:750,};const updateCompass=()=>{const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;compass.style.setProperty("--compass-rotate",`${-angle}deg`);};const entitiesContainer=document.getElementById("entities");const rotateCanvas=(deg,rotateDelay)=>{rotateElement(entitiesContainer,-deg,rotateDelay);rotateElement(drawContainer,deg,rotateDelay);};const resetRotateCanvas=()=>{rotateElement(entitiesContainer);rotateElement(drawContainer);};const rotateElement=(element,deg,rotateDelay)=>{if(rotateDelay)element.style.setProperty("--transition-duration",`${rotateDelay}ms`);if(deg)element.style.setProperty("--rotate-deg",`${deg}deg`);element.classList[deg?"add":"remove"]("rotate");element.classList[deg?"add":"remove"]("zoom-in");};const updateWidgets=()=>{updateClock();updateCompass();};const digAudio=new Audio("sounds/actions/dig.mp3");digAudio.volume=0.25;const rotateAudio=new Audio("sounds/actions/rotate.mp3");rotateAudio.volume=0.25;let canRotate=true;const rotate=(orientation)=>{if(canRotate){canRotate=false;RENDER_INFO.rotationTurns=PLAYER_ENTITY.selectedCellIndex=getMod(RENDER_INFO.rotationTurns+orientation,RENDER_INFO.currentPoly);if(MENU_CONFIG.rotationAnimation){rotateCanvas((360/RENDER_INFO.currentPoly)*-orientation,COMPASS_CONFIG.rotateDelay);rotateAudio.play();}updateCompass();resetDirection();setTimeout(()=>{if(MENU_CONFIG.rotationAnimation)resetRotateCanvas();drawEveryCell(PLAYER_ENTITY);canRotate=true;},COMPASS_CONFIG.rotateDelay);}};const getNextCellIndexBasedOnCode=(code,useDiagonal)=>{const aIndex=getMovementMap(PLAYER_ENTITY.cell,useDiagonal)[code];if(aIndex===undefined)return;return getMod(aIndex,RENDER_INFO.currentPoly);};let lastMovement=(null);let lastSelection=(null);const moveBaseOnCode=(direction,useDiagonal)=>{if(!direction)return;if(lastMovement!==direction){lastMovement=direction;makeEntityRun(PLAYER_ENTITY,lastMovement);}const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined)return;const nextPos=getPosByIndex(PLAYER_ENTITY.cell,aModI);if(!nextPos)return;const nextCell=getCell(nextPos);if(cellIsBlocked(nextCell,PLAYER_ENTITY))return;move(nextCell);updateWeather(direction);};const MOVEMENT_VALUES=Object.values(MOVEMENT);const stopMoving=()=>{if(lastMovement){if(getPolyInfo().hasInverted){const movementMap=getMovementMap(PLAYER_ENTITY.cell);for(const movement of MOVEMENT_VALUES){if(movementMap[movement]===PLAYER_ENTITY.selectedCellIndex){lastSelection=movement;break;}}}updateEntityDirection(PLAYER_ENTITY,lastSelection);lastMovement=null;}};const changeSelectedOnCode=(direction,useDiagonal)=>{if(!direction)return;lastSelection=direction;const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined||aModI===PLAYER_ENTITY.selectedCellIndex)return;PLAYER_ENTITY.selectedCellIndex=aModI;if(MENU_CONFIG.showSelectedCell)drawEveryCell(PLAYER_ENTITY);updateEntityDirection(PLAYER_ENTITY,lastSelection);};const getNextBlockToPlace=()=>PLAYER_ENTITY.pickedCells[PLAYER_ENTITY.pickedCells.length-1];const getNextPolygon=()=>KNOWN_POLYGONS_VALUES[(KNOWN_POLYGONS_VALUES.indexOf(RENDER_INFO.currentPoly)+1)%KNOWN_POLYGONS_VALUES.length];const changePolySides=()=>{RENDER_INFO.currentPoly=getNextPolygon();RENDER_INFO.rotationTurns=0;PLAYER_ENTITY.selectedCellIndex=0;updateCompass();resetDirection();resetMap();addBlockToToolbar(getNextBlockToPlace());};const resetDirection=()=>{lastSelection=MOVEMENT.UP;updateEntityDirection(PLAYER_ENTITY,lastSelection);};const updateAndGetSelectedCell=()=>{updateEntityDirection(PLAYER_ENTITY,lastSelection);return getSelectedCell(PLAYER_ENTITY);};const dig=()=>{const selectedCell=updateAndGetSelectedCell();if(!selectedCell?.block)return;if(selectedCell.entityType){removeEntitiesFromCell(selectedCell);return;}if(selectedCell.block.isFluid)return;const pickedBlock={...(selectedCell.wall||selectedCell)};PLAYER_ENTITY.pickedCells.push(pickedBlock);addBlockToToolbar(pickedBlock);digAudio.play();if(selectedCell.wall){selectedCell.wall=null;}else{selectedCell.block=null;selectedCell.color=null;}move();};const place=()=>{if(!PLAYER_ENTITY.pickedCells.length)return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.wall||selectedCell.entityType)return;digAudio.play();placeBlock(selectedCell);move();};const placeBlock=(cell,block,color)=>{if(!cell||!!cell.entityType)return;if(!block){const cellBlock=PLAYER_ENTITY.pickedCells.pop();block=cellBlock.block;color=cellBlock.color;addBlockToToolbar(getNextBlockToPlace());}if(cell.block&&!cell.block.isFluid){cell.wall={block:block,color:color};}else{cell.block=block;cell.color=color;}};const useBoat=()=>{const selectedCell=updateAndGetSelectedCell();const canMove=!selectedCell.wall&&selectedCell.block;if(PLAYER_ENTITY.connectedEntities[ENTITY_TYPES.BOAT]){if(!selectedCell?.block?.isFluid&&canMove){getOutBoat(PLAYER_ENTITY);move(selectedCell);}return;}if(selectedCell.entityType===ENTITY_TYPES.BOAT){getInBoat(PLAYER_ENTITY);move(selectedCell);}else if(canMove){addBoat(selectedCell,PLAYER_ENTITY);}};const useFishingRod=()=>{startFishing();};const resetMap=()=>{addBlockToToolbar(getNextBlockToPlace());setEntitiesSize();resetCanvas();moveCurrentCell(getCenterCell(),PLAYER_ENTITY.cell);drawEveryCell(PLAYER_ENTITY);updateWeather();};const MOVEMENT_CONFIG={velocity:25,};const getCleanPos=(pos)=>({i:pos?.i||0,j:pos?.j||0});const moveCurrentCell=(oldCell,nextCell)=>{const oldPos=getCleanPos(oldCell?.pos);const nextPos=getCleanPos(nextCell?.pos);RENDER_INFO.iOffset+=nextPos.i-oldPos.i;RENDER_INFO.jOffset+=nextPos.j-oldPos.j;moveEntityToCell(PLAYER_ENTITY,nextCell);};let canMove=true;const move=(nextCell)=>{if(canMove){canMove=false;if(nextCell)moveCurrentCell(PLAYER_ENTITY.cell,nextCell);if(MENU_CONFIG.passTime)passTime();setTimeout(()=>{drawEveryCell(PLAYER_ENTITY);killEntitiesByTimeOfDay();moveEntities(PLAYER_ENTITY.cell);spawnEntities(PLAYER_ENTITY.cell);canMove=true;},1000/MOVEMENT_CONFIG.velocity);}};const findAccessibleCell=(cell,entity)=>{let accessibleCell=cell;while(cellIsBlocked(accessibleCell,entity)){accessibleCell=loadAndGetCell({i:accessibleCell.pos.i+1,j:accessibleCell.pos.j,});}return accessibleCell;};const start=()=>{addEntity(PLAYER_ENTITY);configPolys();resetGrid();resetBiomes();removeGeneratedEntities();updateCanvasCss();resetDirection();PLAYER_ENTITY.cell=findAccessibleCell(loadAndGetCell(INITIAL_POS),PLAYER_ENTITY);resetToolbar();resetMap();};const resetSize=debounce((newSize)=>{RENDER_INFO.cellHeight=newSize||RENDER_INFO.cellHeight;configPolys();resetToolbar();resetMap();});const CONTROLS_CONFIG={minZoom:12,maxZoom:120,};const addDebugBlockToPoint=({x,y})=>{if(!MENU_CONFIG.debugMode||RENDER_INFO.rotationTurns)return;if(MENU_CONFIG.usePerspective){x-=175;y+=60;}const cell=getCell(calculatePosBasedOnPoint({x,y}));const block=BLOCKS.ROCK;if(cell.wall)cell.wall=null;else placeBlock(cell,block,block.color);drawEveryCell(PLAYER_ENTITY);};const getJFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(x)=>(x-xSide)/(polySide/2);case KNOWN_POLYGONS.HEXAGON:return(x)=>(x-xSide)/(xSide+polySide/2);case KNOWN_POLYGONS.SQUARE:default:return(x)=>(x-xSide)/(xSide*2);}};const calcI=(y,ySide,shouldIntercalate,evenJ)=>{let dividend=y-ySide;if(shouldIntercalate){if(PLAYER_ENTITY.cell.pos.j%2&&!evenJ){dividend+=ySide;}else if(!(PLAYER_ENTITY.cell.pos.j%2)&&evenJ){dividend-=ySide;}}return dividend/(ySide*2);};const calculatePosBasedOnPoint=({x,y})=>{const{xSide,ySide,shouldIntercalate,polySide}=getPolyInfo();let j=getJFn(RENDER_INFO.currentPoly,polySide,xSide)(x);j=Math.round(j+(RENDER_INFO.jOffset||0));let i=calcI(y,ySide,shouldIntercalate,!!(j%2));i+=RENDER_INFO.iOffset||0;return{i:Math.round(i),j:j};};const SELECT_OPTIONS={mapGeneration:Object.entries(MAP_GENERATION),};document.querySelectorAll("#menu label").forEach((l)=>{const config=(l).htmlFor;const element=(document.getElementById(config));if(!element)return;if(element.type==="checkbox"){const check=(element);check.checked=MENU_CONFIG[config];check.onchange=()=>{MENU_CONFIG[config]=check.checked;updateCanvasCss();drawEveryCell(PLAYER_ENTITY);check.blur();};}else if(element.tagName==="SELECT"){const select=(element);SELECT_OPTIONS[config].forEach(([key,value])=>{const option=document.createElement("option");option.value=value;option.innerHTML=key;select.appendChild(option);});select.value=MENU_CONFIG[config];select.onchange=()=>{MENU_CONFIG[config]=select.value;start();select.blur();};}});const teleportationIElement=(document.getElementById("teleportation-i"));const teleportationJElement=(document.getElementById("teleportation-j"));const teleportationBtn=(document.getElementById("teleport"));teleportationBtn.onclick=()=>{const i=+teleportationIElement.value;const j=+teleportationJElement.value;move(loadAndGetCell({i,j}));teleportationBtn.blur();};let zoomDist=0;canvasContainer.ontouchstart=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];zoomDist=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);return;}};canvasContainer.ontouchmove=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];const nZoomDist=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);if(nZoomDist>zoomDist&&RENDER_INFO.cellHeight<CONTROLS_CONFIG.maxZoom){resetSize(RENDER_INFO.cellHeight+1);}else if(nZoomDist<zoomDist&&RENDER_INFO.cellHeight>CONTROLS_CONFIG.minZoom){resetSize(RENDER_INFO.cellHeight-1);}zoomDist=nZoomDist;}};canvasContainer.ontouchend=()=>{zoomDist=0;};document.getElementById("change-poly").onclick=()=>{changePolySides();updatePolyImages();};document.getElementById("rotate-left").onclick=()=>rotate(-1);document.getElementById("rotate-right").onclick=()=>rotate(1);const currentPoly=(document.getElementById("current-poly"));const nextPoly=(document.getElementById("next-poly"));const updatePolyImages=()=>{currentPoly.src=POLYGONS_IMAGES[RENDER_INFO.currentPoly];nextPoly.src=POLYGONS_IMAGES[getNextPolygon()];};updatePolyImages();const SELECTION_STICK_CONFIG={touchThreshold:20,};const selectionStickLeft=document.getElementById("selection-stick-left");const selectionStickRight=document.getElementById("selection-stick-right");const maxPoint=selectionStickLeft.offsetWidth/1.25;const minPoint=selectionStickLeft.offsetWidth/5;const midPoint=minPoint+(maxPoint-minPoint)/2;const maxMidPoint=midPoint+SELECTION_STICK_CONFIG.touchThreshold;const minMidPoint=midPoint-SELECTION_STICK_CONFIG.touchThreshold;let leftStickRect=selectionStickLeft?.getBoundingClientRect();let rightStickRect=selectionStickRight?.getBoundingClientRect();const updateMobileDivs=()=>{leftStickRect=selectionStickLeft?.getBoundingClientRect();rightStickRect=selectionStickRight?.getBoundingClientRect();};const moveStick=(e,stickRect,stickElement)=>{e=e||(window.event);e.preventDefault();e.stopPropagation();const{clientX,clientY}=e.touches[0];let finalX=clientX-stickRect.left;let finalY=clientY-stickRect.top;finalX=Math.min(finalX,maxPoint);finalX=Math.max(finalX,minPoint);finalY=Math.min(finalY,maxPoint);finalY=Math.max(finalY,minPoint);stickElement.style.setProperty("--selection-stick-left",`${finalX}px`);stickElement.style.setProperty("--selection-stick-top",`${finalY}px`);let code=null;const useDiagonal=finalY>maxMidPoint;if(useDiagonal)code=MOVEMENT.DOWN;if(finalY<minMidPoint)code=MOVEMENT.UP;if(finalX>maxMidPoint)code=MOVEMENT.RIGHT;if(finalX<minMidPoint)code=MOVEMENT.LEFT;return{code,useDiagonal};};selectionStickLeft.ontouchstart=selectionStickLeft.ontouchmove=(e)=>{const{code,useDiagonal}=moveStick(e,leftStickRect,selectionStickLeft);if(code)changeSelectedOnCode(code,useDiagonal);};let rightStickInfo=({});const updateRightStickInfo=(e)=>(rightStickInfo=moveStick(e,rightStickRect,selectionStickRight));selectionStickRight.ontouchstart=(e)=>{clearInterval(rightStickInfo.interval);updateRightStickInfo(e);rightStickInfo.interval=setInterval(()=>{if(rightStickInfo.code)moveBaseOnCode(rightStickInfo.code,rightStickInfo.useDiagonal);else stopMoving();},100);};selectionStickRight.ontouchmove=updateRightStickInfo;document.ontouchend=()=>{selectionStickLeft?.style.removeProperty("--selection-stick-left");selectionStickLeft?.style.removeProperty("--selection-stick-top");selectionStickRight?.style.removeProperty("--selection-stick-left");selectionStickRight?.style.removeProperty("--selection-stick-top");stopMoving();clearInterval(rightStickInfo.interval);rightStickInfo={code:null,useDiagonal:null,interval:null};};const KEY_MOVEMENT_MAP={["KeyW"]:MOVEMENT.UP,["KeyA"]:MOVEMENT.LEFT,["KeyS"]:MOVEMENT.DOWN,["KeyD"]:MOVEMENT.RIGHT,};const ARROW_MOVEMENT_MAP={["ArrowUp"]:MOVEMENT.UP,["ArrowLeft"]:MOVEMENT.LEFT,["ArrowDown"]:MOVEMENT.DOWN,["ArrowRight"]:MOVEMENT.RIGHT,};const TOOLBAR_ACTIONS=[undefined,document.getElementById("toolbar-dig"),document.getElementById("toolbar-place"),document.getElementById("toolbar-fishing"),document.getElementById("toolbar-boat"),document.getElementById("toolbar-map"),];const MOVEMENT_KEYS=Object.keys(KEY_MOVEMENT_MAP);const menuToggle=(document.getElementById("menuToggle"));const closeDebugMenu=()=>(menuToggle.checked=false);document.onkeydown=(e)=>{e=e||(window.event);const targetElement=(e.target);if(targetElement.tagName==="INPUT"&&targetElement.id!=="menuToggle")return;if(e.code.startsWith("Arrow"))return moveBaseOnCode(ARROW_MOVEMENT_MAP[e.code],e.altKey);if(e.code.startsWith("Digit")||e.code.startsWith("Numpad"))return updateToolbarSelected(+e.code.replace(/Numpad|Digit/gi,""));if(MOVEMENT_KEYS.includes(e.code))return changeSelectedOnCode(KEY_MOVEMENT_MAP[e.code],e.altKey);if(e.code==="KeyQ")return rotate(-1);if(e.code==="KeyE")return rotate(1);if(e.code==="KeyF")return TOOLBAR_ACTIONS[selectedIndex].click();if(e.code.includes("Shift"))return changePolySides();if(e.code==="Space")return move();if(e.code==="Escape"){closeDebugMenu();toggleFullMap(false);}};document.onkeyup=()=>{stopMoving();};const heightSlider=(document.getElementById("zoom"));heightSlider.value=`${RENDER_INFO.cellHeight}`;heightSlider.min=`${CONTROLS_CONFIG.minZoom}`;heightSlider.max=`${CONTROLS_CONFIG.maxZoom}`;heightSlider.oninput=()=>{resetSize(+heightSlider.value);heightSlider.blur();};let selectedIndex=1;const updateToolbarSelected=(keyIndex)=>{const element=TOOLBAR_ACTIONS[keyIndex];if(!element)return;TOOLBAR_ACTIONS[selectedIndex].classList.remove("toolbar-selected");selectedIndex=keyIndex;element.classList.add("toolbar-selected");};TOOLBAR_ACTIONS[1].onclick=()=>dig();TOOLBAR_ACTIONS[2].onclick=()=>place();TOOLBAR_ACTIONS[3].onclick=()=>useFishingRod();TOOLBAR_ACTIONS[4].onclick=()=>useBoat();TOOLBAR_ACTIONS[5].onclick=()=>toggleFullMap();document.onwheel=(e)=>{e=e||(window.event);updateToolbarSelected(e.deltaY<0?selectedIndex-1:selectedIndex+1);};canvasContainer.onclick=(e)=>{e=e||(window.event);if(MENU_CONFIG.debugMode){const{left,top}=canvasContainer.getBoundingClientRect();const x=e.clientX-left;const y=e.clientY-top;addDebugBlockToPoint({x,y});}closeDebugMenu();};start();window.onresize=()=>{updateMobileDivs();resetSize();};