const correctRoundError=(num,estimation=4)=>Math.round(num*10**estimation)/10**estimation;const tweakColor=({r,g,b})=>{const randSaturation=Math.random()*0.1+0.95;const randBrightness=Math.random()*0.1+0.95;r=Math.round(r*randSaturation*randBrightness);g=Math.round(g*randSaturation*randBrightness);b=Math.round(b*randSaturation*randBrightness);return{r,g,b};};const getMod=(number,mod)=>(mod+(number%mod))%mod;const debounce=(fn,timeout=10)=>{let timer;return(...args)=>{clearTimeout(timer);timer=setTimeout(()=>{fn.apply(this,args);},timeout);};};const isPointOutside=(point,canvasHeight,canvasWidth)=>point.x<1||point.y<1||point.x>canvasWidth-1||point.y>canvasHeight-1;const getPosDistance=(pos1,pos2)=>Math.sqrt((pos1.i-pos2.i)**2+(pos1.j-pos2.j)**2);const getRandomFloat=(min,max)=>Math.random()*(max-min)+min;const getRandomInt=(max)=>Math.floor(getRandomFloat(0,max));const correctRoundError=(num,estimation=4)=>Math.round(num*10**estimation)/10**estimation;const tweakColor=({r,g,b})=>{const randSaturation=Math.random()*0.1+0.95;const randBrightness=Math.random()*0.1+0.95;r=Math.round(r*randSaturation*randBrightness);g=Math.round(g*randSaturation*randBrightness);b=Math.round(b*randSaturation*randBrightness);return{r,g,b};};const getMod=(number,mod)=>(mod+(number%mod))%mod;const debounce=(fn,timeout=10)=>{let timer;return(...args)=>{clearTimeout(timer);timer=setTimeout(()=>{fn.apply(this,args);},timeout);};};const isPointOutside=(point,canvasHeight,canvasWidth)=>point.x<1||point.y<1||point.x>canvasWidth-1||point.y>canvasHeight-1;const getPosDistance=(pos1,pos2)=>Math.sqrt((pos1.i-pos2.i)**2+(pos1.j-pos2.j)**2);const getRandomFloat=(min,max)=>Math.random()*(max-min)+min;const getRandomInt=(max)=>Math.floor(getRandomFloat(0,max));const correctRoundError=(num,estimation=4)=>Math.round(num*10**estimation)/10**estimation;const tweakColor=({r,g,b})=>{const randSaturation=Math.random()*0.1+0.95;const randBrightness=Math.random()*0.1+0.95;r=Math.round(r*randSaturation*randBrightness);g=Math.round(g*randSaturation*randBrightness);b=Math.round(b*randSaturation*randBrightness);return{r,g,b};};const getMod=(number,mod)=>(mod+(number%mod))%mod;const debounce=(fn,timeout=10)=>{let timer;return(...args)=>{clearTimeout(timer);timer=setTimeout(()=>{fn.apply(this,args);},timeout);};};const isPointOutside=(point,canvasHeight,canvasWidth)=>point.x<1||point.y<1||point.x>canvasWidth-1||point.y>canvasHeight-1;const getPosDistance=(pos1,pos2)=>Math.sqrt((pos1.i-pos2.i)**2+(pos1.j-pos2.j)**2);const getRandomFloat=(min,max)=>Math.random()*(max-min)+min;const getRandomInt=(max)=>Math.floor(getRandomFloat(0,max));const correctRoundError=(num,estimation=4)=>Math.round(num*10**estimation)/10**estimation;const tweakColor=({r,g,b})=>{const randSaturation=Math.random()*0.1+0.95;const randBrightness=Math.random()*0.1+0.95;r=Math.round(r*randSaturation*randBrightness);g=Math.round(g*randSaturation*randBrightness);b=Math.round(b*randSaturation*randBrightness);return{r,g,b};};const getMod=(number,mod)=>(mod+(number%mod))%mod;const debounce=(fn,timeout=10)=>{let timer;return(...args)=>{clearTimeout(timer);timer=setTimeout(()=>{fn.apply(this,args);},timeout);};};const isPointOutside=(point,canvasHeight,canvasWidth)=>point.x<1||point.y<1||point.x>canvasWidth-1||point.y>canvasHeight-1;const getPosDistance=(pos1,pos2)=>Math.sqrt((pos1.i-pos2.i)**2+(pos1.j-pos2.j)**2);const getRandomFloat=(min,max)=>Math.random()*(max-min)+min;const getRandomInt=(max)=>Math.floor(getRandomFloat(0,max));let GRID=([]);const INITIAL_POS=({i:0,j:0});const getCell=({i,j})=>GRID[i]?.[j];const addCell=({i,j},cell)=>{GRID[i]=GRID[i]||[];GRID[i][j]=cell;};const resetGrid=()=>(GRID=[]);let GRID=([]);const INITIAL_POS=({i:0,j:0});const getCell=({i,j})=>GRID[i]?.[j];const addCell=({i,j},cell)=>{GRID[i]=GRID[i]||[];GRID[i][j]=cell;};const resetGrid=()=>(GRID=[]);const correctRoundError=(num,estimation=4)=>Math.round(num*10**estimation)/10**estimation;const tweakColor=({r,g,b})=>{const randSaturation=Math.random()*0.1+0.95;const randBrightness=Math.random()*0.1+0.95;r=Math.round(r*randSaturation*randBrightness);g=Math.round(g*randSaturation*randBrightness);b=Math.round(b*randSaturation*randBrightness);return{r,g,b};};const getMod=(number,mod)=>(mod+(number%mod))%mod;const debounce=(fn,timeout=10)=>{let timer;return(...args)=>{clearTimeout(timer);timer=setTimeout(()=>{fn.apply(this,args);},timeout);};};const isPointOutside=(point,canvasHeight,canvasWidth)=>point.x<1||point.y<1||point.x>canvasWidth-1||point.y>canvasHeight-1;const getPosDistance=(pos1,pos2)=>Math.sqrt((pos1.i-pos2.i)**2+(pos1.j-pos2.j)**2);const getRandomFloat=(min,max)=>Math.random()*(max-min)+min;const getRandomInt=(max)=>Math.floor(getRandomFloat(0,max));const correctRoundError=(num,estimation=4)=>Math.round(num*10**estimation)/10**estimation;const tweakColor=({r,g,b})=>{const randSaturation=Math.random()*0.1+0.95;const randBrightness=Math.random()*0.1+0.95;r=Math.round(r*randSaturation*randBrightness);g=Math.round(g*randSaturation*randBrightness);b=Math.round(b*randSaturation*randBrightness);return{r,g,b};};const getMod=(number,mod)=>(mod+(number%mod))%mod;const debounce=(fn,timeout=10)=>{let timer;return(...args)=>{clearTimeout(timer);timer=setTimeout(()=>{fn.apply(this,args);},timeout);};};const isPointOutside=(point,canvasHeight,canvasWidth)=>point.x<1||point.y<1||point.x>canvasWidth-1||point.y>canvasHeight-1;const getPosDistance=(pos1,pos2)=>Math.sqrt((pos1.i-pos2.i)**2+(pos1.j-pos2.j)**2);const getRandomFloat=(min,max)=>Math.random()*(max-min)+min;const getRandomInt=(max)=>Math.floor(getRandomFloat(0,max));const correctRoundError=(num,estimation=4)=>Math.round(num*10**estimation)/10**estimation;const tweakColor=({r,g,b})=>{const randSaturation=Math.random()*0.1+0.95;const randBrightness=Math.random()*0.1+0.95;r=Math.round(r*randSaturation*randBrightness);g=Math.round(g*randSaturation*randBrightness);b=Math.round(b*randSaturation*randBrightness);return{r,g,b};};const getMod=(number,mod)=>(mod+(number%mod))%mod;const debounce=(fn,timeout=10)=>{let timer;return(...args)=>{clearTimeout(timer);timer=setTimeout(()=>{fn.apply(this,args);},timeout);};};const isPointOutside=(point,canvasHeight,canvasWidth)=>point.x<1||point.y<1||point.x>canvasWidth-1||point.y>canvasHeight-1;const getPosDistance=(pos1,pos2)=>Math.sqrt((pos1.i-pos2.i)**2+(pos1.j-pos2.j)**2);const getRandomFloat=(min,max)=>Math.random()*(max-min)+min;const getRandomInt=(max)=>Math.floor(getRandomFloat(0,max));const KNOWN_POLYGONS={TRIANGLE:3,SQUARE:4,HEXAGON:6,};const POLYGONS_IMAGES={[KNOWN_POLYGONS.TRIANGLE]:"images/polys/triangle.png",[KNOWN_POLYGONS.SQUARE]:"images/polys/square.png",[KNOWN_POLYGONS.HEXAGON]:"images/polys/hexagon.png",};const POLYGONS_ENTITY_POS={[KNOWN_POLYGONS.TRIANGLE]:{i:7,j:2},[KNOWN_POLYGONS.SQUARE]:{i:7,j:1},[KNOWN_POLYGONS.HEXAGON]:{i:7,j:0},};const KNOWN_POLYGONS_VALUES=Object.values(KNOWN_POLYGONS);const MAP_GENERATION={MIX:"MIX",DISTANCE:"DISTANCE",};const MENU_CONFIG={debugMode:false,passTime:true,rotationAnimation:true,showPos:false,showChunks:false,usePerspective:false,showSelectedCell:true,rain:false,clouds:false,digitalClock:false,music:false,mapGeneration:MAP_GENERATION.DISTANCE,};let GRID=([]);const INITIAL_POS=({i:0,j:0});const getCell=({i,j})=>GRID[i]?.[j];const addCell=({i,j},cell)=>{GRID[i]=GRID[i]||[];GRID[i][j]=cell;};const resetGrid=()=>(GRID=[]);let GRID=([]);const INITIAL_POS=({i:0,j:0});const getCell=({i,j})=>GRID[i]?.[j];const addCell=({i,j},cell)=>{GRID[i]=GRID[i]||[];GRID[i][j]=cell;};const resetGrid=()=>(GRID=[]);let GRID=([]);const INITIAL_POS=({i:0,j:0});const getCell=({i,j})=>GRID[i]?.[j];const addCell=({i,j},cell)=>{GRID[i]=GRID[i]||[];GRID[i][j]=cell;};const resetGrid=()=>(GRID=[]);const KNOWN_POLYGONS={TRIANGLE:3,SQUARE:4,HEXAGON:6,};const POLYGONS_IMAGES={[KNOWN_POLYGONS.TRIANGLE]:"images/polys/triangle.png",[KNOWN_POLYGONS.SQUARE]:"images/polys/square.png",[KNOWN_POLYGONS.HEXAGON]:"images/polys/hexagon.png",};const POLYGONS_ENTITY_POS={[KNOWN_POLYGONS.TRIANGLE]:{i:7,j:2},[KNOWN_POLYGONS.SQUARE]:{i:7,j:1},[KNOWN_POLYGONS.HEXAGON]:{i:7,j:0},};const KNOWN_POLYGONS_VALUES=Object.values(KNOWN_POLYGONS);const MAP_GENERATION={MIX:"MIX",DISTANCE:"DISTANCE",};const MENU_CONFIG={debugMode:false,passTime:true,rotationAnimation:true,showPos:false,showChunks:false,usePerspective:false,showSelectedCell:true,rain:false,clouds:false,digitalClock:false,music:false,mapGeneration:MAP_GENERATION.DISTANCE,};let GRID=([]);const INITIAL_POS=({i:0,j:0});const getCell=({i,j})=>GRID[i]?.[j];const addCell=({i,j},cell)=>{GRID[i]=GRID[i]||[];GRID[i][j]=cell;};const resetGrid=()=>(GRID=[]);const KNOWN_POLYGONS={TRIANGLE:3,SQUARE:4,HEXAGON:6,};const POLYGONS_IMAGES={[KNOWN_POLYGONS.TRIANGLE]:"images/polys/triangle.png",[KNOWN_POLYGONS.SQUARE]:"images/polys/square.png",[KNOWN_POLYGONS.HEXAGON]:"images/polys/hexagon.png",};const POLYGONS_ENTITY_POS={[KNOWN_POLYGONS.TRIANGLE]:{i:7,j:2},[KNOWN_POLYGONS.SQUARE]:{i:7,j:1},[KNOWN_POLYGONS.HEXAGON]:{i:7,j:0},};const KNOWN_POLYGONS_VALUES=Object.values(KNOWN_POLYGONS);const MAP_GENERATION={MIX:"MIX",DISTANCE:"DISTANCE",};const MENU_CONFIG={debugMode:false,passTime:true,rotationAnimation:true,showPos:false,showChunks:false,usePerspective:false,showSelectedCell:true,rain:false,clouds:false,digitalClock:false,music:false,mapGeneration:MAP_GENERATION.DISTANCE,};let GRID=([]);const INITIAL_POS=({i:0,j:0});const getCell=({i,j})=>GRID[i]?.[j];const addCell=({i,j},cell)=>{GRID[i]=GRID[i]||[];GRID[i][j]=cell;};const resetGrid=()=>(GRID=[]);const KNOWN_POLYGONS={TRIANGLE:3,SQUARE:4,HEXAGON:6,};const POLYGONS_IMAGES={[KNOWN_POLYGONS.TRIANGLE]:"images/polys/triangle.png",[KNOWN_POLYGONS.SQUARE]:"images/polys/square.png",[KNOWN_POLYGONS.HEXAGON]:"images/polys/hexagon.png",};const POLYGONS_ENTITY_POS={[KNOWN_POLYGONS.TRIANGLE]:{i:7,j:2},[KNOWN_POLYGONS.SQUARE]:{i:7,j:1},[KNOWN_POLYGONS.HEXAGON]:{i:7,j:0},};const KNOWN_POLYGONS_VALUES=Object.values(KNOWN_POLYGONS);const MAP_GENERATION={MIX:"MIX",DISTANCE:"DISTANCE",};const MENU_CONFIG={debugMode:false,passTime:true,rotationAnimation:true,showPos:false,showChunks:false,usePerspective:false,showSelectedCell:true,rain:false,clouds:false,digitalClock:false,music:false,mapGeneration:MAP_GENERATION.DISTANCE,};const RENDER_INFO=({currentPoly:KNOWN_POLYGONS.HEXAGON,cellHeight:24,iOffset:0,jOffset:0,rotationTurns:0,});const RENDER_INFO=({currentPoly:KNOWN_POLYGONS.HEXAGON,cellHeight:24,iOffset:0,jOffset:0,rotationTurns:0,});const KNOWN_POLYGONS={TRIANGLE:3,SQUARE:4,HEXAGON:6,};const POLYGONS_IMAGES={[KNOWN_POLYGONS.TRIANGLE]:"images/polys/triangle.png",[KNOWN_POLYGONS.SQUARE]:"images/polys/square.png",[KNOWN_POLYGONS.HEXAGON]:"images/polys/hexagon.png",};const POLYGONS_ENTITY_POS={[KNOWN_POLYGONS.TRIANGLE]:{i:7,j:2},[KNOWN_POLYGONS.SQUARE]:{i:7,j:1},[KNOWN_POLYGONS.HEXAGON]:{i:7,j:0},};const KNOWN_POLYGONS_VALUES=Object.values(KNOWN_POLYGONS);const MAP_GENERATION={MIX:"MIX",DISTANCE:"DISTANCE",};const MENU_CONFIG={debugMode:false,passTime:true,rotationAnimation:true,showPos:false,showChunks:false,usePerspective:false,showSelectedCell:true,rain:false,clouds:false,digitalClock:false,music:false,mapGeneration:MAP_GENERATION.DISTANCE,};const RENDER_INFO=({currentPoly:KNOWN_POLYGONS.HEXAGON,cellHeight:24,iOffset:0,jOffset:0,rotationTurns:0,});const KNOWN_POLYGONS={TRIANGLE:3,SQUARE:4,HEXAGON:6,};const POLYGONS_IMAGES={[KNOWN_POLYGONS.TRIANGLE]:"images/polys/triangle.png",[KNOWN_POLYGONS.SQUARE]:"images/polys/square.png",[KNOWN_POLYGONS.HEXAGON]:"images/polys/hexagon.png",};const POLYGONS_ENTITY_POS={[KNOWN_POLYGONS.TRIANGLE]:{i:7,j:2},[KNOWN_POLYGONS.SQUARE]:{i:7,j:1},[KNOWN_POLYGONS.HEXAGON]:{i:7,j:0},};const KNOWN_POLYGONS_VALUES=Object.values(KNOWN_POLYGONS);const MAP_GENERATION={MIX:"MIX",DISTANCE:"DISTANCE",};const MENU_CONFIG={debugMode:false,passTime:true,rotationAnimation:true,showPos:false,showChunks:false,usePerspective:false,showSelectedCell:true,rain:false,clouds:false,digitalClock:false,music:false,mapGeneration:MAP_GENERATION.DISTANCE,};const RENDER_INFO=({currentPoly:KNOWN_POLYGONS.HEXAGON,cellHeight:24,iOffset:0,jOffset:0,rotationTurns:0,});const RENDER_INFO=({currentPoly:KNOWN_POLYGONS.HEXAGON,cellHeight:24,iOffset:0,jOffset:0,rotationTurns:0,});const KNOWN_POLYGONS={TRIANGLE:3,SQUARE:4,HEXAGON:6,};const POLYGONS_IMAGES={[KNOWN_POLYGONS.TRIANGLE]:"images/polys/triangle.png",[KNOWN_POLYGONS.SQUARE]:"images/polys/square.png",[KNOWN_POLYGONS.HEXAGON]:"images/polys/hexagon.png",};const POLYGONS_ENTITY_POS={[KNOWN_POLYGONS.TRIANGLE]:{i:7,j:2},[KNOWN_POLYGONS.SQUARE]:{i:7,j:1},[KNOWN_POLYGONS.HEXAGON]:{i:7,j:0},};const KNOWN_POLYGONS_VALUES=Object.values(KNOWN_POLYGONS);const MAP_GENERATION={MIX:"MIX",DISTANCE:"DISTANCE",};const MENU_CONFIG={debugMode:false,passTime:true,rotationAnimation:true,showPos:false,showChunks:false,usePerspective:false,showSelectedCell:true,rain:false,clouds:false,digitalClock:false,music:false,mapGeneration:MAP_GENERATION.DISTANCE,};const RENDER_INFO=({currentPoly:KNOWN_POLYGONS.HEXAGON,cellHeight:24,iOffset:0,jOffset:0,rotationTurns:0,});const POLYS_INFO=({});const getPolyInfo=()=>POLYS_INFO[RENDER_INFO.currentPoly];const calculatePointBasedOnPos=({i,j},isInverted,baseCell)=>{const{calcX,calcY,ySide,shouldIntercalate}=getPolyInfo();i-=RENDER_INFO.iOffset||0;j-=RENDER_INFO.jOffset||0;let x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=baseCell?.pos.j%2?-ySide:ySide;return applyRotation({x,y},isInverted,baseCell);};const getPosByIndex=(cell,index)=>cell.adjacentPos[RENDER_INFO.currentPoly][getMod(index||0,RENDER_INFO.currentPoly)];const applyRotation=({x,y},isInverted,baseCell)=>{if(!RENDER_INFO.rotationTurns)return{x,y};const{cx,cy,ySide,xSide,hasInverted}=getPolyInfo();const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;const radians=(Math.PI/180)*angle;const cos=Math.cos(radians);const sin=Math.sin(radians);let nx=correctRoundError(cos*(x-cx)+sin*(y-cy)+cx);let ny=correctRoundError(cos*(y-cy)-sin*(x-cx)+cy);if(hasInverted&&isInverted!==baseCell?.isInverted&&angle){const oddTurn=!!(RENDER_INFO.rotationTurns%2);ny+=ySide*(baseCell?.isInverted?1:-1);nx+=(xSide/2)*(baseCell?.isInverted===oddTurn?-1:1);}return{x:nx,y:ny};};const createWallPoints=(points,height)=>{let centerAndBottomPoints=points.filter((p)=>p.y>=0);if(centerAndBottomPoints.length<=1)centerAndBottomPoints=points.sort((a,b)=>a.x-b.x);const firstPoint=centerAndBottomPoints[0];const lastPoint=centerAndBottomPoints[centerAndBottomPoints.length-1];return[{x:firstPoint.x,y:firstPoint.y-height},...centerAndBottomPoints,{x:lastPoint.x,y:lastPoint.y-height},];};const getXFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(j)=>j*(polySide/2)+xSide;case KNOWN_POLYGONS.HEXAGON:return(j)=>j*(xSide+polySide/2)+xSide;case KNOWN_POLYGONS.SQUARE:default:return(j)=>j*xSide*2+xSide;}};const configPoly=(polySides,cellHeight)=>{let radiusFromSide=0;let radiusFromCorner=0;let polySide=0;const hasInverted=polySides%2===1;const ySide=correctRoundError(cellHeight/2);if(hasInverted){polySide=correctRoundError(Math.sqrt(cellHeight**2/(1-1/4)));radiusFromSide=correctRoundError((polySide/2)*(1/Math.tan(Math.PI/polySides)));}else{radiusFromSide=ySide;polySide=correctRoundError(2*radiusFromSide*Math.tan(Math.PI/polySides));}radiusFromCorner=correctRoundError(radiusFromSide*(1/Math.cos(Math.PI/polySides)));const shouldIntercalate=polySides>KNOWN_POLYGONS.SQUARE;const yCoeficient=hasInverted?correctRoundError(-cellHeight/6):0;const coeficient=(polySides/2+1)/2;const points=[];const sideRad=(2*Math.PI)/polySides;for(let i=0;i<polySides;i++){const nI=i-coeficient;const rad=sideRad*nI;const x=correctRoundError(radiusFromCorner*Math.cos(rad));const y=correctRoundError(radiusFromCorner*Math.sin(rad)+yCoeficient,1);points.push({x,y});}const xSide=points.reduce((acc,{x})=>(x>acc?x:acc),0);const invertedPoints=points.map((p)=>({x:-p.x,y:-p.y}));const wallPoints=createWallPoints(points,ySide);const wallInvertedPoints=createWallPoints(invertedPoints,ySide);const slopSide=correctRoundError(Math.sqrt(Math.abs(polySide**2-radiusFromSide**2)));const{innerHeight,innerWidth}=window;const rows=Math.floor(innerHeight/cellHeight);let columns=innerWidth/(xSide*2);if(hasInverted)columns=((innerWidth-2)*2-polySide)/polySide;if(shouldIntercalate)columns=((innerWidth-slopSide)*2)/(radiusFromCorner*2+polySide);columns=Math.floor(columns);if(columns%2===0)columns-=1;if(shouldIntercalate&&((columns+1)/2)%2===0)columns-=2;const canvasHeight=innerHeight;let canvasWidth=columns*(xSide*2);if(hasInverted)canvasWidth=(columns*polySide)/2+polySide/2+2;if(shouldIntercalate)canvasWidth=(columns*(radiusFromCorner*2+polySide))/2+slopSide;canvasWidth=Math.round(canvasWidth);return{polySide,xSide,ySide,points,invertedPoints,wallPoints,wallInvertedPoints,rows,columns,canvasHeight,canvasWidth,polySides,calcX:getXFn(polySides,polySide,xSide),calcY:(i)=>i*ySide*2+ySide,cx:correctRoundError(canvasWidth/2),cy:correctRoundError((canvasHeight-ySide*3)/2),shouldIntercalate,hasInverted,};};const configPolys=()=>{for(const p of KNOWN_POLYGONS_VALUES){POLYS_INFO[p]=configPoly(p,RENDER_INFO.cellHeight);}};const RENDER_INFO=({currentPoly:KNOWN_POLYGONS.HEXAGON,cellHeight:24,iOffset:0,jOffset:0,rotationTurns:0,});const POLYS_INFO=({});const getPolyInfo=()=>POLYS_INFO[RENDER_INFO.currentPoly];const calculatePointBasedOnPos=({i,j},isInverted,baseCell)=>{const{calcX,calcY,ySide,shouldIntercalate}=getPolyInfo();i-=RENDER_INFO.iOffset||0;j-=RENDER_INFO.jOffset||0;let x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=baseCell?.pos.j%2?-ySide:ySide;return applyRotation({x,y},isInverted,baseCell);};const getPosByIndex=(cell,index)=>cell.adjacentPos[RENDER_INFO.currentPoly][getMod(index||0,RENDER_INFO.currentPoly)];const applyRotation=({x,y},isInverted,baseCell)=>{if(!RENDER_INFO.rotationTurns)return{x,y};const{cx,cy,ySide,xSide,hasInverted}=getPolyInfo();const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;const radians=(Math.PI/180)*angle;const cos=Math.cos(radians);const sin=Math.sin(radians);let nx=correctRoundError(cos*(x-cx)+sin*(y-cy)+cx);let ny=correctRoundError(cos*(y-cy)-sin*(x-cx)+cy);if(hasInverted&&isInverted!==baseCell?.isInverted&&angle){const oddTurn=!!(RENDER_INFO.rotationTurns%2);ny+=ySide*(baseCell?.isInverted?1:-1);nx+=(xSide/2)*(baseCell?.isInverted===oddTurn?-1:1);}return{x:nx,y:ny};};const createWallPoints=(points,height)=>{let centerAndBottomPoints=points.filter((p)=>p.y>=0);if(centerAndBottomPoints.length<=1)centerAndBottomPoints=points.sort((a,b)=>a.x-b.x);const firstPoint=centerAndBottomPoints[0];const lastPoint=centerAndBottomPoints[centerAndBottomPoints.length-1];return[{x:firstPoint.x,y:firstPoint.y-height},...centerAndBottomPoints,{x:lastPoint.x,y:lastPoint.y-height},];};const getXFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(j)=>j*(polySide/2)+xSide;case KNOWN_POLYGONS.HEXAGON:return(j)=>j*(xSide+polySide/2)+xSide;case KNOWN_POLYGONS.SQUARE:default:return(j)=>j*xSide*2+xSide;}};const configPoly=(polySides,cellHeight)=>{let radiusFromSide=0;let radiusFromCorner=0;let polySide=0;const hasInverted=polySides%2===1;const ySide=correctRoundError(cellHeight/2);if(hasInverted){polySide=correctRoundError(Math.sqrt(cellHeight**2/(1-1/4)));radiusFromSide=correctRoundError((polySide/2)*(1/Math.tan(Math.PI/polySides)));}else{radiusFromSide=ySide;polySide=correctRoundError(2*radiusFromSide*Math.tan(Math.PI/polySides));}radiusFromCorner=correctRoundError(radiusFromSide*(1/Math.cos(Math.PI/polySides)));const shouldIntercalate=polySides>KNOWN_POLYGONS.SQUARE;const yCoeficient=hasInverted?correctRoundError(-cellHeight/6):0;const coeficient=(polySides/2+1)/2;const points=[];const sideRad=(2*Math.PI)/polySides;for(let i=0;i<polySides;i++){const nI=i-coeficient;const rad=sideRad*nI;const x=correctRoundError(radiusFromCorner*Math.cos(rad));const y=correctRoundError(radiusFromCorner*Math.sin(rad)+yCoeficient,1);points.push({x,y});}const xSide=points.reduce((acc,{x})=>(x>acc?x:acc),0);const invertedPoints=points.map((p)=>({x:-p.x,y:-p.y}));const wallPoints=createWallPoints(points,ySide);const wallInvertedPoints=createWallPoints(invertedPoints,ySide);const slopSide=correctRoundError(Math.sqrt(Math.abs(polySide**2-radiusFromSide**2)));const{innerHeight,innerWidth}=window;const rows=Math.floor(innerHeight/cellHeight);let columns=innerWidth/(xSide*2);if(hasInverted)columns=((innerWidth-2)*2-polySide)/polySide;if(shouldIntercalate)columns=((innerWidth-slopSide)*2)/(radiusFromCorner*2+polySide);columns=Math.floor(columns);if(columns%2===0)columns-=1;if(shouldIntercalate&&((columns+1)/2)%2===0)columns-=2;const canvasHeight=innerHeight;let canvasWidth=columns*(xSide*2);if(hasInverted)canvasWidth=(columns*polySide)/2+polySide/2+2;if(shouldIntercalate)canvasWidth=(columns*(radiusFromCorner*2+polySide))/2+slopSide;canvasWidth=Math.round(canvasWidth);return{polySide,xSide,ySide,points,invertedPoints,wallPoints,wallInvertedPoints,rows,columns,canvasHeight,canvasWidth,polySides,calcX:getXFn(polySides,polySide,xSide),calcY:(i)=>i*ySide*2+ySide,cx:correctRoundError(canvasWidth/2),cy:correctRoundError((canvasHeight-ySide*3)/2),shouldIntercalate,hasInverted,};};const configPolys=()=>{for(const p of KNOWN_POLYGONS_VALUES){POLYS_INFO[p]=configPoly(p,RENDER_INFO.cellHeight);}};const MOVEMENT={DOWN:Symbol("DOWN"),LEFT:Symbol("LEFT"),RIGHT:Symbol("RIGHT"),UP:Symbol("UP"),};const ENTITY_TYPES={PLAYER:"PLAYER",BOAT:"BOAT",TREE:"TREE",ENEMY:"ENEMY",FIRE:"FIRE",RABBIT:"RABBIT",};const IMG_MAP_TYPES={DEFAULT:"DEFAULT",RUNNING:"RUNNING",USING:"USING",WINNING:"WINNING",LOSING:"LOSING",};const BIOME_TYPES={SNOW:"SNOW",DESERT:"DESERT",};const ENTITY_IMAGES_MAP=({[ENTITY_TYPES.PLAYER]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:4,j:0}},[MOVEMENT.LEFT]:{pos:{i:4,j:1}},[MOVEMENT.RIGHT]:{pos:{i:4,j:4}},[MOVEMENT.UP]:{pos:{i:4,j:5}},},[IMG_MAP_TYPES.RUNNING]:{[MOVEMENT.DOWN]:{posFn:(left)=>(left?{i:6,j:0}:{i:6,j:1}),},[MOVEMENT.LEFT]:{posFn:(left)=>(left?{i:6,j:2}:{i:6,j:3}),},[MOVEMENT.RIGHT]:{posFn:(left)=>(left?{i:6,j:4}:{i:6,j:5}),},[MOVEMENT.UP]:{posFn:(left)=>(left?{i:6,j:6}:{i:6,j:7}),},},[IMG_MAP_TYPES.USING]:{[MOVEMENT.DOWN]:{pos:{i:5,j:0}},[MOVEMENT.LEFT]:{pos:{i:5,j:1}},[MOVEMENT.RIGHT]:{pos:{i:5,j:2}},[MOVEMENT.UP]:{pos:{i:5,j:3}},},[IMG_MAP_TYPES.WINNING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:3}},},[IMG_MAP_TYPES.LOSING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:2}},},},[ENTITY_TYPES.TREE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:2}},},[BIOME_TYPES.DESERT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:0}},},[BIOME_TYPES.SNOW]:{[MOVEMENT.DOWN]:{pos:{i:3,j:1}},},},[ENTITY_TYPES.RABBIT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:4}},[MOVEMENT.LEFT]:{pos:{i:2,j:5}},[MOVEMENT.RIGHT]:{pos:{i:2,j:4}},[MOVEMENT.UP]:{pos:{i:2,j:5}},},},[ENTITY_TYPES.ENEMY]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:1,j:0}},[MOVEMENT.LEFT]:{pos:{i:1,j:1}},[MOVEMENT.RIGHT]:{pos:{i:1,j:2}},[MOVEMENT.UP]:{pos:{i:1,j:3}},},},[ENTITY_TYPES.BOAT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:0,j:0}},[MOVEMENT.LEFT]:{pos:{i:0,j:1}},[MOVEMENT.RIGHT]:{pos:{i:0,j:2}},[MOVEMENT.UP]:{pos:{i:0,j:3}},},},[ENTITY_TYPES.FIRE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:0}},},},});const correctRoundError=(num,estimation=4)=>Math.round(num*10**estimation)/10**estimation;const tweakColor=({r,g,b})=>{const randSaturation=Math.random()*0.1+0.95;const randBrightness=Math.random()*0.1+0.95;r=Math.round(r*randSaturation*randBrightness);g=Math.round(g*randSaturation*randBrightness);b=Math.round(b*randSaturation*randBrightness);return{r,g,b};};const getMod=(number,mod)=>(mod+(number%mod))%mod;const debounce=(fn,timeout=10)=>{let timer;return(...args)=>{clearTimeout(timer);timer=setTimeout(()=>{fn.apply(this,args);},timeout);};};const isPointOutside=(point,canvasHeight,canvasWidth)=>point.x<1||point.y<1||point.x>canvasWidth-1||point.y>canvasHeight-1;const getPosDistance=(pos1,pos2)=>Math.sqrt((pos1.i-pos2.i)**2+(pos1.j-pos2.j)**2);const getRandomFloat=(min,max)=>Math.random()*(max-min)+min;const getRandomInt=(max)=>Math.floor(getRandomFloat(0,max));let GRID=([]);const INITIAL_POS=({i:0,j:0});const getCell=({i,j})=>GRID[i]?.[j];const addCell=({i,j},cell)=>{GRID[i]=GRID[i]||[];GRID[i][j]=cell;};const resetGrid=()=>(GRID=[]);const KNOWN_POLYGONS={TRIANGLE:3,SQUARE:4,HEXAGON:6,};const POLYGONS_IMAGES={[KNOWN_POLYGONS.TRIANGLE]:"images/polys/triangle.png",[KNOWN_POLYGONS.SQUARE]:"images/polys/square.png",[KNOWN_POLYGONS.HEXAGON]:"images/polys/hexagon.png",};const POLYGONS_ENTITY_POS={[KNOWN_POLYGONS.TRIANGLE]:{i:7,j:2},[KNOWN_POLYGONS.SQUARE]:{i:7,j:1},[KNOWN_POLYGONS.HEXAGON]:{i:7,j:0},};const KNOWN_POLYGONS_VALUES=Object.values(KNOWN_POLYGONS);const MAP_GENERATION={MIX:"MIX",DISTANCE:"DISTANCE",};const MENU_CONFIG={debugMode:false,passTime:true,rotationAnimation:true,showPos:false,showChunks:false,usePerspective:false,showSelectedCell:true,rain:false,clouds:false,digitalClock:false,music:false,mapGeneration:MAP_GENERATION.DISTANCE,};const RENDER_INFO=({currentPoly:KNOWN_POLYGONS.HEXAGON,cellHeight:24,iOffset:0,jOffset:0,rotationTurns:0,});const POLYS_INFO=({});const getPolyInfo=()=>POLYS_INFO[RENDER_INFO.currentPoly];const calculatePointBasedOnPos=({i,j},isInverted,baseCell)=>{const{calcX,calcY,ySide,shouldIntercalate}=getPolyInfo();i-=RENDER_INFO.iOffset||0;j-=RENDER_INFO.jOffset||0;let x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=baseCell?.pos.j%2?-ySide:ySide;return applyRotation({x,y},isInverted,baseCell);};const getPosByIndex=(cell,index)=>cell.adjacentPos[RENDER_INFO.currentPoly][getMod(index||0,RENDER_INFO.currentPoly)];const applyRotation=({x,y},isInverted,baseCell)=>{if(!RENDER_INFO.rotationTurns)return{x,y};const{cx,cy,ySide,xSide,hasInverted}=getPolyInfo();const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;const radians=(Math.PI/180)*angle;const cos=Math.cos(radians);const sin=Math.sin(radians);let nx=correctRoundError(cos*(x-cx)+sin*(y-cy)+cx);let ny=correctRoundError(cos*(y-cy)-sin*(x-cx)+cy);if(hasInverted&&isInverted!==baseCell?.isInverted&&angle){const oddTurn=!!(RENDER_INFO.rotationTurns%2);ny+=ySide*(baseCell?.isInverted?1:-1);nx+=(xSide/2)*(baseCell?.isInverted===oddTurn?-1:1);}return{x:nx,y:ny};};const createWallPoints=(points,height)=>{let centerAndBottomPoints=points.filter((p)=>p.y>=0);if(centerAndBottomPoints.length<=1)centerAndBottomPoints=points.sort((a,b)=>a.x-b.x);const firstPoint=centerAndBottomPoints[0];const lastPoint=centerAndBottomPoints[centerAndBottomPoints.length-1];return[{x:firstPoint.x,y:firstPoint.y-height},...centerAndBottomPoints,{x:lastPoint.x,y:lastPoint.y-height},];};const getXFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(j)=>j*(polySide/2)+xSide;case KNOWN_POLYGONS.HEXAGON:return(j)=>j*(xSide+polySide/2)+xSide;case KNOWN_POLYGONS.SQUARE:default:return(j)=>j*xSide*2+xSide;}};const configPoly=(polySides,cellHeight)=>{let radiusFromSide=0;let radiusFromCorner=0;let polySide=0;const hasInverted=polySides%2===1;const ySide=correctRoundError(cellHeight/2);if(hasInverted){polySide=correctRoundError(Math.sqrt(cellHeight**2/(1-1/4)));radiusFromSide=correctRoundError((polySide/2)*(1/Math.tan(Math.PI/polySides)));}else{radiusFromSide=ySide;polySide=correctRoundError(2*radiusFromSide*Math.tan(Math.PI/polySides));}radiusFromCorner=correctRoundError(radiusFromSide*(1/Math.cos(Math.PI/polySides)));const shouldIntercalate=polySides>KNOWN_POLYGONS.SQUARE;const yCoeficient=hasInverted?correctRoundError(-cellHeight/6):0;const coeficient=(polySides/2+1)/2;const points=[];const sideRad=(2*Math.PI)/polySides;for(let i=0;i<polySides;i++){const nI=i-coeficient;const rad=sideRad*nI;const x=correctRoundError(radiusFromCorner*Math.cos(rad));const y=correctRoundError(radiusFromCorner*Math.sin(rad)+yCoeficient,1);points.push({x,y});}const xSide=points.reduce((acc,{x})=>(x>acc?x:acc),0);const invertedPoints=points.map((p)=>({x:-p.x,y:-p.y}));const wallPoints=createWallPoints(points,ySide);const wallInvertedPoints=createWallPoints(invertedPoints,ySide);const slopSide=correctRoundError(Math.sqrt(Math.abs(polySide**2-radiusFromSide**2)));const{innerHeight,innerWidth}=window;const rows=Math.floor(innerHeight/cellHeight);let columns=innerWidth/(xSide*2);if(hasInverted)columns=((innerWidth-2)*2-polySide)/polySide;if(shouldIntercalate)columns=((innerWidth-slopSide)*2)/(radiusFromCorner*2+polySide);columns=Math.floor(columns);if(columns%2===0)columns-=1;if(shouldIntercalate&&((columns+1)/2)%2===0)columns-=2;const canvasHeight=innerHeight;let canvasWidth=columns*(xSide*2);if(hasInverted)canvasWidth=(columns*polySide)/2+polySide/2+2;if(shouldIntercalate)canvasWidth=(columns*(radiusFromCorner*2+polySide))/2+slopSide;canvasWidth=Math.round(canvasWidth);return{polySide,xSide,ySide,points,invertedPoints,wallPoints,wallInvertedPoints,rows,columns,canvasHeight,canvasWidth,polySides,calcX:getXFn(polySides,polySide,xSide),calcY:(i)=>i*ySide*2+ySide,cx:correctRoundError(canvasWidth/2),cy:correctRoundError((canvasHeight-ySide*3)/2),shouldIntercalate,hasInverted,};};const configPolys=()=>{for(const p of KNOWN_POLYGONS_VALUES){POLYS_INFO[p]=configPoly(p,RENDER_INFO.cellHeight);}};const MOVEMENT={DOWN:Symbol("DOWN"),LEFT:Symbol("LEFT"),RIGHT:Symbol("RIGHT"),UP:Symbol("UP"),};const ENTITY_TYPES={PLAYER:"PLAYER",BOAT:"BOAT",TREE:"TREE",ENEMY:"ENEMY",FIRE:"FIRE",RABBIT:"RABBIT",};const IMG_MAP_TYPES={DEFAULT:"DEFAULT",RUNNING:"RUNNING",USING:"USING",WINNING:"WINNING",LOSING:"LOSING",};const BIOME_TYPES={SNOW:"SNOW",DESERT:"DESERT",};const ENTITY_IMAGES_MAP=({[ENTITY_TYPES.PLAYER]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:4,j:0}},[MOVEMENT.LEFT]:{pos:{i:4,j:1}},[MOVEMENT.RIGHT]:{pos:{i:4,j:4}},[MOVEMENT.UP]:{pos:{i:4,j:5}},},[IMG_MAP_TYPES.RUNNING]:{[MOVEMENT.DOWN]:{posFn:(left)=>(left?{i:6,j:0}:{i:6,j:1}),},[MOVEMENT.LEFT]:{posFn:(left)=>(left?{i:6,j:2}:{i:6,j:3}),},[MOVEMENT.RIGHT]:{posFn:(left)=>(left?{i:6,j:4}:{i:6,j:5}),},[MOVEMENT.UP]:{posFn:(left)=>(left?{i:6,j:6}:{i:6,j:7}),},},[IMG_MAP_TYPES.USING]:{[MOVEMENT.DOWN]:{pos:{i:5,j:0}},[MOVEMENT.LEFT]:{pos:{i:5,j:1}},[MOVEMENT.RIGHT]:{pos:{i:5,j:2}},[MOVEMENT.UP]:{pos:{i:5,j:3}},},[IMG_MAP_TYPES.WINNING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:3}},},[IMG_MAP_TYPES.LOSING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:2}},},},[ENTITY_TYPES.TREE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:2}},},[BIOME_TYPES.DESERT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:0}},},[BIOME_TYPES.SNOW]:{[MOVEMENT.DOWN]:{pos:{i:3,j:1}},},},[ENTITY_TYPES.RABBIT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:4}},[MOVEMENT.LEFT]:{pos:{i:2,j:5}},[MOVEMENT.RIGHT]:{pos:{i:2,j:4}},[MOVEMENT.UP]:{pos:{i:2,j:5}},},},[ENTITY_TYPES.ENEMY]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:1,j:0}},[MOVEMENT.LEFT]:{pos:{i:1,j:1}},[MOVEMENT.RIGHT]:{pos:{i:1,j:2}},[MOVEMENT.UP]:{pos:{i:1,j:3}},},},[ENTITY_TYPES.BOAT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:0,j:0}},[MOVEMENT.LEFT]:{pos:{i:0,j:1}},[MOVEMENT.RIGHT]:{pos:{i:0,j:2}},[MOVEMENT.UP]:{pos:{i:0,j:3}},},},[ENTITY_TYPES.FIRE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:0}},},},});const correctRoundError=(num,estimation=4)=>Math.round(num*10**estimation)/10**estimation;const tweakColor=({r,g,b})=>{const randSaturation=Math.random()*0.1+0.95;const randBrightness=Math.random()*0.1+0.95;r=Math.round(r*randSaturation*randBrightness);g=Math.round(g*randSaturation*randBrightness);b=Math.round(b*randSaturation*randBrightness);return{r,g,b};};const getMod=(number,mod)=>(mod+(number%mod))%mod;const debounce=(fn,timeout=10)=>{let timer;return(...args)=>{clearTimeout(timer);timer=setTimeout(()=>{fn.apply(this,args);},timeout);};};const isPointOutside=(point,canvasHeight,canvasWidth)=>point.x<1||point.y<1||point.x>canvasWidth-1||point.y>canvasHeight-1;const getPosDistance=(pos1,pos2)=>Math.sqrt((pos1.i-pos2.i)**2+(pos1.j-pos2.j)**2);const getRandomFloat=(min,max)=>Math.random()*(max-min)+min;const getRandomInt=(max)=>Math.floor(getRandomFloat(0,max));const ENTITY_INFO=({timeOfDay:0,});const POLYS_INFO=({});const getPolyInfo=()=>POLYS_INFO[RENDER_INFO.currentPoly];const calculatePointBasedOnPos=({i,j},isInverted,baseCell)=>{const{calcX,calcY,ySide,shouldIntercalate}=getPolyInfo();i-=RENDER_INFO.iOffset||0;j-=RENDER_INFO.jOffset||0;let x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=baseCell?.pos.j%2?-ySide:ySide;return applyRotation({x,y},isInverted,baseCell);};const getPosByIndex=(cell,index)=>cell.adjacentPos[RENDER_INFO.currentPoly][getMod(index||0,RENDER_INFO.currentPoly)];const applyRotation=({x,y},isInverted,baseCell)=>{if(!RENDER_INFO.rotationTurns)return{x,y};const{cx,cy,ySide,xSide,hasInverted}=getPolyInfo();const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;const radians=(Math.PI/180)*angle;const cos=Math.cos(radians);const sin=Math.sin(radians);let nx=correctRoundError(cos*(x-cx)+sin*(y-cy)+cx);let ny=correctRoundError(cos*(y-cy)-sin*(x-cx)+cy);if(hasInverted&&isInverted!==baseCell?.isInverted&&angle){const oddTurn=!!(RENDER_INFO.rotationTurns%2);ny+=ySide*(baseCell?.isInverted?1:-1);nx+=(xSide/2)*(baseCell?.isInverted===oddTurn?-1:1);}return{x:nx,y:ny};};const createWallPoints=(points,height)=>{let centerAndBottomPoints=points.filter((p)=>p.y>=0);if(centerAndBottomPoints.length<=1)centerAndBottomPoints=points.sort((a,b)=>a.x-b.x);const firstPoint=centerAndBottomPoints[0];const lastPoint=centerAndBottomPoints[centerAndBottomPoints.length-1];return[{x:firstPoint.x,y:firstPoint.y-height},...centerAndBottomPoints,{x:lastPoint.x,y:lastPoint.y-height},];};const getXFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(j)=>j*(polySide/2)+xSide;case KNOWN_POLYGONS.HEXAGON:return(j)=>j*(xSide+polySide/2)+xSide;case KNOWN_POLYGONS.SQUARE:default:return(j)=>j*xSide*2+xSide;}};const configPoly=(polySides,cellHeight)=>{let radiusFromSide=0;let radiusFromCorner=0;let polySide=0;const hasInverted=polySides%2===1;const ySide=correctRoundError(cellHeight/2);if(hasInverted){polySide=correctRoundError(Math.sqrt(cellHeight**2/(1-1/4)));radiusFromSide=correctRoundError((polySide/2)*(1/Math.tan(Math.PI/polySides)));}else{radiusFromSide=ySide;polySide=correctRoundError(2*radiusFromSide*Math.tan(Math.PI/polySides));}radiusFromCorner=correctRoundError(radiusFromSide*(1/Math.cos(Math.PI/polySides)));const shouldIntercalate=polySides>KNOWN_POLYGONS.SQUARE;const yCoeficient=hasInverted?correctRoundError(-cellHeight/6):0;const coeficient=(polySides/2+1)/2;const points=[];const sideRad=(2*Math.PI)/polySides;for(let i=0;i<polySides;i++){const nI=i-coeficient;const rad=sideRad*nI;const x=correctRoundError(radiusFromCorner*Math.cos(rad));const y=correctRoundError(radiusFromCorner*Math.sin(rad)+yCoeficient,1);points.push({x,y});}const xSide=points.reduce((acc,{x})=>(x>acc?x:acc),0);const invertedPoints=points.map((p)=>({x:-p.x,y:-p.y}));const wallPoints=createWallPoints(points,ySide);const wallInvertedPoints=createWallPoints(invertedPoints,ySide);const slopSide=correctRoundError(Math.sqrt(Math.abs(polySide**2-radiusFromSide**2)));const{innerHeight,innerWidth}=window;const rows=Math.floor(innerHeight/cellHeight);let columns=innerWidth/(xSide*2);if(hasInverted)columns=((innerWidth-2)*2-polySide)/polySide;if(shouldIntercalate)columns=((innerWidth-slopSide)*2)/(radiusFromCorner*2+polySide);columns=Math.floor(columns);if(columns%2===0)columns-=1;if(shouldIntercalate&&((columns+1)/2)%2===0)columns-=2;const canvasHeight=innerHeight;let canvasWidth=columns*(xSide*2);if(hasInverted)canvasWidth=(columns*polySide)/2+polySide/2+2;if(shouldIntercalate)canvasWidth=(columns*(radiusFromCorner*2+polySide))/2+slopSide;canvasWidth=Math.round(canvasWidth);return{polySide,xSide,ySide,points,invertedPoints,wallPoints,wallInvertedPoints,rows,columns,canvasHeight,canvasWidth,polySides,calcX:getXFn(polySides,polySide,xSide),calcY:(i)=>i*ySide*2+ySide,cx:correctRoundError(canvasWidth/2),cy:correctRoundError((canvasHeight-ySide*3)/2),shouldIntercalate,hasInverted,};};const configPolys=()=>{for(const p of KNOWN_POLYGONS_VALUES){POLYS_INFO[p]=configPoly(p,RENDER_INFO.cellHeight);}};const MOVEMENT={DOWN:Symbol("DOWN"),LEFT:Symbol("LEFT"),RIGHT:Symbol("RIGHT"),UP:Symbol("UP"),};const ENTITY_TYPES={PLAYER:"PLAYER",BOAT:"BOAT",TREE:"TREE",ENEMY:"ENEMY",FIRE:"FIRE",RABBIT:"RABBIT",};const IMG_MAP_TYPES={DEFAULT:"DEFAULT",RUNNING:"RUNNING",USING:"USING",WINNING:"WINNING",LOSING:"LOSING",};const BIOME_TYPES={SNOW:"SNOW",DESERT:"DESERT",};const ENTITY_IMAGES_MAP=({[ENTITY_TYPES.PLAYER]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:4,j:0}},[MOVEMENT.LEFT]:{pos:{i:4,j:1}},[MOVEMENT.RIGHT]:{pos:{i:4,j:4}},[MOVEMENT.UP]:{pos:{i:4,j:5}},},[IMG_MAP_TYPES.RUNNING]:{[MOVEMENT.DOWN]:{posFn:(left)=>(left?{i:6,j:0}:{i:6,j:1}),},[MOVEMENT.LEFT]:{posFn:(left)=>(left?{i:6,j:2}:{i:6,j:3}),},[MOVEMENT.RIGHT]:{posFn:(left)=>(left?{i:6,j:4}:{i:6,j:5}),},[MOVEMENT.UP]:{posFn:(left)=>(left?{i:6,j:6}:{i:6,j:7}),},},[IMG_MAP_TYPES.USING]:{[MOVEMENT.DOWN]:{pos:{i:5,j:0}},[MOVEMENT.LEFT]:{pos:{i:5,j:1}},[MOVEMENT.RIGHT]:{pos:{i:5,j:2}},[MOVEMENT.UP]:{pos:{i:5,j:3}},},[IMG_MAP_TYPES.WINNING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:3}},},[IMG_MAP_TYPES.LOSING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:2}},},},[ENTITY_TYPES.TREE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:2}},},[BIOME_TYPES.DESERT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:0}},},[BIOME_TYPES.SNOW]:{[MOVEMENT.DOWN]:{pos:{i:3,j:1}},},},[ENTITY_TYPES.RABBIT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:4}},[MOVEMENT.LEFT]:{pos:{i:2,j:5}},[MOVEMENT.RIGHT]:{pos:{i:2,j:4}},[MOVEMENT.UP]:{pos:{i:2,j:5}},},},[ENTITY_TYPES.ENEMY]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:1,j:0}},[MOVEMENT.LEFT]:{pos:{i:1,j:1}},[MOVEMENT.RIGHT]:{pos:{i:1,j:2}},[MOVEMENT.UP]:{pos:{i:1,j:3}},},},[ENTITY_TYPES.BOAT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:0,j:0}},[MOVEMENT.LEFT]:{pos:{i:0,j:1}},[MOVEMENT.RIGHT]:{pos:{i:0,j:2}},[MOVEMENT.UP]:{pos:{i:0,j:3}},},},[ENTITY_TYPES.FIRE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:0}},},},});const ENTITY_INFO=({timeOfDay:0,});const POLYS_INFO=({});const getPolyInfo=()=>POLYS_INFO[RENDER_INFO.currentPoly];const calculatePointBasedOnPos=({i,j},isInverted,baseCell)=>{const{calcX,calcY,ySide,shouldIntercalate}=getPolyInfo();i-=RENDER_INFO.iOffset||0;j-=RENDER_INFO.jOffset||0;let x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=baseCell?.pos.j%2?-ySide:ySide;return applyRotation({x,y},isInverted,baseCell);};const getPosByIndex=(cell,index)=>cell.adjacentPos[RENDER_INFO.currentPoly][getMod(index||0,RENDER_INFO.currentPoly)];const applyRotation=({x,y},isInverted,baseCell)=>{if(!RENDER_INFO.rotationTurns)return{x,y};const{cx,cy,ySide,xSide,hasInverted}=getPolyInfo();const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;const radians=(Math.PI/180)*angle;const cos=Math.cos(radians);const sin=Math.sin(radians);let nx=correctRoundError(cos*(x-cx)+sin*(y-cy)+cx);let ny=correctRoundError(cos*(y-cy)-sin*(x-cx)+cy);if(hasInverted&&isInverted!==baseCell?.isInverted&&angle){const oddTurn=!!(RENDER_INFO.rotationTurns%2);ny+=ySide*(baseCell?.isInverted?1:-1);nx+=(xSide/2)*(baseCell?.isInverted===oddTurn?-1:1);}return{x:nx,y:ny};};const createWallPoints=(points,height)=>{let centerAndBottomPoints=points.filter((p)=>p.y>=0);if(centerAndBottomPoints.length<=1)centerAndBottomPoints=points.sort((a,b)=>a.x-b.x);const firstPoint=centerAndBottomPoints[0];const lastPoint=centerAndBottomPoints[centerAndBottomPoints.length-1];return[{x:firstPoint.x,y:firstPoint.y-height},...centerAndBottomPoints,{x:lastPoint.x,y:lastPoint.y-height},];};const getXFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(j)=>j*(polySide/2)+xSide;case KNOWN_POLYGONS.HEXAGON:return(j)=>j*(xSide+polySide/2)+xSide;case KNOWN_POLYGONS.SQUARE:default:return(j)=>j*xSide*2+xSide;}};const configPoly=(polySides,cellHeight)=>{let radiusFromSide=0;let radiusFromCorner=0;let polySide=0;const hasInverted=polySides%2===1;const ySide=correctRoundError(cellHeight/2);if(hasInverted){polySide=correctRoundError(Math.sqrt(cellHeight**2/(1-1/4)));radiusFromSide=correctRoundError((polySide/2)*(1/Math.tan(Math.PI/polySides)));}else{radiusFromSide=ySide;polySide=correctRoundError(2*radiusFromSide*Math.tan(Math.PI/polySides));}radiusFromCorner=correctRoundError(radiusFromSide*(1/Math.cos(Math.PI/polySides)));const shouldIntercalate=polySides>KNOWN_POLYGONS.SQUARE;const yCoeficient=hasInverted?correctRoundError(-cellHeight/6):0;const coeficient=(polySides/2+1)/2;const points=[];const sideRad=(2*Math.PI)/polySides;for(let i=0;i<polySides;i++){const nI=i-coeficient;const rad=sideRad*nI;const x=correctRoundError(radiusFromCorner*Math.cos(rad));const y=correctRoundError(radiusFromCorner*Math.sin(rad)+yCoeficient,1);points.push({x,y});}const xSide=points.reduce((acc,{x})=>(x>acc?x:acc),0);const invertedPoints=points.map((p)=>({x:-p.x,y:-p.y}));const wallPoints=createWallPoints(points,ySide);const wallInvertedPoints=createWallPoints(invertedPoints,ySide);const slopSide=correctRoundError(Math.sqrt(Math.abs(polySide**2-radiusFromSide**2)));const{innerHeight,innerWidth}=window;const rows=Math.floor(innerHeight/cellHeight);let columns=innerWidth/(xSide*2);if(hasInverted)columns=((innerWidth-2)*2-polySide)/polySide;if(shouldIntercalate)columns=((innerWidth-slopSide)*2)/(radiusFromCorner*2+polySide);columns=Math.floor(columns);if(columns%2===0)columns-=1;if(shouldIntercalate&&((columns+1)/2)%2===0)columns-=2;const canvasHeight=innerHeight;let canvasWidth=columns*(xSide*2);if(hasInverted)canvasWidth=(columns*polySide)/2+polySide/2+2;if(shouldIntercalate)canvasWidth=(columns*(radiusFromCorner*2+polySide))/2+slopSide;canvasWidth=Math.round(canvasWidth);return{polySide,xSide,ySide,points,invertedPoints,wallPoints,wallInvertedPoints,rows,columns,canvasHeight,canvasWidth,polySides,calcX:getXFn(polySides,polySide,xSide),calcY:(i)=>i*ySide*2+ySide,cx:correctRoundError(canvasWidth/2),cy:correctRoundError((canvasHeight-ySide*3)/2),shouldIntercalate,hasInverted,};};const configPolys=()=>{for(const p of KNOWN_POLYGONS_VALUES){POLYS_INFO[p]=configPoly(p,RENDER_INFO.cellHeight);}};const ENTITY_ACTIONS_CONFIG={delayToBurn:1000,};const getClosestTarget=(entity)=>{let minDistance=Infinity;let selectedTarget=(null);ENTITIES.forEach((targetEntity)=>{entity.movementOptions.targets.forEach((t)=>{if(targetEntity.cell&&targetEntity.type===t){const distance=getPosDistance(entity.cell.pos,targetEntity.cell.pos);if(distance<minDistance){selectedTarget=targetEntity;minDistance=distance;}}});});return selectedTarget;};const getClosestCell=(entity,cell,targetCell)=>{let minDistance=Infinity;let selectedCell=(null);let selectedIndex=0;const aPos=cell.adjacentPos[RENDER_INFO.currentPoly];for(let index=0;index<aPos.length;index++){const pos=aPos[index];const aCell=getCell(pos);if(cellIsBlocked(aCell,entity)&&aCell.entityType!==targetCell.entityType)continue;const distance=getPosDistance(aCell.pos,targetCell.pos);if(distance<minDistance){selectedCell=aCell;selectedIndex=index;minDistance=distance;}}return{cell:selectedCell,index:selectedIndex};};const moveEntities=(baseCell)=>{const{indexToMove}=getMovementMaps(baseCell);ENTITIES.forEach((e)=>{if(!e.cell||e.deleted)return;moveEntity(e,indexToMove);updateEntityOpacity(e);});};const moveEntity=(e,indexToMove)=>{if(!e.movementOptions?.speed)return;const{targets,speed,random,damage}=e.movementOptions;let nextCell=e.cell;let nextIndex=0;let target=(null);for(let index=0;index<speed;index++){if(targets){target=getClosestTarget(e);if(!target)return;const nextCellInfo=getClosestCell(e,nextCell,target.cell);nextCell=nextCellInfo.cell;nextIndex=nextCellInfo.index;if(!nextCell)return;}else if(random){nextIndex=getRandomInt(RENDER_INFO.currentPoly);const aPos=nextCell.adjacentPos[RENDER_INFO.currentPoly];nextCell=getCell(aPos[nextIndex]);for(let i=0;i<aPos.length;i++){if(!cellIsBlocked(nextCell,e))break;nextIndex=getMod(nextIndex+1,RENDER_INFO.currentPoly);nextCell=getCell(aPos[nextIndex]);}}}if(target&&nextCell.entityType===target.type&&damage){removeEntity(e);hurtEntity(target,damage);}if(cellIsBlocked(nextCell,e))return;nextIndex=getMod(nextIndex,RENDER_INFO.currentPoly);updateEntityImage(e,indexToMove[nextIndex]);moveEntityToCell(e,nextCell);};const getMovementMaps=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>{currentPoly=currentPoly??RENDER_INFO.currentPoly;hasInverted=hasInverted??getPolyInfo().hasInverted;let topI=rotationTurns??RENDER_INFO.rotationTurns;let bottomI=topI+Math.floor(currentPoly/2);let topLeftI=topI+currentPoly-1;let topRightI=topI+1;let bottomLeftI=bottomI+1;let bottomRightI=bottomI-1;if(hasInverted){topLeftI=bottomLeftI=topI+(baseCell.isInverted?1:2);topRightI=bottomRightI=topI+(baseCell.isInverted?2:1);bottomI=baseCell.isInverted?topI:undefined;topI=baseCell.isInverted?undefined:topI;}return{moveToIndex:{[MOVEMENT.UP]:topI,[MOVEMENT.DOWN]:bottomI,[MOVEMENT.LEFT]:useDiagonal?bottomLeftI:topLeftI,[MOVEMENT.RIGHT]:useDiagonal?bottomRightI:topRightI,},indexToMove:{[topI]:MOVEMENT.UP,[bottomI]:MOVEMENT.DOWN,[bottomLeftI]:MOVEMENT.LEFT,[topLeftI]:MOVEMENT.LEFT,[bottomRightI]:MOVEMENT.RIGHT,[topRightI]:MOVEMENT.RIGHT,},};};const getMovementMap=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>getMovementMaps(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted).moveToIndex;const killEntitiesByTimeOfDay=()=>{if(MENU_CONFIG.rain)return;const entitiesToKill=([]);ENTITIES.forEach((e)=>{if(!e.cell||!e.minTime||e.deleted||e.minTime<=ENTITY_INFO.timeOfDay)return;const fireEntity=createEntity(e.cell,e.id,ENTITY_TYPES.FIRE,{zIndex:e.zIndex+1,});e.connectedEntities[ENTITY_TYPES.FIRE]=fireEntity;e.deleted=true;entitiesToKill.push(e);});setTimeout(()=>{entitiesToKill.forEach(removeEntity);},ENTITY_ACTIONS_CONFIG.delayToBurn);};const MOVEMENT={DOWN:Symbol("DOWN"),LEFT:Symbol("LEFT"),RIGHT:Symbol("RIGHT"),UP:Symbol("UP"),};const ENTITY_TYPES={PLAYER:"PLAYER",BOAT:"BOAT",TREE:"TREE",ENEMY:"ENEMY",FIRE:"FIRE",RABBIT:"RABBIT",};const IMG_MAP_TYPES={DEFAULT:"DEFAULT",RUNNING:"RUNNING",USING:"USING",WINNING:"WINNING",LOSING:"LOSING",};const BIOME_TYPES={SNOW:"SNOW",DESERT:"DESERT",};const ENTITY_IMAGES_MAP=({[ENTITY_TYPES.PLAYER]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:4,j:0}},[MOVEMENT.LEFT]:{pos:{i:4,j:1}},[MOVEMENT.RIGHT]:{pos:{i:4,j:4}},[MOVEMENT.UP]:{pos:{i:4,j:5}},},[IMG_MAP_TYPES.RUNNING]:{[MOVEMENT.DOWN]:{posFn:(left)=>(left?{i:6,j:0}:{i:6,j:1}),},[MOVEMENT.LEFT]:{posFn:(left)=>(left?{i:6,j:2}:{i:6,j:3}),},[MOVEMENT.RIGHT]:{posFn:(left)=>(left?{i:6,j:4}:{i:6,j:5}),},[MOVEMENT.UP]:{posFn:(left)=>(left?{i:6,j:6}:{i:6,j:7}),},},[IMG_MAP_TYPES.USING]:{[MOVEMENT.DOWN]:{pos:{i:5,j:0}},[MOVEMENT.LEFT]:{pos:{i:5,j:1}},[MOVEMENT.RIGHT]:{pos:{i:5,j:2}},[MOVEMENT.UP]:{pos:{i:5,j:3}},},[IMG_MAP_TYPES.WINNING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:3}},},[IMG_MAP_TYPES.LOSING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:2}},},},[ENTITY_TYPES.TREE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:2}},},[BIOME_TYPES.DESERT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:0}},},[BIOME_TYPES.SNOW]:{[MOVEMENT.DOWN]:{pos:{i:3,j:1}},},},[ENTITY_TYPES.RABBIT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:4}},[MOVEMENT.LEFT]:{pos:{i:2,j:5}},[MOVEMENT.RIGHT]:{pos:{i:2,j:4}},[MOVEMENT.UP]:{pos:{i:2,j:5}},},},[ENTITY_TYPES.ENEMY]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:1,j:0}},[MOVEMENT.LEFT]:{pos:{i:1,j:1}},[MOVEMENT.RIGHT]:{pos:{i:1,j:2}},[MOVEMENT.UP]:{pos:{i:1,j:3}},},},[ENTITY_TYPES.BOAT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:0,j:0}},[MOVEMENT.LEFT]:{pos:{i:0,j:1}},[MOVEMENT.RIGHT]:{pos:{i:0,j:2}},[MOVEMENT.UP]:{pos:{i:0,j:3}},},},[ENTITY_TYPES.FIRE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:0}},},},});const ENTITY_INFO=({timeOfDay:0,});const BOAT_ENTITIES=({});const getInBoat=(entity)=>{if(!BOAT_ENTITIES[entity.id])addBoat(entity.cell,entity);BOAT_ENTITIES[entity.id].isConnected=true;entity.connectedEntities[ENTITY_TYPES.BOAT]=BOAT_ENTITIES[entity.id];};const getOutBoat=(entity)=>{if(entity.connectedEntities[ENTITY_TYPES.BOAT]){delete entity.connectedEntities[ENTITY_TYPES.BOAT];BOAT_ENTITIES[entity.id].isConnected=false;moveEntityToCell(BOAT_ENTITIES[entity.id],entity.cell);}};const addBoat=(cell,entity)=>{let boatEntity=BOAT_ENTITIES[entity.id];if(!boatEntity)boatEntity=BOAT_ENTITIES[entity.id]=createEntity(cell,entity.id,ENTITY_TYPES.BOAT,{zIndex:1,movementsToCut:[MOVEMENT.UP,MOVEMENT.DOWN],currentDirection:MOVEMENT.RIGHT,});moveEntityToCell(boatEntity,cell);};const addEnemy=(cell)=>{const enemyEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.ENEMY,{minTime:40,movementOptions:{speed:1,targets:new Set([ENTITY_TYPES.PLAYER]),damage:1,},});if(enemyEntity&&cell.block.isFluid)getInBoat(enemyEntity);};const spawnEntity=(entityType,cell)=>{switch(entityType){case ENTITY_TYPES.TREE:return addTree(cell);case ENTITY_TYPES.RABBIT:return addRabbit(cell);case ENTITY_TYPES.ENEMY:return addEnemy(cell);}};const PLAYER_CONFIG={maxHealth:10,};const PLAYER_ENTITY=({id:"PLAYER_1",type:ENTITY_TYPES.PLAYER,cell:null,img:document.getElementById("player"),connectedEntities:{},selectedCellIndex:0,health:PLAYER_CONFIG.maxHealth,});const addRabbit=(cell)=>{const rabbitEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.RABBIT,{isGenerated:true,movementOptions:{speed:1,random:true},});if(cell.block.isFluid)getInBoat(rabbitEntity);};const addTree=(cell)=>{const treeEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.TREE,{isGenerated:true});if(cell.block.isFluid)getInBoat(treeEntity);};const ENTITY_ACTIONS_CONFIG={delayToBurn:1000,};const getClosestTarget=(entity)=>{let minDistance=Infinity;let selectedTarget=(null);ENTITIES.forEach((targetEntity)=>{entity.movementOptions.targets.forEach((t)=>{if(targetEntity.cell&&targetEntity.type===t){const distance=getPosDistance(entity.cell.pos,targetEntity.cell.pos);if(distance<minDistance){selectedTarget=targetEntity;minDistance=distance;}}});});return selectedTarget;};const getClosestCell=(entity,cell,targetCell)=>{let minDistance=Infinity;let selectedCell=(null);let selectedIndex=0;const aPos=cell.adjacentPos[RENDER_INFO.currentPoly];for(let index=0;index<aPos.length;index++){const pos=aPos[index];const aCell=getCell(pos);if(cellIsBlocked(aCell,entity)&&aCell.entityType!==targetCell.entityType)continue;const distance=getPosDistance(aCell.pos,targetCell.pos);if(distance<minDistance){selectedCell=aCell;selectedIndex=index;minDistance=distance;}}return{cell:selectedCell,index:selectedIndex};};const moveEntities=(baseCell)=>{const{indexToMove}=getMovementMaps(baseCell);ENTITIES.forEach((e)=>{if(!e.cell||e.deleted)return;moveEntity(e,indexToMove);updateEntityOpacity(e);});};const moveEntity=(e,indexToMove)=>{if(!e.movementOptions?.speed)return;const{targets,speed,random,damage}=e.movementOptions;let nextCell=e.cell;let nextIndex=0;let target=(null);for(let index=0;index<speed;index++){if(targets){target=getClosestTarget(e);if(!target)return;const nextCellInfo=getClosestCell(e,nextCell,target.cell);nextCell=nextCellInfo.cell;nextIndex=nextCellInfo.index;if(!nextCell)return;}else if(random){nextIndex=getRandomInt(RENDER_INFO.currentPoly);const aPos=nextCell.adjacentPos[RENDER_INFO.currentPoly];nextCell=getCell(aPos[nextIndex]);for(let i=0;i<aPos.length;i++){if(!cellIsBlocked(nextCell,e))break;nextIndex=getMod(nextIndex+1,RENDER_INFO.currentPoly);nextCell=getCell(aPos[nextIndex]);}}}if(target&&nextCell.entityType===target.type&&damage){removeEntity(e);hurtEntity(target,damage);}if(cellIsBlocked(nextCell,e))return;nextIndex=getMod(nextIndex,RENDER_INFO.currentPoly);updateEntityImage(e,indexToMove[nextIndex]);moveEntityToCell(e,nextCell);};const getMovementMaps=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>{currentPoly=currentPoly??RENDER_INFO.currentPoly;hasInverted=hasInverted??getPolyInfo().hasInverted;let topI=rotationTurns??RENDER_INFO.rotationTurns;let bottomI=topI+Math.floor(currentPoly/2);let topLeftI=topI+currentPoly-1;let topRightI=topI+1;let bottomLeftI=bottomI+1;let bottomRightI=bottomI-1;if(hasInverted){topLeftI=bottomLeftI=topI+(baseCell.isInverted?1:2);topRightI=bottomRightI=topI+(baseCell.isInverted?2:1);bottomI=baseCell.isInverted?topI:undefined;topI=baseCell.isInverted?undefined:topI;}return{moveToIndex:{[MOVEMENT.UP]:topI,[MOVEMENT.DOWN]:bottomI,[MOVEMENT.LEFT]:useDiagonal?bottomLeftI:topLeftI,[MOVEMENT.RIGHT]:useDiagonal?bottomRightI:topRightI,},indexToMove:{[topI]:MOVEMENT.UP,[bottomI]:MOVEMENT.DOWN,[bottomLeftI]:MOVEMENT.LEFT,[topLeftI]:MOVEMENT.LEFT,[bottomRightI]:MOVEMENT.RIGHT,[topRightI]:MOVEMENT.RIGHT,},};};const getMovementMap=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>getMovementMaps(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted).moveToIndex;const killEntitiesByTimeOfDay=()=>{if(MENU_CONFIG.rain)return;const entitiesToKill=([]);ENTITIES.forEach((e)=>{if(!e.cell||!e.minTime||e.deleted||e.minTime<=ENTITY_INFO.timeOfDay)return;const fireEntity=createEntity(e.cell,e.id,ENTITY_TYPES.FIRE,{zIndex:e.zIndex+1,});e.connectedEntities[ENTITY_TYPES.FIRE]=fireEntity;e.deleted=true;entitiesToKill.push(e);});setTimeout(()=>{entitiesToKill.forEach(removeEntity);},ENTITY_ACTIONS_CONFIG.delayToBurn);};const BOAT_ENTITIES=({});const getInBoat=(entity)=>{if(!BOAT_ENTITIES[entity.id])addBoat(entity.cell,entity);BOAT_ENTITIES[entity.id].isConnected=true;entity.connectedEntities[ENTITY_TYPES.BOAT]=BOAT_ENTITIES[entity.id];};const getOutBoat=(entity)=>{if(entity.connectedEntities[ENTITY_TYPES.BOAT]){delete entity.connectedEntities[ENTITY_TYPES.BOAT];BOAT_ENTITIES[entity.id].isConnected=false;moveEntityToCell(BOAT_ENTITIES[entity.id],entity.cell);}};const addBoat=(cell,entity)=>{let boatEntity=BOAT_ENTITIES[entity.id];if(!boatEntity)boatEntity=BOAT_ENTITIES[entity.id]=createEntity(cell,entity.id,ENTITY_TYPES.BOAT,{zIndex:1,movementsToCut:[MOVEMENT.UP,MOVEMENT.DOWN],currentDirection:MOVEMENT.RIGHT,});moveEntityToCell(boatEntity,cell);};const addEnemy=(cell)=>{const enemyEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.ENEMY,{minTime:40,movementOptions:{speed:1,targets:new Set([ENTITY_TYPES.PLAYER]),damage:1,},});if(enemyEntity&&cell.block.isFluid)getInBoat(enemyEntity);};const spawnEntity=(entityType,cell)=>{switch(entityType){case ENTITY_TYPES.TREE:return addTree(cell);case ENTITY_TYPES.RABBIT:return addRabbit(cell);case ENTITY_TYPES.ENEMY:return addEnemy(cell);}};const PLAYER_CONFIG={maxHealth:10,};const PLAYER_ENTITY=({id:"PLAYER_1",type:ENTITY_TYPES.PLAYER,cell:null,img:document.getElementById("player"),connectedEntities:{},selectedCellIndex:0,health:PLAYER_CONFIG.maxHealth,});const ENTITIES=(new Set());const addEntity=(entity)=>ENTITIES.add(entity);const moveEntityToCell=(entity,cell)=>{if(!cell)return;const previousType=entity.cell?.entityType||cell.entityType;if(entity.cell)entity.cell.entityType=null;entity.cell=cell;entity.cell.entityType=previousType||entity.type;updateEntityPoint(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach((e)=>moveEntityToCell(e,cell));};const removeEntity=(entity)=>{entity.cell.entityType=null;removeEntityImage(entity);ENTITIES.delete(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach(removeEntity);};const getEntitiesFromCell=(cell)=>{const entities=([]);ENTITIES.forEach((entity)=>{if(entity.cell===cell)entities.push(entity);});return entities;};const createEntity=(cell,id,type,entityParams={})=>{if(entityParams.minTime&&ENTITY_INFO.timeOfDay<entityParams.minTime)return;const entity=({id:`${type}_${id}`,type,connectedEntities:{},currentImgType:cell.block?.biomeType,health:1,...entityParams,});createEntityImage(entity);moveEntityToCell(entity,cell);addEntity(entity);return entity;};const setEntitiesSize=()=>ENTITIES.forEach((e)=>setEntitySize(e));const removeGeneratedEntities=()=>ENTITIES.forEach((e)=>e.isGenerated&&removeEntity(e));const updateEntities=()=>ENTITIES.forEach((e)=>updateEntityPoint(e));const cellIsBlocked=(cell,entity)=>!MENU_CONFIG.debugMode&&(!cell||!cell.block||!!cell.wall||!!cell.entityType||(entity.connectedEntities[ENTITY_TYPES.BOAT]?!cell.block.isFluid:cell.block.isFluid));const getSelectedCell=(entity)=>getCell(getPosByIndex(entity.cell,entity.selectedCellIndex));const updateEntityDirection=(entity,direction)=>{updateEntityImage(entity,direction);Object.values(entity.connectedEntities).forEach((e)=>{updateEntityImage(e,MOVEMENT.RIGHT);});};const makeEntityUse=(entity)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.USING);setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},250);};const updateEntityHealth=(entity)=>{if(entity===PLAYER_ENTITY){if(entity.health>PLAYER_CONFIG.maxHealth)entity.health=PLAYER_CONFIG.maxHealth;updatePlayerHearts();}else if(entity.health<=0)removeEntity(entity);};const giveItemToEntity=(entity,item)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.WINNING);const callback=displayWinAnimation(entity,item.imgPos);if(item.health){entity.health+=item.health;updateEntityHealth(entity);}setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);callback();},1000);};const hurtEntity=(entity,damage)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.LOSING);entity.health-=damage;updateEntityHealth(entity);if(entity.health>0)setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},1000);};const makeEntityRun=(entity,direction)=>{const connectedEntities=Object.values(entity.connectedEntities);if(!connectedEntities.length){updateEntityImage(entity,direction,IMG_MAP_TYPES.RUNNING);return;}updateEntityImage(entity,direction);connectedEntities.forEach((e)=>{updateEntityImage(e,direction);cutEntityImage(e,direction);});};const addRabbit=(cell)=>{const rabbitEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.RABBIT,{isGenerated:true,movementOptions:{speed:1,random:true},});if(cell.block.isFluid)getInBoat(rabbitEntity);};const addTree=(cell)=>{const treeEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.TREE,{isGenerated:true});if(cell.block.isFluid)getInBoat(treeEntity);};const CUT_MOVEMENTS_MAP={[MOVEMENT.DOWN]:"marginTop",[MOVEMENT.LEFT]:"marginLeft",[MOVEMENT.RIGHT]:"marginRight",[MOVEMENT.UP]:"marginTop",};const container=document.getElementById("entities");const createImageElement=()=>{const img=document.createElement("div");img.className="image";return img;};const createEntityImage=(entity)=>{const img=createImageElement();img.id=entity.id;img.style.zIndex=`${entity.zIndex ||2}`;container.appendChild(img);entity.img=img;setEntitySize(entity);};const displayWinAnimation=(entity,itemPos)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);const img=createImageElement();img.classList.add("won-item");img.style.marginTop=`-${ySide}px`;setImagePos(img,itemPos);container.appendChild(img);setEntityImageSize(img,ySide/2);setImagePoint(img,point,false,ySide/2);return()=>{container.removeChild(img);};};const removeEntityImage=(entity)=>{if(entity.img)container.removeChild(entity.img);entity.img=null;};const updateEntityPoint=(entity,parentPoint)=>{if(!parentPoint&&entity.isConnected)return;const{hasInverted,canvasHeight,canvasWidth}=getPolyInfo();const point=parentPoint||calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);if(isPointOutside(point,canvasHeight,canvasWidth)){if(entity.img)removeEntityImage(entity);}else if(!entity.img){createEntityImage(entity);}if(entity.img)setImagePoint(entity.img,point);verifyEntityHeight(entity);Object.values(entity.connectedEntities).forEach((e)=>updateEntityPoint(e,point));};const updateEntityOpacity=(entity)=>{if(!entity?.img||entity?.deleted)return;entity.img.style.setProperty("--entity-opacity",`${entity.cell.modifier ||1}`);};const getEntitySize=(ySide)=>Math.round((ySide||getPolyInfo().ySide)*2.5);const setImagePos=(img,pos)=>{img.style.setProperty("--entity-position-i",`${pos.i}`);img.style.setProperty("--entity-position-j",`${pos.j}`);};const setEntityImageSize=(img,ySide)=>{if(!img)return;const size=getEntitySize(ySide);img.style.setProperty("--entity-size",`${size}px`);};const setEntitySize=(entity,ySide)=>{if(!entity?.img)return;setEntityImageSize(entity.img,ySide);setEntityImageInfo(entity);};const setEntityImageInfo=(entity)=>{const imgInfo=getEntityImageInfo(entity);if(!imgInfo.src){entity.img.style.removeProperty("--entity-img");entity.img.classList.remove("dont-use-spritesheet");}if(imgInfo.pos){setImagePos(entity.img,imgInfo.pos);}else if(imgInfo.posFn){const pos=imgInfo.posFn(!!entity.leftFootWalk);entity.leftFootWalk=!entity.leftFootWalk;setImagePos(entity.img,pos);}else if(imgInfo.src){entity.img.style.setProperty("--entity-img",`url(${imgInfo.src})`);entity.img.classList.add("dont-use-spritesheet");setImagePos(entity.img,{i:0,j:0});}};const setImagePoint=(img,point,shouldCenter,ySide)=>{if(!point)return;const entitySize=getEntitySize(ySide);img.style.setProperty("--entity-top",`${point.y -entitySize /(shouldCenter ?2 :1.25)}px`);img.style.setProperty("--entity-left",`${point.x -entitySize /2}px`);};const verifyEntityHeight=(entity)=>{if(!entity?.cell||!entity?.img)return;const{hasInverted}=getPolyInfo();const downI=hasInverted&&entity.cell.isInverted?RENDER_INFO.rotationTurns:RENDER_INFO.rotationTurns+Math.floor(RENDER_INFO.currentPoly/2);const downPos=getPosByIndex(entity.cell,downI);const downCell=getCell(downPos);if(!downCell)return;entity.img.classList.remove("not-inverted-both-walls");entity.img.classList.remove("not-inverted-right-wall");entity.img.classList.remove("not-inverted-left-wall");entity.img.classList.remove("behind-wall");if(hasInverted&&!entity.cell.isInverted){const rightCell=downCell;const leftI=RENDER_INFO.rotationTurns+RENDER_INFO.currentPoly-1;const leftPos=getPosByIndex(entity.cell,leftI);const leftCell=getCell(leftPos);if(rightCell.wall&&leftCell.wall){entity.img.classList.add("not-inverted-both-walls");}else if(rightCell.wall){entity.img.classList.add("not-inverted-right-wall");}else if(leftCell.wall){entity.img.classList.add("not-inverted-left-wall");}}else if(downCell.wall){entity.img.classList.add("behind-wall");}if(Object.values(entity.connectedEntities).length)entity.img.classList.add("behind-wall");};const getEntityImageInfo=(entity)=>{const typeMap=ENTITY_IMAGES_MAP[entity.type];const mapType=typeMap[entity.currentImgType]||typeMap[IMG_MAP_TYPES.DEFAULT];return(mapType[entity.currentDirection||MOVEMENT.DOWN]||mapType[MOVEMENT.DOWN]);};const updateEntityImage=(entity,direction,imgMapType)=>{if(!entity?.img)return;entity.currentImgType=imgMapType;entity.currentDirection=direction;setEntityImageInfo(entity);entity.img.style.marginTop=null;entity.img.style.marginLeft=null;entity.img.style.marginRight=null;};const cutEntityImage=(entity,direction)=>{if(entity.movementsToCut?.length){if(entity.movementsToCut.includes(direction)){const{ySide}=getPolyInfo();entity.img.style[CUT_MOVEMENTS_MAP[direction]]=`${ySide}px`;}}};const playerHealthContainer=document.getElementById("health-container");const updatePlayerHearts=()=>{playerHealthContainer.innerHTML="";let curretnHealth=PLAYER_ENTITY.health;for(let i=0;i<PLAYER_CONFIG.maxHealth;i++){const heartImg=createImageElement();if(curretnHealth){setImagePos(heartImg,{i:2,j:3});heartImg.classList.add("filled");curretnHealth--;}else{setImagePos(heartImg,{i:2,j:2});}playerHealthContainer.appendChild(heartImg);}};updatePlayerHearts();const GENERATION_CONFIG={chunkSize:50,};const getRange=(n,range)=>Math.floor(n/range)*range;const getChunkStart=(pos,height,width)=>({i:getRange(pos.i,height),j:getRange(pos.j,width),});const hexToRgb=(hexColor)=>{let hex=hexColor.trim().slice(1);let r=parseInt(hex.substring(0,2),16);let g=parseInt(hex.substring(2,4),16);let b=parseInt(hex.substring(4,6),16);return{r,g,b};};const TRACK_TYPES={TRACK1:"TRACK1",TRACK2:"TRACK2",TRACK3:"TRACK3",TRACK4:"TRACK4",TRACK5:"TRACK5",TRACK6:"TRACK6",TRACK7:"TRACK7",TRACK8:"TRACK8",TRACK9:"TRACK9",TRACK11:"TRACK11",TRACK10:"TRACK10",TRACK12:"TRACK12",TRACK13:"TRACK13",TRACK14:"TRACK14",TRACK15:"TRACK15",TRACK16:"TRACK16",};const ENEMY_SPAWN={probability:0.00001,entityType:ENTITY_TYPES.ENEMY,spawnOnMove:true,increaseWithTime:true,};const WATER_SPAWNS=[{probability:0.0005,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const FOREST_SPAWNS=[{probability:0.01,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const SNOW_PROPS={biomeType:BIOME_TYPES.SNOW,spawnableEntities:[{probability:0.01,entityType:ENTITY_TYPES.TREE},ENEMY_SPAWN,],};const DESERT_PROPS={biomeType:BIOME_TYPES.DESERT,spawnableEntities:[{probability:0.001,entityType:ENTITY_TYPES.TREE},{...ENEMY_SPAWN,probability:0.00005,},],};const EMPTY_BLOCK=({layer:0,color:{r:-1,g:-1,b:-1},});const BLOCKS=({DEEP_WATER:{name:"DEEP_WATER",color:hexToRgb("#256299"),layer:0,isFluid:true,spawnableEntities:WATER_SPAWNS,trackType:TRACK_TYPES.TRACK5,},WATER:{name:"WATER",color:hexToRgb("#2375b4"),layer:0,isFluid:true,trackType:TRACK_TYPES.TRACK4,},LOW_GRASS:{name:"LOW_GRASS",color:hexToRgb("#457950"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK2,},MID_GRASS:{name:"MID_GRASS",color:hexToRgb("#2d673e"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK1,},HIGH_GRASS:{name:"HIGH_GRASS",color:hexToRgb("#2d673e"),layer:1,trackType:TRACK_TYPES.TRACK1,},DIRT:{name:"DIRT",color:hexToRgb("#3F573A"),layer:1,trackType:TRACK_TYPES.TRACK6,},ROCK:{name:"ROCK",color:hexToRgb("#CBC0BB"),layer:1,},BEACH_SAND:{name:"BEACH_SAND",color:hexToRgb("#ab976a"),layer:0,spawnableEntities:[ENEMY_SPAWN],trackType:TRACK_TYPES.TRACK3,},FROZEN_WATER:{name:"FROZEN_WATER",color:hexToRgb("#94F2F4"),layer:0,trackType:TRACK_TYPES.TRACK11,...SNOW_PROPS,},FROZEN_SEA_SHORE:{name:"FROZEN_SEA_SHORE",color:hexToRgb("#A0E6EC"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},SLUSH:{name:"SLUSH",color:hexToRgb("#D0ECEB"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},ICE:{name:"ICE",color:hexToRgb("#ECFFFD"),layer:0,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},HIGH_ICE:{name:"HIGH_ICE",color:hexToRgb("#ECFFFD"),layer:1,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},DUST:{name:"DUST",color:hexToRgb("#DAA98B"),layer:0,trackType:TRACK_TYPES.TRACK16,...DESERT_PROPS,},SAND:{name:"SAND",color:hexToRgb("#EC912E"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},DARK_SAND:{name:"DARK_SAND",color:hexToRgb("#CC7025"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},TERRACOTA:{name:"TERRACOTA",color:hexToRgb("#9F561A"),layer:0,trackType:TRACK_TYPES.TRACK15,...DESERT_PROPS,},HIGH_TERRACOTA:{name:"HIGH_TERRACOTA",color:hexToRgb("#9F561A"),layer:1,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},});const addPropsToBlock=(block,props)=>({...block,...props});const BIOMES_RAW=({FOREST:{name:"FOREST",mapColor:BLOCKS.MID_GRASS.color,minValue:-1,minDistance:0,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.WATER,{max:-0.4}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:-0.2}),addPropsToBlock(BLOCKS.MID_GRASS,{max:0.4}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.5}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},OCEAN:{name:"OCEAN",mapColor:BLOCKS.WATER.color,minValue:-0.2,minDistance:75,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.DEEP_WATER,{max:-0.1}),addPropsToBlock(BLOCKS.WATER,{max:0.3}),addPropsToBlock(BLOCKS.BEACH_SAND,{max:0.5}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:0.7}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.8}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},SNOW:{name:"SNOW",mapColor:BLOCKS.ICE.color,minValue:0.2,minDistance:150,higherGroundBlock:BLOCKS.ICE,negativeJ:false,ranges:[addPropsToBlock(BLOCKS.FROZEN_WATER,{max:-0.2}),addPropsToBlock(BLOCKS.FROZEN_SEA_SHORE,{max:0}),addPropsToBlock(BLOCKS.SLUSH,{max:0.1}),addPropsToBlock(BLOCKS.HIGH_ICE,{max:1}),],},DESERT:{name:"DESERT",mapColor:BLOCKS.SAND.color,minValue:0,minDistance:150,higherGroundBlock:BLOCKS.TERRACOTA,negativeJ:true,ranges:[addPropsToBlock(BLOCKS.DUST,{max:-0.4}),addPropsToBlock(BLOCKS.SAND,{max:-0.2}),addPropsToBlock(BLOCKS.DARK_SAND,{max:0}),addPropsToBlock(BLOCKS.TERRACOTA,{max:0.2}),addPropsToBlock(BLOCKS.HIGH_TERRACOTA,{max:1}),],},});const BIOMES=Object.values(BIOMES_RAW).sort((a,b)=>b.minDistance-a.minDistance);const POLYS_INFO=({});const getPolyInfo=()=>POLYS_INFO[RENDER_INFO.currentPoly];const calculatePointBasedOnPos=({i,j},isInverted,baseCell)=>{const{calcX,calcY,ySide,shouldIntercalate}=getPolyInfo();i-=RENDER_INFO.iOffset||0;j-=RENDER_INFO.jOffset||0;let x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=baseCell?.pos.j%2?-ySide:ySide;return applyRotation({x,y},isInverted,baseCell);};const getPosByIndex=(cell,index)=>cell.adjacentPos[RENDER_INFO.currentPoly][getMod(index||0,RENDER_INFO.currentPoly)];const applyRotation=({x,y},isInverted,baseCell)=>{if(!RENDER_INFO.rotationTurns)return{x,y};const{cx,cy,ySide,xSide,hasInverted}=getPolyInfo();const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;const radians=(Math.PI/180)*angle;const cos=Math.cos(radians);const sin=Math.sin(radians);let nx=correctRoundError(cos*(x-cx)+sin*(y-cy)+cx);let ny=correctRoundError(cos*(y-cy)-sin*(x-cx)+cy);if(hasInverted&&isInverted!==baseCell?.isInverted&&angle){const oddTurn=!!(RENDER_INFO.rotationTurns%2);ny+=ySide*(baseCell?.isInverted?1:-1);nx+=(xSide/2)*(baseCell?.isInverted===oddTurn?-1:1);}return{x:nx,y:ny};};const createWallPoints=(points,height)=>{let centerAndBottomPoints=points.filter((p)=>p.y>=0);if(centerAndBottomPoints.length<=1)centerAndBottomPoints=points.sort((a,b)=>a.x-b.x);const firstPoint=centerAndBottomPoints[0];const lastPoint=centerAndBottomPoints[centerAndBottomPoints.length-1];return[{x:firstPoint.x,y:firstPoint.y-height},...centerAndBottomPoints,{x:lastPoint.x,y:lastPoint.y-height},];};const getXFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(j)=>j*(polySide/2)+xSide;case KNOWN_POLYGONS.HEXAGON:return(j)=>j*(xSide+polySide/2)+xSide;case KNOWN_POLYGONS.SQUARE:default:return(j)=>j*xSide*2+xSide;}};const configPoly=(polySides,cellHeight)=>{let radiusFromSide=0;let radiusFromCorner=0;let polySide=0;const hasInverted=polySides%2===1;const ySide=correctRoundError(cellHeight/2);if(hasInverted){polySide=correctRoundError(Math.sqrt(cellHeight**2/(1-1/4)));radiusFromSide=correctRoundError((polySide/2)*(1/Math.tan(Math.PI/polySides)));}else{radiusFromSide=ySide;polySide=correctRoundError(2*radiusFromSide*Math.tan(Math.PI/polySides));}radiusFromCorner=correctRoundError(radiusFromSide*(1/Math.cos(Math.PI/polySides)));const shouldIntercalate=polySides>KNOWN_POLYGONS.SQUARE;const yCoeficient=hasInverted?correctRoundError(-cellHeight/6):0;const coeficient=(polySides/2+1)/2;const points=[];const sideRad=(2*Math.PI)/polySides;for(let i=0;i<polySides;i++){const nI=i-coeficient;const rad=sideRad*nI;const x=correctRoundError(radiusFromCorner*Math.cos(rad));const y=correctRoundError(radiusFromCorner*Math.sin(rad)+yCoeficient,1);points.push({x,y});}const xSide=points.reduce((acc,{x})=>(x>acc?x:acc),0);const invertedPoints=points.map((p)=>({x:-p.x,y:-p.y}));const wallPoints=createWallPoints(points,ySide);const wallInvertedPoints=createWallPoints(invertedPoints,ySide);const slopSide=correctRoundError(Math.sqrt(Math.abs(polySide**2-radiusFromSide**2)));const{innerHeight,innerWidth}=window;const rows=Math.floor(innerHeight/cellHeight);let columns=innerWidth/(xSide*2);if(hasInverted)columns=((innerWidth-2)*2-polySide)/polySide;if(shouldIntercalate)columns=((innerWidth-slopSide)*2)/(radiusFromCorner*2+polySide);columns=Math.floor(columns);if(columns%2===0)columns-=1;if(shouldIntercalate&&((columns+1)/2)%2===0)columns-=2;const canvasHeight=innerHeight;let canvasWidth=columns*(xSide*2);if(hasInverted)canvasWidth=(columns*polySide)/2+polySide/2+2;if(shouldIntercalate)canvasWidth=(columns*(radiusFromCorner*2+polySide))/2+slopSide;canvasWidth=Math.round(canvasWidth);return{polySide,xSide,ySide,points,invertedPoints,wallPoints,wallInvertedPoints,rows,columns,canvasHeight,canvasWidth,polySides,calcX:getXFn(polySides,polySide,xSide),calcY:(i)=>i*ySide*2+ySide,cx:correctRoundError(canvasWidth/2),cy:correctRoundError((canvasHeight-ySide*3)/2),shouldIntercalate,hasInverted,};};const configPolys=()=>{for(const p of KNOWN_POLYGONS_VALUES){POLYS_INFO[p]=configPoly(p,RENDER_INFO.cellHeight);}};let BIOME_MAPS=([]);const resetBiomes=()=>(BIOME_MAPS=[]);const getPosBiomeOffset=({i,j})=>({i:i/GENERATION_CONFIG.chunkSize,j:j/GENERATION_CONFIG.chunkSize,});const addBiomeToMap=(pos,biome)=>{const{i,j}=getPosBiomeOffset(pos);if(!BIOME_MAPS[i])BIOME_MAPS[i]=[];if(BIOME_MAPS[i][j])return;BIOME_MAPS[i][j]=biome;};const getBiomeFromMap=(pos)=>{pos=getChunkStart(pos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const{i,j}=getPosBiomeOffset(pos);return BIOME_MAPS[i]?.[j];};const getBiomeMap=()=>BIOME_MAPS;const createMinesObj=()=>{const minefield=([]);const MINES_CONFIG={bombsNum:Math.round(GENERATION_CONFIG.chunkSize**2/4),};const createField=()=>{for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){minefield[i]=[];for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){minefield[i][j]=false;}}};const getIndexForBomb=()=>{const limit=GENERATION_CONFIG.chunkSize-2;return Math.floor(Math.random()*limit)+1;};const addBomb=()=>{const row=getIndexForBomb();const column=getIndexForBomb();if(minefield[row][column])return false;minefield[row][column]=true;return true;};const addBombs=()=>{for(let i=0;i<MINES_CONFIG.bombsNum;i++){if(!addBomb())i--;}};createField();addBombs();return{isBomb:(pos)=>minefield[pos.i][pos.j],};};const MINE_BLOCKS=({MINES_LOW:{name:"MINES_LOW",color:hexToRgb("#d3d3d3"),layer:0,indestructible:true,isFluid:false,},MINES_HIGH:{name:"MINES_HIGH",color:hexToRgb("#d3d3d3"),layer:1,isFluid:false,onDestroy:(cell)=>{const aCells=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);const isNextToBomb=!!aCells.find((c)=>c.hasBomb);if(isNextToBomb)return;cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell).filter((c)=>c.wall?.block?.name==="MINES_HIGH"&&!c.hasBomb).forEach((c)=>{const onDestroy=c.wall.block.onDestroy;c.wall=null;onDestroy(c);});},},});const MINE_BIOMES=({MINES:{name:"MINES",mapColor:MINE_BLOCKS.MINES_LOW.color,minValue:-1,minDistance:0,higherGroundBlock:MINE_BLOCKS.MINES_LOW,ranges:[addPropsToBlock(MINE_BLOCKS.MINES_HIGH,{max:1})],},});const POLYS_INFO=({});const getPolyInfo=()=>POLYS_INFO[RENDER_INFO.currentPoly];const calculatePointBasedOnPos=({i,j},isInverted,baseCell)=>{const{calcX,calcY,ySide,shouldIntercalate}=getPolyInfo();i-=RENDER_INFO.iOffset||0;j-=RENDER_INFO.jOffset||0;let x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=baseCell?.pos.j%2?-ySide:ySide;return applyRotation({x,y},isInverted,baseCell);};const getPosByIndex=(cell,index)=>cell.adjacentPos[RENDER_INFO.currentPoly][getMod(index||0,RENDER_INFO.currentPoly)];const applyRotation=({x,y},isInverted,baseCell)=>{if(!RENDER_INFO.rotationTurns)return{x,y};const{cx,cy,ySide,xSide,hasInverted}=getPolyInfo();const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;const radians=(Math.PI/180)*angle;const cos=Math.cos(radians);const sin=Math.sin(radians);let nx=correctRoundError(cos*(x-cx)+sin*(y-cy)+cx);let ny=correctRoundError(cos*(y-cy)-sin*(x-cx)+cy);if(hasInverted&&isInverted!==baseCell?.isInverted&&angle){const oddTurn=!!(RENDER_INFO.rotationTurns%2);ny+=ySide*(baseCell?.isInverted?1:-1);nx+=(xSide/2)*(baseCell?.isInverted===oddTurn?-1:1);}return{x:nx,y:ny};};const createWallPoints=(points,height)=>{let centerAndBottomPoints=points.filter((p)=>p.y>=0);if(centerAndBottomPoints.length<=1)centerAndBottomPoints=points.sort((a,b)=>a.x-b.x);const firstPoint=centerAndBottomPoints[0];const lastPoint=centerAndBottomPoints[centerAndBottomPoints.length-1];return[{x:firstPoint.x,y:firstPoint.y-height},...centerAndBottomPoints,{x:lastPoint.x,y:lastPoint.y-height},];};const getXFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(j)=>j*(polySide/2)+xSide;case KNOWN_POLYGONS.HEXAGON:return(j)=>j*(xSide+polySide/2)+xSide;case KNOWN_POLYGONS.SQUARE:default:return(j)=>j*xSide*2+xSide;}};const configPoly=(polySides,cellHeight)=>{let radiusFromSide=0;let radiusFromCorner=0;let polySide=0;const hasInverted=polySides%2===1;const ySide=correctRoundError(cellHeight/2);if(hasInverted){polySide=correctRoundError(Math.sqrt(cellHeight**2/(1-1/4)));radiusFromSide=correctRoundError((polySide/2)*(1/Math.tan(Math.PI/polySides)));}else{radiusFromSide=ySide;polySide=correctRoundError(2*radiusFromSide*Math.tan(Math.PI/polySides));}radiusFromCorner=correctRoundError(radiusFromSide*(1/Math.cos(Math.PI/polySides)));const shouldIntercalate=polySides>KNOWN_POLYGONS.SQUARE;const yCoeficient=hasInverted?correctRoundError(-cellHeight/6):0;const coeficient=(polySides/2+1)/2;const points=[];const sideRad=(2*Math.PI)/polySides;for(let i=0;i<polySides;i++){const nI=i-coeficient;const rad=sideRad*nI;const x=correctRoundError(radiusFromCorner*Math.cos(rad));const y=correctRoundError(radiusFromCorner*Math.sin(rad)+yCoeficient,1);points.push({x,y});}const xSide=points.reduce((acc,{x})=>(x>acc?x:acc),0);const invertedPoints=points.map((p)=>({x:-p.x,y:-p.y}));const wallPoints=createWallPoints(points,ySide);const wallInvertedPoints=createWallPoints(invertedPoints,ySide);const slopSide=correctRoundError(Math.sqrt(Math.abs(polySide**2-radiusFromSide**2)));const{innerHeight,innerWidth}=window;const rows=Math.floor(innerHeight/cellHeight);let columns=innerWidth/(xSide*2);if(hasInverted)columns=((innerWidth-2)*2-polySide)/polySide;if(shouldIntercalate)columns=((innerWidth-slopSide)*2)/(radiusFromCorner*2+polySide);columns=Math.floor(columns);if(columns%2===0)columns-=1;if(shouldIntercalate&&((columns+1)/2)%2===0)columns-=2;const canvasHeight=innerHeight;let canvasWidth=columns*(xSide*2);if(hasInverted)canvasWidth=(columns*polySide)/2+polySide/2+2;if(shouldIntercalate)canvasWidth=(columns*(radiusFromCorner*2+polySide))/2+slopSide;canvasWidth=Math.round(canvasWidth);return{polySide,xSide,ySide,points,invertedPoints,wallPoints,wallInvertedPoints,rows,columns,canvasHeight,canvasWidth,polySides,calcX:getXFn(polySides,polySide,xSide),calcY:(i)=>i*ySide*2+ySide,cx:correctRoundError(canvasWidth/2),cy:correctRoundError((canvasHeight-ySide*3)/2),shouldIntercalate,hasInverted,};};const configPolys=()=>{for(const p of KNOWN_POLYGONS_VALUES){POLYS_INFO[p]=configPoly(p,RENDER_INFO.cellHeight);}};const MOVEMENT={DOWN:Symbol("DOWN"),LEFT:Symbol("LEFT"),RIGHT:Symbol("RIGHT"),UP:Symbol("UP"),};const ENTITY_TYPES={PLAYER:"PLAYER",BOAT:"BOAT",TREE:"TREE",ENEMY:"ENEMY",FIRE:"FIRE",RABBIT:"RABBIT",};const IMG_MAP_TYPES={DEFAULT:"DEFAULT",RUNNING:"RUNNING",USING:"USING",WINNING:"WINNING",LOSING:"LOSING",};const BIOME_TYPES={SNOW:"SNOW",DESERT:"DESERT",};const ENTITY_IMAGES_MAP=({[ENTITY_TYPES.PLAYER]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:4,j:0}},[MOVEMENT.LEFT]:{pos:{i:4,j:1}},[MOVEMENT.RIGHT]:{pos:{i:4,j:4}},[MOVEMENT.UP]:{pos:{i:4,j:5}},},[IMG_MAP_TYPES.RUNNING]:{[MOVEMENT.DOWN]:{posFn:(left)=>(left?{i:6,j:0}:{i:6,j:1}),},[MOVEMENT.LEFT]:{posFn:(left)=>(left?{i:6,j:2}:{i:6,j:3}),},[MOVEMENT.RIGHT]:{posFn:(left)=>(left?{i:6,j:4}:{i:6,j:5}),},[MOVEMENT.UP]:{posFn:(left)=>(left?{i:6,j:6}:{i:6,j:7}),},},[IMG_MAP_TYPES.USING]:{[MOVEMENT.DOWN]:{pos:{i:5,j:0}},[MOVEMENT.LEFT]:{pos:{i:5,j:1}},[MOVEMENT.RIGHT]:{pos:{i:5,j:2}},[MOVEMENT.UP]:{pos:{i:5,j:3}},},[IMG_MAP_TYPES.WINNING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:3}},},[IMG_MAP_TYPES.LOSING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:2}},},},[ENTITY_TYPES.TREE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:2}},},[BIOME_TYPES.DESERT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:0}},},[BIOME_TYPES.SNOW]:{[MOVEMENT.DOWN]:{pos:{i:3,j:1}},},},[ENTITY_TYPES.RABBIT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:4}},[MOVEMENT.LEFT]:{pos:{i:2,j:5}},[MOVEMENT.RIGHT]:{pos:{i:2,j:4}},[MOVEMENT.UP]:{pos:{i:2,j:5}},},},[ENTITY_TYPES.ENEMY]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:1,j:0}},[MOVEMENT.LEFT]:{pos:{i:1,j:1}},[MOVEMENT.RIGHT]:{pos:{i:1,j:2}},[MOVEMENT.UP]:{pos:{i:1,j:3}},},},[ENTITY_TYPES.BOAT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:0,j:0}},[MOVEMENT.LEFT]:{pos:{i:0,j:1}},[MOVEMENT.RIGHT]:{pos:{i:0,j:2}},[MOVEMENT.UP]:{pos:{i:0,j:3}},},},[ENTITY_TYPES.FIRE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:0}},},},});const ENTITY_INFO=({timeOfDay:0,});const MOVEMENT={DOWN:Symbol("DOWN"),LEFT:Symbol("LEFT"),RIGHT:Symbol("RIGHT"),UP:Symbol("UP"),};const ENTITY_TYPES={PLAYER:"PLAYER",BOAT:"BOAT",TREE:"TREE",ENEMY:"ENEMY",FIRE:"FIRE",RABBIT:"RABBIT",};const IMG_MAP_TYPES={DEFAULT:"DEFAULT",RUNNING:"RUNNING",USING:"USING",WINNING:"WINNING",LOSING:"LOSING",};const BIOME_TYPES={SNOW:"SNOW",DESERT:"DESERT",};const ENTITY_IMAGES_MAP=({[ENTITY_TYPES.PLAYER]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:4,j:0}},[MOVEMENT.LEFT]:{pos:{i:4,j:1}},[MOVEMENT.RIGHT]:{pos:{i:4,j:4}},[MOVEMENT.UP]:{pos:{i:4,j:5}},},[IMG_MAP_TYPES.RUNNING]:{[MOVEMENT.DOWN]:{posFn:(left)=>(left?{i:6,j:0}:{i:6,j:1}),},[MOVEMENT.LEFT]:{posFn:(left)=>(left?{i:6,j:2}:{i:6,j:3}),},[MOVEMENT.RIGHT]:{posFn:(left)=>(left?{i:6,j:4}:{i:6,j:5}),},[MOVEMENT.UP]:{posFn:(left)=>(left?{i:6,j:6}:{i:6,j:7}),},},[IMG_MAP_TYPES.USING]:{[MOVEMENT.DOWN]:{pos:{i:5,j:0}},[MOVEMENT.LEFT]:{pos:{i:5,j:1}},[MOVEMENT.RIGHT]:{pos:{i:5,j:2}},[MOVEMENT.UP]:{pos:{i:5,j:3}},},[IMG_MAP_TYPES.WINNING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:3}},},[IMG_MAP_TYPES.LOSING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:2}},},},[ENTITY_TYPES.TREE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:2}},},[BIOME_TYPES.DESERT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:0}},},[BIOME_TYPES.SNOW]:{[MOVEMENT.DOWN]:{pos:{i:3,j:1}},},},[ENTITY_TYPES.RABBIT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:4}},[MOVEMENT.LEFT]:{pos:{i:2,j:5}},[MOVEMENT.RIGHT]:{pos:{i:2,j:4}},[MOVEMENT.UP]:{pos:{i:2,j:5}},},},[ENTITY_TYPES.ENEMY]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:1,j:0}},[MOVEMENT.LEFT]:{pos:{i:1,j:1}},[MOVEMENT.RIGHT]:{pos:{i:1,j:2}},[MOVEMENT.UP]:{pos:{i:1,j:3}},},},[ENTITY_TYPES.BOAT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:0,j:0}},[MOVEMENT.LEFT]:{pos:{i:0,j:1}},[MOVEMENT.RIGHT]:{pos:{i:0,j:2}},[MOVEMENT.UP]:{pos:{i:0,j:3}},},},[ENTITY_TYPES.FIRE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:0}},},},});const ENTITY_INFO=({timeOfDay:0,});const ENTITY_ACTIONS_CONFIG={delayToBurn:1000,};const getClosestTarget=(entity)=>{let minDistance=Infinity;let selectedTarget=(null);ENTITIES.forEach((targetEntity)=>{entity.movementOptions.targets.forEach((t)=>{if(targetEntity.cell&&targetEntity.type===t){const distance=getPosDistance(entity.cell.pos,targetEntity.cell.pos);if(distance<minDistance){selectedTarget=targetEntity;minDistance=distance;}}});});return selectedTarget;};const getClosestCell=(entity,cell,targetCell)=>{let minDistance=Infinity;let selectedCell=(null);let selectedIndex=0;const aPos=cell.adjacentPos[RENDER_INFO.currentPoly];for(let index=0;index<aPos.length;index++){const pos=aPos[index];const aCell=getCell(pos);if(cellIsBlocked(aCell,entity)&&aCell.entityType!==targetCell.entityType)continue;const distance=getPosDistance(aCell.pos,targetCell.pos);if(distance<minDistance){selectedCell=aCell;selectedIndex=index;minDistance=distance;}}return{cell:selectedCell,index:selectedIndex};};const moveEntities=(baseCell)=>{const{indexToMove}=getMovementMaps(baseCell);ENTITIES.forEach((e)=>{if(!e.cell||e.deleted)return;moveEntity(e,indexToMove);updateEntityOpacity(e);});};const moveEntity=(e,indexToMove)=>{if(!e.movementOptions?.speed)return;const{targets,speed,random,damage}=e.movementOptions;let nextCell=e.cell;let nextIndex=0;let target=(null);for(let index=0;index<speed;index++){if(targets){target=getClosestTarget(e);if(!target)return;const nextCellInfo=getClosestCell(e,nextCell,target.cell);nextCell=nextCellInfo.cell;nextIndex=nextCellInfo.index;if(!nextCell)return;}else if(random){nextIndex=getRandomInt(RENDER_INFO.currentPoly);const aPos=nextCell.adjacentPos[RENDER_INFO.currentPoly];nextCell=getCell(aPos[nextIndex]);for(let i=0;i<aPos.length;i++){if(!cellIsBlocked(nextCell,e))break;nextIndex=getMod(nextIndex+1,RENDER_INFO.currentPoly);nextCell=getCell(aPos[nextIndex]);}}}if(target&&nextCell.entityType===target.type&&damage){removeEntity(e);hurtEntity(target,damage);}if(cellIsBlocked(nextCell,e))return;nextIndex=getMod(nextIndex,RENDER_INFO.currentPoly);updateEntityImage(e,indexToMove[nextIndex]);moveEntityToCell(e,nextCell);};const getMovementMaps=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>{currentPoly=currentPoly??RENDER_INFO.currentPoly;hasInverted=hasInverted??getPolyInfo().hasInverted;let topI=rotationTurns??RENDER_INFO.rotationTurns;let bottomI=topI+Math.floor(currentPoly/2);let topLeftI=topI+currentPoly-1;let topRightI=topI+1;let bottomLeftI=bottomI+1;let bottomRightI=bottomI-1;if(hasInverted){topLeftI=bottomLeftI=topI+(baseCell.isInverted?1:2);topRightI=bottomRightI=topI+(baseCell.isInverted?2:1);bottomI=baseCell.isInverted?topI:undefined;topI=baseCell.isInverted?undefined:topI;}return{moveToIndex:{[MOVEMENT.UP]:topI,[MOVEMENT.DOWN]:bottomI,[MOVEMENT.LEFT]:useDiagonal?bottomLeftI:topLeftI,[MOVEMENT.RIGHT]:useDiagonal?bottomRightI:topRightI,},indexToMove:{[topI]:MOVEMENT.UP,[bottomI]:MOVEMENT.DOWN,[bottomLeftI]:MOVEMENT.LEFT,[topLeftI]:MOVEMENT.LEFT,[bottomRightI]:MOVEMENT.RIGHT,[topRightI]:MOVEMENT.RIGHT,},};};const getMovementMap=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>getMovementMaps(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted).moveToIndex;const killEntitiesByTimeOfDay=()=>{if(MENU_CONFIG.rain)return;const entitiesToKill=([]);ENTITIES.forEach((e)=>{if(!e.cell||!e.minTime||e.deleted||e.minTime<=ENTITY_INFO.timeOfDay)return;const fireEntity=createEntity(e.cell,e.id,ENTITY_TYPES.FIRE,{zIndex:e.zIndex+1,});e.connectedEntities[ENTITY_TYPES.FIRE]=fireEntity;e.deleted=true;entitiesToKill.push(e);});setTimeout(()=>{entitiesToKill.forEach(removeEntity);},ENTITY_ACTIONS_CONFIG.delayToBurn);};const MOVEMENT={DOWN:Symbol("DOWN"),LEFT:Symbol("LEFT"),RIGHT:Symbol("RIGHT"),UP:Symbol("UP"),};const ENTITY_TYPES={PLAYER:"PLAYER",BOAT:"BOAT",TREE:"TREE",ENEMY:"ENEMY",FIRE:"FIRE",RABBIT:"RABBIT",};const IMG_MAP_TYPES={DEFAULT:"DEFAULT",RUNNING:"RUNNING",USING:"USING",WINNING:"WINNING",LOSING:"LOSING",};const BIOME_TYPES={SNOW:"SNOW",DESERT:"DESERT",};const ENTITY_IMAGES_MAP=({[ENTITY_TYPES.PLAYER]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:4,j:0}},[MOVEMENT.LEFT]:{pos:{i:4,j:1}},[MOVEMENT.RIGHT]:{pos:{i:4,j:4}},[MOVEMENT.UP]:{pos:{i:4,j:5}},},[IMG_MAP_TYPES.RUNNING]:{[MOVEMENT.DOWN]:{posFn:(left)=>(left?{i:6,j:0}:{i:6,j:1}),},[MOVEMENT.LEFT]:{posFn:(left)=>(left?{i:6,j:2}:{i:6,j:3}),},[MOVEMENT.RIGHT]:{posFn:(left)=>(left?{i:6,j:4}:{i:6,j:5}),},[MOVEMENT.UP]:{posFn:(left)=>(left?{i:6,j:6}:{i:6,j:7}),},},[IMG_MAP_TYPES.USING]:{[MOVEMENT.DOWN]:{pos:{i:5,j:0}},[MOVEMENT.LEFT]:{pos:{i:5,j:1}},[MOVEMENT.RIGHT]:{pos:{i:5,j:2}},[MOVEMENT.UP]:{pos:{i:5,j:3}},},[IMG_MAP_TYPES.WINNING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:3}},},[IMG_MAP_TYPES.LOSING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:2}},},},[ENTITY_TYPES.TREE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:2}},},[BIOME_TYPES.DESERT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:0}},},[BIOME_TYPES.SNOW]:{[MOVEMENT.DOWN]:{pos:{i:3,j:1}},},},[ENTITY_TYPES.RABBIT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:4}},[MOVEMENT.LEFT]:{pos:{i:2,j:5}},[MOVEMENT.RIGHT]:{pos:{i:2,j:4}},[MOVEMENT.UP]:{pos:{i:2,j:5}},},},[ENTITY_TYPES.ENEMY]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:1,j:0}},[MOVEMENT.LEFT]:{pos:{i:1,j:1}},[MOVEMENT.RIGHT]:{pos:{i:1,j:2}},[MOVEMENT.UP]:{pos:{i:1,j:3}},},},[ENTITY_TYPES.BOAT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:0,j:0}},[MOVEMENT.LEFT]:{pos:{i:0,j:1}},[MOVEMENT.RIGHT]:{pos:{i:0,j:2}},[MOVEMENT.UP]:{pos:{i:0,j:3}},},},[ENTITY_TYPES.FIRE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:0}},},},});const ENTITY_INFO=({timeOfDay:0,});const ENTITY_INFO=({timeOfDay:0,});const POLYS_INFO=({});const getPolyInfo=()=>POLYS_INFO[RENDER_INFO.currentPoly];const calculatePointBasedOnPos=({i,j},isInverted,baseCell)=>{const{calcX,calcY,ySide,shouldIntercalate}=getPolyInfo();i-=RENDER_INFO.iOffset||0;j-=RENDER_INFO.jOffset||0;let x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=baseCell?.pos.j%2?-ySide:ySide;return applyRotation({x,y},isInverted,baseCell);};const getPosByIndex=(cell,index)=>cell.adjacentPos[RENDER_INFO.currentPoly][getMod(index||0,RENDER_INFO.currentPoly)];const applyRotation=({x,y},isInverted,baseCell)=>{if(!RENDER_INFO.rotationTurns)return{x,y};const{cx,cy,ySide,xSide,hasInverted}=getPolyInfo();const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;const radians=(Math.PI/180)*angle;const cos=Math.cos(radians);const sin=Math.sin(radians);let nx=correctRoundError(cos*(x-cx)+sin*(y-cy)+cx);let ny=correctRoundError(cos*(y-cy)-sin*(x-cx)+cy);if(hasInverted&&isInverted!==baseCell?.isInverted&&angle){const oddTurn=!!(RENDER_INFO.rotationTurns%2);ny+=ySide*(baseCell?.isInverted?1:-1);nx+=(xSide/2)*(baseCell?.isInverted===oddTurn?-1:1);}return{x:nx,y:ny};};const createWallPoints=(points,height)=>{let centerAndBottomPoints=points.filter((p)=>p.y>=0);if(centerAndBottomPoints.length<=1)centerAndBottomPoints=points.sort((a,b)=>a.x-b.x);const firstPoint=centerAndBottomPoints[0];const lastPoint=centerAndBottomPoints[centerAndBottomPoints.length-1];return[{x:firstPoint.x,y:firstPoint.y-height},...centerAndBottomPoints,{x:lastPoint.x,y:lastPoint.y-height},];};const getXFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(j)=>j*(polySide/2)+xSide;case KNOWN_POLYGONS.HEXAGON:return(j)=>j*(xSide+polySide/2)+xSide;case KNOWN_POLYGONS.SQUARE:default:return(j)=>j*xSide*2+xSide;}};const configPoly=(polySides,cellHeight)=>{let radiusFromSide=0;let radiusFromCorner=0;let polySide=0;const hasInverted=polySides%2===1;const ySide=correctRoundError(cellHeight/2);if(hasInverted){polySide=correctRoundError(Math.sqrt(cellHeight**2/(1-1/4)));radiusFromSide=correctRoundError((polySide/2)*(1/Math.tan(Math.PI/polySides)));}else{radiusFromSide=ySide;polySide=correctRoundError(2*radiusFromSide*Math.tan(Math.PI/polySides));}radiusFromCorner=correctRoundError(radiusFromSide*(1/Math.cos(Math.PI/polySides)));const shouldIntercalate=polySides>KNOWN_POLYGONS.SQUARE;const yCoeficient=hasInverted?correctRoundError(-cellHeight/6):0;const coeficient=(polySides/2+1)/2;const points=[];const sideRad=(2*Math.PI)/polySides;for(let i=0;i<polySides;i++){const nI=i-coeficient;const rad=sideRad*nI;const x=correctRoundError(radiusFromCorner*Math.cos(rad));const y=correctRoundError(radiusFromCorner*Math.sin(rad)+yCoeficient,1);points.push({x,y});}const xSide=points.reduce((acc,{x})=>(x>acc?x:acc),0);const invertedPoints=points.map((p)=>({x:-p.x,y:-p.y}));const wallPoints=createWallPoints(points,ySide);const wallInvertedPoints=createWallPoints(invertedPoints,ySide);const slopSide=correctRoundError(Math.sqrt(Math.abs(polySide**2-radiusFromSide**2)));const{innerHeight,innerWidth}=window;const rows=Math.floor(innerHeight/cellHeight);let columns=innerWidth/(xSide*2);if(hasInverted)columns=((innerWidth-2)*2-polySide)/polySide;if(shouldIntercalate)columns=((innerWidth-slopSide)*2)/(radiusFromCorner*2+polySide);columns=Math.floor(columns);if(columns%2===0)columns-=1;if(shouldIntercalate&&((columns+1)/2)%2===0)columns-=2;const canvasHeight=innerHeight;let canvasWidth=columns*(xSide*2);if(hasInverted)canvasWidth=(columns*polySide)/2+polySide/2+2;if(shouldIntercalate)canvasWidth=(columns*(radiusFromCorner*2+polySide))/2+slopSide;canvasWidth=Math.round(canvasWidth);return{polySide,xSide,ySide,points,invertedPoints,wallPoints,wallInvertedPoints,rows,columns,canvasHeight,canvasWidth,polySides,calcX:getXFn(polySides,polySide,xSide),calcY:(i)=>i*ySide*2+ySide,cx:correctRoundError(canvasWidth/2),cy:correctRoundError((canvasHeight-ySide*3)/2),shouldIntercalate,hasInverted,};};const configPolys=()=>{for(const p of KNOWN_POLYGONS_VALUES){POLYS_INFO[p]=configPoly(p,RENDER_INFO.cellHeight);}};let GRID=([]);const INITIAL_POS=({i:0,j:0});const getCell=({i,j})=>GRID[i]?.[j];const addCell=({i,j},cell)=>{GRID[i]=GRID[i]||[];GRID[i][j]=cell;};const resetGrid=()=>(GRID=[]);const KNOWN_POLYGONS={TRIANGLE:3,SQUARE:4,HEXAGON:6,};const POLYGONS_IMAGES={[KNOWN_POLYGONS.TRIANGLE]:"images/polys/triangle.png",[KNOWN_POLYGONS.SQUARE]:"images/polys/square.png",[KNOWN_POLYGONS.HEXAGON]:"images/polys/hexagon.png",};const POLYGONS_ENTITY_POS={[KNOWN_POLYGONS.TRIANGLE]:{i:7,j:2},[KNOWN_POLYGONS.SQUARE]:{i:7,j:1},[KNOWN_POLYGONS.HEXAGON]:{i:7,j:0},};const KNOWN_POLYGONS_VALUES=Object.values(KNOWN_POLYGONS);const MAP_GENERATION={MIX:"MIX",DISTANCE:"DISTANCE",};const MENU_CONFIG={debugMode:false,passTime:true,rotationAnimation:true,showPos:false,showChunks:false,usePerspective:false,showSelectedCell:true,rain:false,clouds:false,digitalClock:false,music:false,mapGeneration:MAP_GENERATION.DISTANCE,};const RENDER_INFO=({currentPoly:KNOWN_POLYGONS.HEXAGON,cellHeight:24,iOffset:0,jOffset:0,rotationTurns:0,});const ENTITY_ACTIONS_CONFIG={delayToBurn:1000,};const getClosestTarget=(entity)=>{let minDistance=Infinity;let selectedTarget=(null);ENTITIES.forEach((targetEntity)=>{entity.movementOptions.targets.forEach((t)=>{if(targetEntity.cell&&targetEntity.type===t){const distance=getPosDistance(entity.cell.pos,targetEntity.cell.pos);if(distance<minDistance){selectedTarget=targetEntity;minDistance=distance;}}});});return selectedTarget;};const getClosestCell=(entity,cell,targetCell)=>{let minDistance=Infinity;let selectedCell=(null);let selectedIndex=0;const aPos=cell.adjacentPos[RENDER_INFO.currentPoly];for(let index=0;index<aPos.length;index++){const pos=aPos[index];const aCell=getCell(pos);if(cellIsBlocked(aCell,entity)&&aCell.entityType!==targetCell.entityType)continue;const distance=getPosDistance(aCell.pos,targetCell.pos);if(distance<minDistance){selectedCell=aCell;selectedIndex=index;minDistance=distance;}}return{cell:selectedCell,index:selectedIndex};};const moveEntities=(baseCell)=>{const{indexToMove}=getMovementMaps(baseCell);ENTITIES.forEach((e)=>{if(!e.cell||e.deleted)return;moveEntity(e,indexToMove);updateEntityOpacity(e);});};const moveEntity=(e,indexToMove)=>{if(!e.movementOptions?.speed)return;const{targets,speed,random,damage}=e.movementOptions;let nextCell=e.cell;let nextIndex=0;let target=(null);for(let index=0;index<speed;index++){if(targets){target=getClosestTarget(e);if(!target)return;const nextCellInfo=getClosestCell(e,nextCell,target.cell);nextCell=nextCellInfo.cell;nextIndex=nextCellInfo.index;if(!nextCell)return;}else if(random){nextIndex=getRandomInt(RENDER_INFO.currentPoly);const aPos=nextCell.adjacentPos[RENDER_INFO.currentPoly];nextCell=getCell(aPos[nextIndex]);for(let i=0;i<aPos.length;i++){if(!cellIsBlocked(nextCell,e))break;nextIndex=getMod(nextIndex+1,RENDER_INFO.currentPoly);nextCell=getCell(aPos[nextIndex]);}}}if(target&&nextCell.entityType===target.type&&damage){removeEntity(e);hurtEntity(target,damage);}if(cellIsBlocked(nextCell,e))return;nextIndex=getMod(nextIndex,RENDER_INFO.currentPoly);updateEntityImage(e,indexToMove[nextIndex]);moveEntityToCell(e,nextCell);};const getMovementMaps=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>{currentPoly=currentPoly??RENDER_INFO.currentPoly;hasInverted=hasInverted??getPolyInfo().hasInverted;let topI=rotationTurns??RENDER_INFO.rotationTurns;let bottomI=topI+Math.floor(currentPoly/2);let topLeftI=topI+currentPoly-1;let topRightI=topI+1;let bottomLeftI=bottomI+1;let bottomRightI=bottomI-1;if(hasInverted){topLeftI=bottomLeftI=topI+(baseCell.isInverted?1:2);topRightI=bottomRightI=topI+(baseCell.isInverted?2:1);bottomI=baseCell.isInverted?topI:undefined;topI=baseCell.isInverted?undefined:topI;}return{moveToIndex:{[MOVEMENT.UP]:topI,[MOVEMENT.DOWN]:bottomI,[MOVEMENT.LEFT]:useDiagonal?bottomLeftI:topLeftI,[MOVEMENT.RIGHT]:useDiagonal?bottomRightI:topRightI,},indexToMove:{[topI]:MOVEMENT.UP,[bottomI]:MOVEMENT.DOWN,[bottomLeftI]:MOVEMENT.LEFT,[topLeftI]:MOVEMENT.LEFT,[bottomRightI]:MOVEMENT.RIGHT,[topRightI]:MOVEMENT.RIGHT,},};};const getMovementMap=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>getMovementMaps(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted).moveToIndex;const killEntitiesByTimeOfDay=()=>{if(MENU_CONFIG.rain)return;const entitiesToKill=([]);ENTITIES.forEach((e)=>{if(!e.cell||!e.minTime||e.deleted||e.minTime<=ENTITY_INFO.timeOfDay)return;const fireEntity=createEntity(e.cell,e.id,ENTITY_TYPES.FIRE,{zIndex:e.zIndex+1,});e.connectedEntities[ENTITY_TYPES.FIRE]=fireEntity;e.deleted=true;entitiesToKill.push(e);});setTimeout(()=>{entitiesToKill.forEach(removeEntity);},ENTITY_ACTIONS_CONFIG.delayToBurn);};const BOAT_ENTITIES=({});const getInBoat=(entity)=>{if(!BOAT_ENTITIES[entity.id])addBoat(entity.cell,entity);BOAT_ENTITIES[entity.id].isConnected=true;entity.connectedEntities[ENTITY_TYPES.BOAT]=BOAT_ENTITIES[entity.id];};const getOutBoat=(entity)=>{if(entity.connectedEntities[ENTITY_TYPES.BOAT]){delete entity.connectedEntities[ENTITY_TYPES.BOAT];BOAT_ENTITIES[entity.id].isConnected=false;moveEntityToCell(BOAT_ENTITIES[entity.id],entity.cell);}};const addBoat=(cell,entity)=>{let boatEntity=BOAT_ENTITIES[entity.id];if(!boatEntity)boatEntity=BOAT_ENTITIES[entity.id]=createEntity(cell,entity.id,ENTITY_TYPES.BOAT,{zIndex:1,movementsToCut:[MOVEMENT.UP,MOVEMENT.DOWN],currentDirection:MOVEMENT.RIGHT,});moveEntityToCell(boatEntity,cell);};const addEnemy=(cell)=>{const enemyEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.ENEMY,{minTime:40,movementOptions:{speed:1,targets:new Set([ENTITY_TYPES.PLAYER]),damage:1,},});if(enemyEntity&&cell.block.isFluid)getInBoat(enemyEntity);};const ENTITY_ACTIONS_CONFIG={delayToBurn:1000,};const getClosestTarget=(entity)=>{let minDistance=Infinity;let selectedTarget=(null);ENTITIES.forEach((targetEntity)=>{entity.movementOptions.targets.forEach((t)=>{if(targetEntity.cell&&targetEntity.type===t){const distance=getPosDistance(entity.cell.pos,targetEntity.cell.pos);if(distance<minDistance){selectedTarget=targetEntity;minDistance=distance;}}});});return selectedTarget;};const getClosestCell=(entity,cell,targetCell)=>{let minDistance=Infinity;let selectedCell=(null);let selectedIndex=0;const aPos=cell.adjacentPos[RENDER_INFO.currentPoly];for(let index=0;index<aPos.length;index++){const pos=aPos[index];const aCell=getCell(pos);if(cellIsBlocked(aCell,entity)&&aCell.entityType!==targetCell.entityType)continue;const distance=getPosDistance(aCell.pos,targetCell.pos);if(distance<minDistance){selectedCell=aCell;selectedIndex=index;minDistance=distance;}}return{cell:selectedCell,index:selectedIndex};};const moveEntities=(baseCell)=>{const{indexToMove}=getMovementMaps(baseCell);ENTITIES.forEach((e)=>{if(!e.cell||e.deleted)return;moveEntity(e,indexToMove);updateEntityOpacity(e);});};const moveEntity=(e,indexToMove)=>{if(!e.movementOptions?.speed)return;const{targets,speed,random,damage}=e.movementOptions;let nextCell=e.cell;let nextIndex=0;let target=(null);for(let index=0;index<speed;index++){if(targets){target=getClosestTarget(e);if(!target)return;const nextCellInfo=getClosestCell(e,nextCell,target.cell);nextCell=nextCellInfo.cell;nextIndex=nextCellInfo.index;if(!nextCell)return;}else if(random){nextIndex=getRandomInt(RENDER_INFO.currentPoly);const aPos=nextCell.adjacentPos[RENDER_INFO.currentPoly];nextCell=getCell(aPos[nextIndex]);for(let i=0;i<aPos.length;i++){if(!cellIsBlocked(nextCell,e))break;nextIndex=getMod(nextIndex+1,RENDER_INFO.currentPoly);nextCell=getCell(aPos[nextIndex]);}}}if(target&&nextCell.entityType===target.type&&damage){removeEntity(e);hurtEntity(target,damage);}if(cellIsBlocked(nextCell,e))return;nextIndex=getMod(nextIndex,RENDER_INFO.currentPoly);updateEntityImage(e,indexToMove[nextIndex]);moveEntityToCell(e,nextCell);};const getMovementMaps=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>{currentPoly=currentPoly??RENDER_INFO.currentPoly;hasInverted=hasInverted??getPolyInfo().hasInverted;let topI=rotationTurns??RENDER_INFO.rotationTurns;let bottomI=topI+Math.floor(currentPoly/2);let topLeftI=topI+currentPoly-1;let topRightI=topI+1;let bottomLeftI=bottomI+1;let bottomRightI=bottomI-1;if(hasInverted){topLeftI=bottomLeftI=topI+(baseCell.isInverted?1:2);topRightI=bottomRightI=topI+(baseCell.isInverted?2:1);bottomI=baseCell.isInverted?topI:undefined;topI=baseCell.isInverted?undefined:topI;}return{moveToIndex:{[MOVEMENT.UP]:topI,[MOVEMENT.DOWN]:bottomI,[MOVEMENT.LEFT]:useDiagonal?bottomLeftI:topLeftI,[MOVEMENT.RIGHT]:useDiagonal?bottomRightI:topRightI,},indexToMove:{[topI]:MOVEMENT.UP,[bottomI]:MOVEMENT.DOWN,[bottomLeftI]:MOVEMENT.LEFT,[topLeftI]:MOVEMENT.LEFT,[bottomRightI]:MOVEMENT.RIGHT,[topRightI]:MOVEMENT.RIGHT,},};};const getMovementMap=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>getMovementMaps(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted).moveToIndex;const killEntitiesByTimeOfDay=()=>{if(MENU_CONFIG.rain)return;const entitiesToKill=([]);ENTITIES.forEach((e)=>{if(!e.cell||!e.minTime||e.deleted||e.minTime<=ENTITY_INFO.timeOfDay)return;const fireEntity=createEntity(e.cell,e.id,ENTITY_TYPES.FIRE,{zIndex:e.zIndex+1,});e.connectedEntities[ENTITY_TYPES.FIRE]=fireEntity;e.deleted=true;entitiesToKill.push(e);});setTimeout(()=>{entitiesToKill.forEach(removeEntity);},ENTITY_ACTIONS_CONFIG.delayToBurn);};const spawnEntity=(entityType,cell)=>{switch(entityType){case ENTITY_TYPES.TREE:return addTree(cell);case ENTITY_TYPES.RABBIT:return addRabbit(cell);case ENTITY_TYPES.ENEMY:return addEnemy(cell);}};const PLAYER_CONFIG={maxHealth:10,};const PLAYER_ENTITY=({id:"PLAYER_1",type:ENTITY_TYPES.PLAYER,cell:null,img:document.getElementById("player"),connectedEntities:{},selectedCellIndex:0,health:PLAYER_CONFIG.maxHealth,});const addRabbit=(cell)=>{const rabbitEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.RABBIT,{isGenerated:true,movementOptions:{speed:1,random:true},});if(cell.block.isFluid)getInBoat(rabbitEntity);};const addTree=(cell)=>{const treeEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.TREE,{isGenerated:true});if(cell.block.isFluid)getInBoat(treeEntity);};const ENTITY_ACTIONS_CONFIG={delayToBurn:1000,};const getClosestTarget=(entity)=>{let minDistance=Infinity;let selectedTarget=(null);ENTITIES.forEach((targetEntity)=>{entity.movementOptions.targets.forEach((t)=>{if(targetEntity.cell&&targetEntity.type===t){const distance=getPosDistance(entity.cell.pos,targetEntity.cell.pos);if(distance<minDistance){selectedTarget=targetEntity;minDistance=distance;}}});});return selectedTarget;};const getClosestCell=(entity,cell,targetCell)=>{let minDistance=Infinity;let selectedCell=(null);let selectedIndex=0;const aPos=cell.adjacentPos[RENDER_INFO.currentPoly];for(let index=0;index<aPos.length;index++){const pos=aPos[index];const aCell=getCell(pos);if(cellIsBlocked(aCell,entity)&&aCell.entityType!==targetCell.entityType)continue;const distance=getPosDistance(aCell.pos,targetCell.pos);if(distance<minDistance){selectedCell=aCell;selectedIndex=index;minDistance=distance;}}return{cell:selectedCell,index:selectedIndex};};const moveEntities=(baseCell)=>{const{indexToMove}=getMovementMaps(baseCell);ENTITIES.forEach((e)=>{if(!e.cell||e.deleted)return;moveEntity(e,indexToMove);updateEntityOpacity(e);});};const moveEntity=(e,indexToMove)=>{if(!e.movementOptions?.speed)return;const{targets,speed,random,damage}=e.movementOptions;let nextCell=e.cell;let nextIndex=0;let target=(null);for(let index=0;index<speed;index++){if(targets){target=getClosestTarget(e);if(!target)return;const nextCellInfo=getClosestCell(e,nextCell,target.cell);nextCell=nextCellInfo.cell;nextIndex=nextCellInfo.index;if(!nextCell)return;}else if(random){nextIndex=getRandomInt(RENDER_INFO.currentPoly);const aPos=nextCell.adjacentPos[RENDER_INFO.currentPoly];nextCell=getCell(aPos[nextIndex]);for(let i=0;i<aPos.length;i++){if(!cellIsBlocked(nextCell,e))break;nextIndex=getMod(nextIndex+1,RENDER_INFO.currentPoly);nextCell=getCell(aPos[nextIndex]);}}}if(target&&nextCell.entityType===target.type&&damage){removeEntity(e);hurtEntity(target,damage);}if(cellIsBlocked(nextCell,e))return;nextIndex=getMod(nextIndex,RENDER_INFO.currentPoly);updateEntityImage(e,indexToMove[nextIndex]);moveEntityToCell(e,nextCell);};const getMovementMaps=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>{currentPoly=currentPoly??RENDER_INFO.currentPoly;hasInverted=hasInverted??getPolyInfo().hasInverted;let topI=rotationTurns??RENDER_INFO.rotationTurns;let bottomI=topI+Math.floor(currentPoly/2);let topLeftI=topI+currentPoly-1;let topRightI=topI+1;let bottomLeftI=bottomI+1;let bottomRightI=bottomI-1;if(hasInverted){topLeftI=bottomLeftI=topI+(baseCell.isInverted?1:2);topRightI=bottomRightI=topI+(baseCell.isInverted?2:1);bottomI=baseCell.isInverted?topI:undefined;topI=baseCell.isInverted?undefined:topI;}return{moveToIndex:{[MOVEMENT.UP]:topI,[MOVEMENT.DOWN]:bottomI,[MOVEMENT.LEFT]:useDiagonal?bottomLeftI:topLeftI,[MOVEMENT.RIGHT]:useDiagonal?bottomRightI:topRightI,},indexToMove:{[topI]:MOVEMENT.UP,[bottomI]:MOVEMENT.DOWN,[bottomLeftI]:MOVEMENT.LEFT,[topLeftI]:MOVEMENT.LEFT,[bottomRightI]:MOVEMENT.RIGHT,[topRightI]:MOVEMENT.RIGHT,},};};const getMovementMap=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>getMovementMaps(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted).moveToIndex;const killEntitiesByTimeOfDay=()=>{if(MENU_CONFIG.rain)return;const entitiesToKill=([]);ENTITIES.forEach((e)=>{if(!e.cell||!e.minTime||e.deleted||e.minTime<=ENTITY_INFO.timeOfDay)return;const fireEntity=createEntity(e.cell,e.id,ENTITY_TYPES.FIRE,{zIndex:e.zIndex+1,});e.connectedEntities[ENTITY_TYPES.FIRE]=fireEntity;e.deleted=true;entitiesToKill.push(e);});setTimeout(()=>{entitiesToKill.forEach(removeEntity);},ENTITY_ACTIONS_CONFIG.delayToBurn);};const ENTITIES=(new Set());const addEntity=(entity)=>ENTITIES.add(entity);const moveEntityToCell=(entity,cell)=>{if(!cell)return;const previousType=entity.cell?.entityType||cell.entityType;if(entity.cell)entity.cell.entityType=null;entity.cell=cell;entity.cell.entityType=previousType||entity.type;updateEntityPoint(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach((e)=>moveEntityToCell(e,cell));};const removeEntity=(entity)=>{entity.cell.entityType=null;removeEntityImage(entity);ENTITIES.delete(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach(removeEntity);};const getEntitiesFromCell=(cell)=>{const entities=([]);ENTITIES.forEach((entity)=>{if(entity.cell===cell)entities.push(entity);});return entities;};const createEntity=(cell,id,type,entityParams={})=>{if(entityParams.minTime&&ENTITY_INFO.timeOfDay<entityParams.minTime)return;const entity=({id:`${type}_${id}`,type,connectedEntities:{},currentImgType:cell.block?.biomeType,health:1,...entityParams,});createEntityImage(entity);moveEntityToCell(entity,cell);addEntity(entity);return entity;};const setEntitiesSize=()=>ENTITIES.forEach((e)=>setEntitySize(e));const removeGeneratedEntities=()=>ENTITIES.forEach((e)=>e.isGenerated&&removeEntity(e));const updateEntities=()=>ENTITIES.forEach((e)=>updateEntityPoint(e));const cellIsBlocked=(cell,entity)=>!MENU_CONFIG.debugMode&&(!cell||!cell.block||!!cell.wall||!!cell.entityType||(entity.connectedEntities[ENTITY_TYPES.BOAT]?!cell.block.isFluid:cell.block.isFluid));const getSelectedCell=(entity)=>getCell(getPosByIndex(entity.cell,entity.selectedCellIndex));const updateEntityDirection=(entity,direction)=>{updateEntityImage(entity,direction);Object.values(entity.connectedEntities).forEach((e)=>{updateEntityImage(e,MOVEMENT.RIGHT);});};const makeEntityUse=(entity)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.USING);setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},250);};const updateEntityHealth=(entity)=>{if(entity===PLAYER_ENTITY){if(entity.health>PLAYER_CONFIG.maxHealth)entity.health=PLAYER_CONFIG.maxHealth;updatePlayerHearts();}else if(entity.health<=0)removeEntity(entity);};const giveItemToEntity=(entity,item)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.WINNING);const callback=displayWinAnimation(entity,item.imgPos);if(item.health){entity.health+=item.health;updateEntityHealth(entity);}setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);callback();},1000);};const hurtEntity=(entity,damage)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.LOSING);entity.health-=damage;updateEntityHealth(entity);if(entity.health>0)setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},1000);};const makeEntityRun=(entity,direction)=>{const connectedEntities=Object.values(entity.connectedEntities);if(!connectedEntities.length){updateEntityImage(entity,direction,IMG_MAP_TYPES.RUNNING);return;}updateEntityImage(entity,direction);connectedEntities.forEach((e)=>{updateEntityImage(e,direction);cutEntityImage(e,direction);});};const BOAT_ENTITIES=({});const getInBoat=(entity)=>{if(!BOAT_ENTITIES[entity.id])addBoat(entity.cell,entity);BOAT_ENTITIES[entity.id].isConnected=true;entity.connectedEntities[ENTITY_TYPES.BOAT]=BOAT_ENTITIES[entity.id];};const getOutBoat=(entity)=>{if(entity.connectedEntities[ENTITY_TYPES.BOAT]){delete entity.connectedEntities[ENTITY_TYPES.BOAT];BOAT_ENTITIES[entity.id].isConnected=false;moveEntityToCell(BOAT_ENTITIES[entity.id],entity.cell);}};const addBoat=(cell,entity)=>{let boatEntity=BOAT_ENTITIES[entity.id];if(!boatEntity)boatEntity=BOAT_ENTITIES[entity.id]=createEntity(cell,entity.id,ENTITY_TYPES.BOAT,{zIndex:1,movementsToCut:[MOVEMENT.UP,MOVEMENT.DOWN],currentDirection:MOVEMENT.RIGHT,});moveEntityToCell(boatEntity,cell);};const addEnemy=(cell)=>{const enemyEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.ENEMY,{minTime:40,movementOptions:{speed:1,targets:new Set([ENTITY_TYPES.PLAYER]),damage:1,},});if(enemyEntity&&cell.block.isFluid)getInBoat(enemyEntity);};const spawnEntity=(entityType,cell)=>{switch(entityType){case ENTITY_TYPES.TREE:return addTree(cell);case ENTITY_TYPES.RABBIT:return addRabbit(cell);case ENTITY_TYPES.ENEMY:return addEnemy(cell);}};const MOVEMENT={DOWN:Symbol("DOWN"),LEFT:Symbol("LEFT"),RIGHT:Symbol("RIGHT"),UP:Symbol("UP"),};const ENTITY_TYPES={PLAYER:"PLAYER",BOAT:"BOAT",TREE:"TREE",ENEMY:"ENEMY",FIRE:"FIRE",RABBIT:"RABBIT",};const IMG_MAP_TYPES={DEFAULT:"DEFAULT",RUNNING:"RUNNING",USING:"USING",WINNING:"WINNING",LOSING:"LOSING",};const BIOME_TYPES={SNOW:"SNOW",DESERT:"DESERT",};const ENTITY_IMAGES_MAP=({[ENTITY_TYPES.PLAYER]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:4,j:0}},[MOVEMENT.LEFT]:{pos:{i:4,j:1}},[MOVEMENT.RIGHT]:{pos:{i:4,j:4}},[MOVEMENT.UP]:{pos:{i:4,j:5}},},[IMG_MAP_TYPES.RUNNING]:{[MOVEMENT.DOWN]:{posFn:(left)=>(left?{i:6,j:0}:{i:6,j:1}),},[MOVEMENT.LEFT]:{posFn:(left)=>(left?{i:6,j:2}:{i:6,j:3}),},[MOVEMENT.RIGHT]:{posFn:(left)=>(left?{i:6,j:4}:{i:6,j:5}),},[MOVEMENT.UP]:{posFn:(left)=>(left?{i:6,j:6}:{i:6,j:7}),},},[IMG_MAP_TYPES.USING]:{[MOVEMENT.DOWN]:{pos:{i:5,j:0}},[MOVEMENT.LEFT]:{pos:{i:5,j:1}},[MOVEMENT.RIGHT]:{pos:{i:5,j:2}},[MOVEMENT.UP]:{pos:{i:5,j:3}},},[IMG_MAP_TYPES.WINNING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:3}},},[IMG_MAP_TYPES.LOSING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:2}},},},[ENTITY_TYPES.TREE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:2}},},[BIOME_TYPES.DESERT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:0}},},[BIOME_TYPES.SNOW]:{[MOVEMENT.DOWN]:{pos:{i:3,j:1}},},},[ENTITY_TYPES.RABBIT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:4}},[MOVEMENT.LEFT]:{pos:{i:2,j:5}},[MOVEMENT.RIGHT]:{pos:{i:2,j:4}},[MOVEMENT.UP]:{pos:{i:2,j:5}},},},[ENTITY_TYPES.ENEMY]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:1,j:0}},[MOVEMENT.LEFT]:{pos:{i:1,j:1}},[MOVEMENT.RIGHT]:{pos:{i:1,j:2}},[MOVEMENT.UP]:{pos:{i:1,j:3}},},},[ENTITY_TYPES.BOAT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:0,j:0}},[MOVEMENT.LEFT]:{pos:{i:0,j:1}},[MOVEMENT.RIGHT]:{pos:{i:0,j:2}},[MOVEMENT.UP]:{pos:{i:0,j:3}},},},[ENTITY_TYPES.FIRE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:0}},},},});const PLAYER_CONFIG={maxHealth:10,};const PLAYER_ENTITY=({id:"PLAYER_1",type:ENTITY_TYPES.PLAYER,cell:null,img:document.getElementById("player"),connectedEntities:{},selectedCellIndex:0,health:PLAYER_CONFIG.maxHealth,});const addRabbit=(cell)=>{const rabbitEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.RABBIT,{isGenerated:true,movementOptions:{speed:1,random:true},});if(cell.block.isFluid)getInBoat(rabbitEntity);};const ENTITY_INFO=({timeOfDay:0,});const POLYS_INFO=({});const getPolyInfo=()=>POLYS_INFO[RENDER_INFO.currentPoly];const calculatePointBasedOnPos=({i,j},isInverted,baseCell)=>{const{calcX,calcY,ySide,shouldIntercalate}=getPolyInfo();i-=RENDER_INFO.iOffset||0;j-=RENDER_INFO.jOffset||0;let x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=baseCell?.pos.j%2?-ySide:ySide;return applyRotation({x,y},isInverted,baseCell);};const getPosByIndex=(cell,index)=>cell.adjacentPos[RENDER_INFO.currentPoly][getMod(index||0,RENDER_INFO.currentPoly)];const applyRotation=({x,y},isInverted,baseCell)=>{if(!RENDER_INFO.rotationTurns)return{x,y};const{cx,cy,ySide,xSide,hasInverted}=getPolyInfo();const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;const radians=(Math.PI/180)*angle;const cos=Math.cos(radians);const sin=Math.sin(radians);let nx=correctRoundError(cos*(x-cx)+sin*(y-cy)+cx);let ny=correctRoundError(cos*(y-cy)-sin*(x-cx)+cy);if(hasInverted&&isInverted!==baseCell?.isInverted&&angle){const oddTurn=!!(RENDER_INFO.rotationTurns%2);ny+=ySide*(baseCell?.isInverted?1:-1);nx+=(xSide/2)*(baseCell?.isInverted===oddTurn?-1:1);}return{x:nx,y:ny};};const createWallPoints=(points,height)=>{let centerAndBottomPoints=points.filter((p)=>p.y>=0);if(centerAndBottomPoints.length<=1)centerAndBottomPoints=points.sort((a,b)=>a.x-b.x);const firstPoint=centerAndBottomPoints[0];const lastPoint=centerAndBottomPoints[centerAndBottomPoints.length-1];return[{x:firstPoint.x,y:firstPoint.y-height},...centerAndBottomPoints,{x:lastPoint.x,y:lastPoint.y-height},];};const getXFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(j)=>j*(polySide/2)+xSide;case KNOWN_POLYGONS.HEXAGON:return(j)=>j*(xSide+polySide/2)+xSide;case KNOWN_POLYGONS.SQUARE:default:return(j)=>j*xSide*2+xSide;}};const configPoly=(polySides,cellHeight)=>{let radiusFromSide=0;let radiusFromCorner=0;let polySide=0;const hasInverted=polySides%2===1;const ySide=correctRoundError(cellHeight/2);if(hasInverted){polySide=correctRoundError(Math.sqrt(cellHeight**2/(1-1/4)));radiusFromSide=correctRoundError((polySide/2)*(1/Math.tan(Math.PI/polySides)));}else{radiusFromSide=ySide;polySide=correctRoundError(2*radiusFromSide*Math.tan(Math.PI/polySides));}radiusFromCorner=correctRoundError(radiusFromSide*(1/Math.cos(Math.PI/polySides)));const shouldIntercalate=polySides>KNOWN_POLYGONS.SQUARE;const yCoeficient=hasInverted?correctRoundError(-cellHeight/6):0;const coeficient=(polySides/2+1)/2;const points=[];const sideRad=(2*Math.PI)/polySides;for(let i=0;i<polySides;i++){const nI=i-coeficient;const rad=sideRad*nI;const x=correctRoundError(radiusFromCorner*Math.cos(rad));const y=correctRoundError(radiusFromCorner*Math.sin(rad)+yCoeficient,1);points.push({x,y});}const xSide=points.reduce((acc,{x})=>(x>acc?x:acc),0);const invertedPoints=points.map((p)=>({x:-p.x,y:-p.y}));const wallPoints=createWallPoints(points,ySide);const wallInvertedPoints=createWallPoints(invertedPoints,ySide);const slopSide=correctRoundError(Math.sqrt(Math.abs(polySide**2-radiusFromSide**2)));const{innerHeight,innerWidth}=window;const rows=Math.floor(innerHeight/cellHeight);let columns=innerWidth/(xSide*2);if(hasInverted)columns=((innerWidth-2)*2-polySide)/polySide;if(shouldIntercalate)columns=((innerWidth-slopSide)*2)/(radiusFromCorner*2+polySide);columns=Math.floor(columns);if(columns%2===0)columns-=1;if(shouldIntercalate&&((columns+1)/2)%2===0)columns-=2;const canvasHeight=innerHeight;let canvasWidth=columns*(xSide*2);if(hasInverted)canvasWidth=(columns*polySide)/2+polySide/2+2;if(shouldIntercalate)canvasWidth=(columns*(radiusFromCorner*2+polySide))/2+slopSide;canvasWidth=Math.round(canvasWidth);return{polySide,xSide,ySide,points,invertedPoints,wallPoints,wallInvertedPoints,rows,columns,canvasHeight,canvasWidth,polySides,calcX:getXFn(polySides,polySide,xSide),calcY:(i)=>i*ySide*2+ySide,cx:correctRoundError(canvasWidth/2),cy:correctRoundError((canvasHeight-ySide*3)/2),shouldIntercalate,hasInverted,};};const configPolys=()=>{for(const p of KNOWN_POLYGONS_VALUES){POLYS_INFO[p]=configPoly(p,RENDER_INFO.cellHeight);}};const addTree=(cell)=>{const treeEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.TREE,{isGenerated:true});if(cell.block.isFluid)getInBoat(treeEntity);};const BOAT_ENTITIES=({});const getInBoat=(entity)=>{if(!BOAT_ENTITIES[entity.id])addBoat(entity.cell,entity);BOAT_ENTITIES[entity.id].isConnected=true;entity.connectedEntities[ENTITY_TYPES.BOAT]=BOAT_ENTITIES[entity.id];};const getOutBoat=(entity)=>{if(entity.connectedEntities[ENTITY_TYPES.BOAT]){delete entity.connectedEntities[ENTITY_TYPES.BOAT];BOAT_ENTITIES[entity.id].isConnected=false;moveEntityToCell(BOAT_ENTITIES[entity.id],entity.cell);}};const addBoat=(cell,entity)=>{let boatEntity=BOAT_ENTITIES[entity.id];if(!boatEntity)boatEntity=BOAT_ENTITIES[entity.id]=createEntity(cell,entity.id,ENTITY_TYPES.BOAT,{zIndex:1,movementsToCut:[MOVEMENT.UP,MOVEMENT.DOWN],currentDirection:MOVEMENT.RIGHT,});moveEntityToCell(boatEntity,cell);};const addEnemy=(cell)=>{const enemyEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.ENEMY,{minTime:40,movementOptions:{speed:1,targets:new Set([ENTITY_TYPES.PLAYER]),damage:1,},});if(enemyEntity&&cell.block.isFluid)getInBoat(enemyEntity);};const spawnEntity=(entityType,cell)=>{switch(entityType){case ENTITY_TYPES.TREE:return addTree(cell);case ENTITY_TYPES.RABBIT:return addRabbit(cell);case ENTITY_TYPES.ENEMY:return addEnemy(cell);}};const BOAT_ENTITIES=({});const getInBoat=(entity)=>{if(!BOAT_ENTITIES[entity.id])addBoat(entity.cell,entity);BOAT_ENTITIES[entity.id].isConnected=true;entity.connectedEntities[ENTITY_TYPES.BOAT]=BOAT_ENTITIES[entity.id];};const getOutBoat=(entity)=>{if(entity.connectedEntities[ENTITY_TYPES.BOAT]){delete entity.connectedEntities[ENTITY_TYPES.BOAT];BOAT_ENTITIES[entity.id].isConnected=false;moveEntityToCell(BOAT_ENTITIES[entity.id],entity.cell);}};const addBoat=(cell,entity)=>{let boatEntity=BOAT_ENTITIES[entity.id];if(!boatEntity)boatEntity=BOAT_ENTITIES[entity.id]=createEntity(cell,entity.id,ENTITY_TYPES.BOAT,{zIndex:1,movementsToCut:[MOVEMENT.UP,MOVEMENT.DOWN],currentDirection:MOVEMENT.RIGHT,});moveEntityToCell(boatEntity,cell);};const PLAYER_CONFIG={maxHealth:10,};const PLAYER_ENTITY=({id:"PLAYER_1",type:ENTITY_TYPES.PLAYER,cell:null,img:document.getElementById("player"),connectedEntities:{},selectedCellIndex:0,health:PLAYER_CONFIG.maxHealth,});const CUT_MOVEMENTS_MAP={[MOVEMENT.DOWN]:"marginTop",[MOVEMENT.LEFT]:"marginLeft",[MOVEMENT.RIGHT]:"marginRight",[MOVEMENT.UP]:"marginTop",};const container=document.getElementById("entities");const createImageElement=()=>{const img=document.createElement("div");img.className="image";return img;};const createEntityImage=(entity)=>{const img=createImageElement();img.id=entity.id;img.style.zIndex=`${entity.zIndex ||2}`;container.appendChild(img);entity.img=img;setEntitySize(entity);};const displayWinAnimation=(entity,itemPos)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);const img=createImageElement();img.classList.add("won-item");img.style.marginTop=`-${ySide}px`;setImagePos(img,itemPos);container.appendChild(img);setEntityImageSize(img,ySide/2);setImagePoint(img,point,false,ySide/2);return()=>{container.removeChild(img);};};const removeEntityImage=(entity)=>{if(entity.img)container.removeChild(entity.img);entity.img=null;};const updateEntityPoint=(entity,parentPoint)=>{if(!parentPoint&&entity.isConnected)return;const{hasInverted,canvasHeight,canvasWidth}=getPolyInfo();const point=parentPoint||calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);if(isPointOutside(point,canvasHeight,canvasWidth)){if(entity.img)removeEntityImage(entity);}else if(!entity.img){createEntityImage(entity);}if(entity.img)setImagePoint(entity.img,point);verifyEntityHeight(entity);Object.values(entity.connectedEntities).forEach((e)=>updateEntityPoint(e,point));};const updateEntityOpacity=(entity)=>{if(!entity?.img||entity?.deleted)return;entity.img.style.setProperty("--entity-opacity",`${entity.cell.modifier ||1}`);};const getEntitySize=(ySide)=>Math.round((ySide||getPolyInfo().ySide)*2.5);const setImagePos=(img,pos)=>{img.style.setProperty("--entity-position-i",`${pos.i}`);img.style.setProperty("--entity-position-j",`${pos.j}`);};const setEntityImageSize=(img,ySide)=>{if(!img)return;const size=getEntitySize(ySide);img.style.setProperty("--entity-size",`${size}px`);};const setEntitySize=(entity,ySide)=>{if(!entity?.img)return;setEntityImageSize(entity.img,ySide);setEntityImageInfo(entity);};const setEntityImageInfo=(entity)=>{const imgInfo=getEntityImageInfo(entity);if(!imgInfo.src){entity.img.style.removeProperty("--entity-img");entity.img.classList.remove("dont-use-spritesheet");}if(imgInfo.pos){setImagePos(entity.img,imgInfo.pos);}else if(imgInfo.posFn){const pos=imgInfo.posFn(!!entity.leftFootWalk);entity.leftFootWalk=!entity.leftFootWalk;setImagePos(entity.img,pos);}else if(imgInfo.src){entity.img.style.setProperty("--entity-img",`url(${imgInfo.src})`);entity.img.classList.add("dont-use-spritesheet");setImagePos(entity.img,{i:0,j:0});}};const setImagePoint=(img,point,shouldCenter,ySide)=>{if(!point)return;const entitySize=getEntitySize(ySide);img.style.setProperty("--entity-top",`${point.y -entitySize /(shouldCenter ?2 :1.25)}px`);img.style.setProperty("--entity-left",`${point.x -entitySize /2}px`);};const verifyEntityHeight=(entity)=>{if(!entity?.cell||!entity?.img)return;const{hasInverted}=getPolyInfo();const downI=hasInverted&&entity.cell.isInverted?RENDER_INFO.rotationTurns:RENDER_INFO.rotationTurns+Math.floor(RENDER_INFO.currentPoly/2);const downPos=getPosByIndex(entity.cell,downI);const downCell=getCell(downPos);if(!downCell)return;entity.img.classList.remove("not-inverted-both-walls");entity.img.classList.remove("not-inverted-right-wall");entity.img.classList.remove("not-inverted-left-wall");entity.img.classList.remove("behind-wall");if(hasInverted&&!entity.cell.isInverted){const rightCell=downCell;const leftI=RENDER_INFO.rotationTurns+RENDER_INFO.currentPoly-1;const leftPos=getPosByIndex(entity.cell,leftI);const leftCell=getCell(leftPos);if(rightCell.wall&&leftCell.wall){entity.img.classList.add("not-inverted-both-walls");}else if(rightCell.wall){entity.img.classList.add("not-inverted-right-wall");}else if(leftCell.wall){entity.img.classList.add("not-inverted-left-wall");}}else if(downCell.wall){entity.img.classList.add("behind-wall");}if(Object.values(entity.connectedEntities).length)entity.img.classList.add("behind-wall");};const getEntityImageInfo=(entity)=>{const typeMap=ENTITY_IMAGES_MAP[entity.type];const mapType=typeMap[entity.currentImgType]||typeMap[IMG_MAP_TYPES.DEFAULT];return(mapType[entity.currentDirection||MOVEMENT.DOWN]||mapType[MOVEMENT.DOWN]);};const updateEntityImage=(entity,direction,imgMapType)=>{if(!entity?.img)return;entity.currentImgType=imgMapType;entity.currentDirection=direction;setEntityImageInfo(entity);entity.img.style.marginTop=null;entity.img.style.marginLeft=null;entity.img.style.marginRight=null;};const cutEntityImage=(entity,direction)=>{if(entity.movementsToCut?.length){if(entity.movementsToCut.includes(direction)){const{ySide}=getPolyInfo();entity.img.style[CUT_MOVEMENTS_MAP[direction]]=`${ySide}px`;}}};const playerHealthContainer=document.getElementById("health-container");const updatePlayerHearts=()=>{playerHealthContainer.innerHTML="";let curretnHealth=PLAYER_ENTITY.health;for(let i=0;i<PLAYER_CONFIG.maxHealth;i++){const heartImg=createImageElement();if(curretnHealth){setImagePos(heartImg,{i:2,j:3});heartImg.classList.add("filled");curretnHealth--;}else{setImagePos(heartImg,{i:2,j:2});}playerHealthContainer.appendChild(heartImg);}};updatePlayerHearts();const ENTITY_ACTIONS_CONFIG={delayToBurn:1000,};const getClosestTarget=(entity)=>{let minDistance=Infinity;let selectedTarget=(null);ENTITIES.forEach((targetEntity)=>{entity.movementOptions.targets.forEach((t)=>{if(targetEntity.cell&&targetEntity.type===t){const distance=getPosDistance(entity.cell.pos,targetEntity.cell.pos);if(distance<minDistance){selectedTarget=targetEntity;minDistance=distance;}}});});return selectedTarget;};const getClosestCell=(entity,cell,targetCell)=>{let minDistance=Infinity;let selectedCell=(null);let selectedIndex=0;const aPos=cell.adjacentPos[RENDER_INFO.currentPoly];for(let index=0;index<aPos.length;index++){const pos=aPos[index];const aCell=getCell(pos);if(cellIsBlocked(aCell,entity)&&aCell.entityType!==targetCell.entityType)continue;const distance=getPosDistance(aCell.pos,targetCell.pos);if(distance<minDistance){selectedCell=aCell;selectedIndex=index;minDistance=distance;}}return{cell:selectedCell,index:selectedIndex};};const moveEntities=(baseCell)=>{const{indexToMove}=getMovementMaps(baseCell);ENTITIES.forEach((e)=>{if(!e.cell||e.deleted)return;moveEntity(e,indexToMove);updateEntityOpacity(e);});};const moveEntity=(e,indexToMove)=>{if(!e.movementOptions?.speed)return;const{targets,speed,random,damage}=e.movementOptions;let nextCell=e.cell;let nextIndex=0;let target=(null);for(let index=0;index<speed;index++){if(targets){target=getClosestTarget(e);if(!target)return;const nextCellInfo=getClosestCell(e,nextCell,target.cell);nextCell=nextCellInfo.cell;nextIndex=nextCellInfo.index;if(!nextCell)return;}else if(random){nextIndex=getRandomInt(RENDER_INFO.currentPoly);const aPos=nextCell.adjacentPos[RENDER_INFO.currentPoly];nextCell=getCell(aPos[nextIndex]);for(let i=0;i<aPos.length;i++){if(!cellIsBlocked(nextCell,e))break;nextIndex=getMod(nextIndex+1,RENDER_INFO.currentPoly);nextCell=getCell(aPos[nextIndex]);}}}if(target&&nextCell.entityType===target.type&&damage){removeEntity(e);hurtEntity(target,damage);}if(cellIsBlocked(nextCell,e))return;nextIndex=getMod(nextIndex,RENDER_INFO.currentPoly);updateEntityImage(e,indexToMove[nextIndex]);moveEntityToCell(e,nextCell);};const getMovementMaps=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>{currentPoly=currentPoly??RENDER_INFO.currentPoly;hasInverted=hasInverted??getPolyInfo().hasInverted;let topI=rotationTurns??RENDER_INFO.rotationTurns;let bottomI=topI+Math.floor(currentPoly/2);let topLeftI=topI+currentPoly-1;let topRightI=topI+1;let bottomLeftI=bottomI+1;let bottomRightI=bottomI-1;if(hasInverted){topLeftI=bottomLeftI=topI+(baseCell.isInverted?1:2);topRightI=bottomRightI=topI+(baseCell.isInverted?2:1);bottomI=baseCell.isInverted?topI:undefined;topI=baseCell.isInverted?undefined:topI;}return{moveToIndex:{[MOVEMENT.UP]:topI,[MOVEMENT.DOWN]:bottomI,[MOVEMENT.LEFT]:useDiagonal?bottomLeftI:topLeftI,[MOVEMENT.RIGHT]:useDiagonal?bottomRightI:topRightI,},indexToMove:{[topI]:MOVEMENT.UP,[bottomI]:MOVEMENT.DOWN,[bottomLeftI]:MOVEMENT.LEFT,[topLeftI]:MOVEMENT.LEFT,[bottomRightI]:MOVEMENT.RIGHT,[topRightI]:MOVEMENT.RIGHT,},};};const getMovementMap=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>getMovementMaps(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted).moveToIndex;const killEntitiesByTimeOfDay=()=>{if(MENU_CONFIG.rain)return;const entitiesToKill=([]);ENTITIES.forEach((e)=>{if(!e.cell||!e.minTime||e.deleted||e.minTime<=ENTITY_INFO.timeOfDay)return;const fireEntity=createEntity(e.cell,e.id,ENTITY_TYPES.FIRE,{zIndex:e.zIndex+1,});e.connectedEntities[ENTITY_TYPES.FIRE]=fireEntity;e.deleted=true;entitiesToKill.push(e);});setTimeout(()=>{entitiesToKill.forEach(removeEntity);},ENTITY_ACTIONS_CONFIG.delayToBurn);};const GENERATION_CONFIG={chunkSize:50,};const getRange=(n,range)=>Math.floor(n/range)*range;const getChunkStart=(pos,height,width)=>({i:getRange(pos.i,height),j:getRange(pos.j,width),});const MOVEMENT={DOWN:Symbol("DOWN"),LEFT:Symbol("LEFT"),RIGHT:Symbol("RIGHT"),UP:Symbol("UP"),};const ENTITY_TYPES={PLAYER:"PLAYER",BOAT:"BOAT",TREE:"TREE",ENEMY:"ENEMY",FIRE:"FIRE",RABBIT:"RABBIT",};const IMG_MAP_TYPES={DEFAULT:"DEFAULT",RUNNING:"RUNNING",USING:"USING",WINNING:"WINNING",LOSING:"LOSING",};const BIOME_TYPES={SNOW:"SNOW",DESERT:"DESERT",};const ENTITY_IMAGES_MAP=({[ENTITY_TYPES.PLAYER]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:4,j:0}},[MOVEMENT.LEFT]:{pos:{i:4,j:1}},[MOVEMENT.RIGHT]:{pos:{i:4,j:4}},[MOVEMENT.UP]:{pos:{i:4,j:5}},},[IMG_MAP_TYPES.RUNNING]:{[MOVEMENT.DOWN]:{posFn:(left)=>(left?{i:6,j:0}:{i:6,j:1}),},[MOVEMENT.LEFT]:{posFn:(left)=>(left?{i:6,j:2}:{i:6,j:3}),},[MOVEMENT.RIGHT]:{posFn:(left)=>(left?{i:6,j:4}:{i:6,j:5}),},[MOVEMENT.UP]:{posFn:(left)=>(left?{i:6,j:6}:{i:6,j:7}),},},[IMG_MAP_TYPES.USING]:{[MOVEMENT.DOWN]:{pos:{i:5,j:0}},[MOVEMENT.LEFT]:{pos:{i:5,j:1}},[MOVEMENT.RIGHT]:{pos:{i:5,j:2}},[MOVEMENT.UP]:{pos:{i:5,j:3}},},[IMG_MAP_TYPES.WINNING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:3}},},[IMG_MAP_TYPES.LOSING]:{[MOVEMENT.DOWN]:{pos:{i:4,j:2}},},},[ENTITY_TYPES.TREE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:2}},},[BIOME_TYPES.DESERT]:{[MOVEMENT.DOWN]:{pos:{i:3,j:0}},},[BIOME_TYPES.SNOW]:{[MOVEMENT.DOWN]:{pos:{i:3,j:1}},},},[ENTITY_TYPES.RABBIT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:4}},[MOVEMENT.LEFT]:{pos:{i:2,j:5}},[MOVEMENT.RIGHT]:{pos:{i:2,j:4}},[MOVEMENT.UP]:{pos:{i:2,j:5}},},},[ENTITY_TYPES.ENEMY]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:1,j:0}},[MOVEMENT.LEFT]:{pos:{i:1,j:1}},[MOVEMENT.RIGHT]:{pos:{i:1,j:2}},[MOVEMENT.UP]:{pos:{i:1,j:3}},},},[ENTITY_TYPES.BOAT]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:0,j:0}},[MOVEMENT.LEFT]:{pos:{i:0,j:1}},[MOVEMENT.RIGHT]:{pos:{i:0,j:2}},[MOVEMENT.UP]:{pos:{i:0,j:3}},},},[ENTITY_TYPES.FIRE]:{[IMG_MAP_TYPES.DEFAULT]:{[MOVEMENT.DOWN]:{pos:{i:2,j:0}},},},});const BOAT_ENTITIES=({});const getInBoat=(entity)=>{if(!BOAT_ENTITIES[entity.id])addBoat(entity.cell,entity);BOAT_ENTITIES[entity.id].isConnected=true;entity.connectedEntities[ENTITY_TYPES.BOAT]=BOAT_ENTITIES[entity.id];};const getOutBoat=(entity)=>{if(entity.connectedEntities[ENTITY_TYPES.BOAT]){delete entity.connectedEntities[ENTITY_TYPES.BOAT];BOAT_ENTITIES[entity.id].isConnected=false;moveEntityToCell(BOAT_ENTITIES[entity.id],entity.cell);}};const addBoat=(cell,entity)=>{let boatEntity=BOAT_ENTITIES[entity.id];if(!boatEntity)boatEntity=BOAT_ENTITIES[entity.id]=createEntity(cell,entity.id,ENTITY_TYPES.BOAT,{zIndex:1,movementsToCut:[MOVEMENT.UP,MOVEMENT.DOWN],currentDirection:MOVEMENT.RIGHT,});moveEntityToCell(boatEntity,cell);};const addEnemy=(cell)=>{const enemyEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.ENEMY,{minTime:40,movementOptions:{speed:1,targets:new Set([ENTITY_TYPES.PLAYER]),damage:1,},});if(enemyEntity&&cell.block.isFluid)getInBoat(enemyEntity);};const ENTITY_INFO=({timeOfDay:0,});const spawnEntity=(entityType,cell)=>{switch(entityType){case ENTITY_TYPES.TREE:return addTree(cell);case ENTITY_TYPES.RABBIT:return addRabbit(cell);case ENTITY_TYPES.ENEMY:return addEnemy(cell);}};const hexToRgb=(hexColor)=>{let hex=hexColor.trim().slice(1);let r=parseInt(hex.substring(0,2),16);let g=parseInt(hex.substring(2,4),16);let b=parseInt(hex.substring(4,6),16);return{r,g,b};};const TRACK_TYPES={TRACK1:"TRACK1",TRACK2:"TRACK2",TRACK3:"TRACK3",TRACK4:"TRACK4",TRACK5:"TRACK5",TRACK6:"TRACK6",TRACK7:"TRACK7",TRACK8:"TRACK8",TRACK9:"TRACK9",TRACK11:"TRACK11",TRACK10:"TRACK10",TRACK12:"TRACK12",TRACK13:"TRACK13",TRACK14:"TRACK14",TRACK15:"TRACK15",TRACK16:"TRACK16",};const ENEMY_SPAWN={probability:0.00001,entityType:ENTITY_TYPES.ENEMY,spawnOnMove:true,increaseWithTime:true,};const WATER_SPAWNS=[{probability:0.0005,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const FOREST_SPAWNS=[{probability:0.01,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const SNOW_PROPS={biomeType:BIOME_TYPES.SNOW,spawnableEntities:[{probability:0.01,entityType:ENTITY_TYPES.TREE},ENEMY_SPAWN,],};const DESERT_PROPS={biomeType:BIOME_TYPES.DESERT,spawnableEntities:[{probability:0.001,entityType:ENTITY_TYPES.TREE},{...ENEMY_SPAWN,probability:0.00005,},],};const EMPTY_BLOCK=({layer:0,color:{r:-1,g:-1,b:-1},});const BLOCKS=({DEEP_WATER:{name:"DEEP_WATER",color:hexToRgb("#256299"),layer:0,isFluid:true,spawnableEntities:WATER_SPAWNS,trackType:TRACK_TYPES.TRACK5,},WATER:{name:"WATER",color:hexToRgb("#2375b4"),layer:0,isFluid:true,trackType:TRACK_TYPES.TRACK4,},LOW_GRASS:{name:"LOW_GRASS",color:hexToRgb("#457950"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK2,},MID_GRASS:{name:"MID_GRASS",color:hexToRgb("#2d673e"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK1,},HIGH_GRASS:{name:"HIGH_GRASS",color:hexToRgb("#2d673e"),layer:1,trackType:TRACK_TYPES.TRACK1,},DIRT:{name:"DIRT",color:hexToRgb("#3F573A"),layer:1,trackType:TRACK_TYPES.TRACK6,},ROCK:{name:"ROCK",color:hexToRgb("#CBC0BB"),layer:1,},BEACH_SAND:{name:"BEACH_SAND",color:hexToRgb("#ab976a"),layer:0,spawnableEntities:[ENEMY_SPAWN],trackType:TRACK_TYPES.TRACK3,},FROZEN_WATER:{name:"FROZEN_WATER",color:hexToRgb("#94F2F4"),layer:0,trackType:TRACK_TYPES.TRACK11,...SNOW_PROPS,},FROZEN_SEA_SHORE:{name:"FROZEN_SEA_SHORE",color:hexToRgb("#A0E6EC"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},SLUSH:{name:"SLUSH",color:hexToRgb("#D0ECEB"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},ICE:{name:"ICE",color:hexToRgb("#ECFFFD"),layer:0,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},HIGH_ICE:{name:"HIGH_ICE",color:hexToRgb("#ECFFFD"),layer:1,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},DUST:{name:"DUST",color:hexToRgb("#DAA98B"),layer:0,trackType:TRACK_TYPES.TRACK16,...DESERT_PROPS,},SAND:{name:"SAND",color:hexToRgb("#EC912E"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},DARK_SAND:{name:"DARK_SAND",color:hexToRgb("#CC7025"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},TERRACOTA:{name:"TERRACOTA",color:hexToRgb("#9F561A"),layer:0,trackType:TRACK_TYPES.TRACK15,...DESERT_PROPS,},HIGH_TERRACOTA:{name:"HIGH_TERRACOTA",color:hexToRgb("#9F561A"),layer:1,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},});const PLAYER_CONFIG={maxHealth:10,};const PLAYER_ENTITY=({id:"PLAYER_1",type:ENTITY_TYPES.PLAYER,cell:null,img:document.getElementById("player"),connectedEntities:{},selectedCellIndex:0,health:PLAYER_CONFIG.maxHealth,});const addRabbit=(cell)=>{const rabbitEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.RABBIT,{isGenerated:true,movementOptions:{speed:1,random:true},});if(cell.block.isFluid)getInBoat(rabbitEntity);};const addPropsToBlock=(block,props)=>({...block,...props});const BIOMES_RAW=({FOREST:{name:"FOREST",mapColor:BLOCKS.MID_GRASS.color,minValue:-1,minDistance:0,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.WATER,{max:-0.4}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:-0.2}),addPropsToBlock(BLOCKS.MID_GRASS,{max:0.4}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.5}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},OCEAN:{name:"OCEAN",mapColor:BLOCKS.WATER.color,minValue:-0.2,minDistance:75,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.DEEP_WATER,{max:-0.1}),addPropsToBlock(BLOCKS.WATER,{max:0.3}),addPropsToBlock(BLOCKS.BEACH_SAND,{max:0.5}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:0.7}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.8}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},SNOW:{name:"SNOW",mapColor:BLOCKS.ICE.color,minValue:0.2,minDistance:150,higherGroundBlock:BLOCKS.ICE,negativeJ:false,ranges:[addPropsToBlock(BLOCKS.FROZEN_WATER,{max:-0.2}),addPropsToBlock(BLOCKS.FROZEN_SEA_SHORE,{max:0}),addPropsToBlock(BLOCKS.SLUSH,{max:0.1}),addPropsToBlock(BLOCKS.HIGH_ICE,{max:1}),],},DESERT:{name:"DESERT",mapColor:BLOCKS.SAND.color,minValue:0,minDistance:150,higherGroundBlock:BLOCKS.TERRACOTA,negativeJ:true,ranges:[addPropsToBlock(BLOCKS.DUST,{max:-0.4}),addPropsToBlock(BLOCKS.SAND,{max:-0.2}),addPropsToBlock(BLOCKS.DARK_SAND,{max:0}),addPropsToBlock(BLOCKS.TERRACOTA,{max:0.2}),addPropsToBlock(BLOCKS.HIGH_TERRACOTA,{max:1}),],},});const BIOMES=Object.values(BIOMES_RAW).sort((a,b)=>b.minDistance-a.minDistance);const addTree=(cell)=>{const treeEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.TREE,{isGenerated:true});if(cell.block.isFluid)getInBoat(treeEntity);};const isCellInverted=({i,j})=>(i+j)%2!==0;const getAdjacentPos=({i,j},isInverted)=>{return{[KNOWN_POLYGONS.TRIANGLE]:isInverted?[{i:i+1,j},{i,j:j-1},{i,j:j+1},]:[{i:i-1,j},{i,j:j+1},{i,j:j-1},],[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j},{i,j:j+1},{i:i+1,j},{i,j:j-1},],[KNOWN_POLYGONS.HEXAGON]:j%2?[{i:i-1,j},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},]:[{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j},{i,j:j-1},{i:i-1,j:j-1},],};};const getAdjacentPosWithCorners=({i,j},isInverted)=>{return{...getAdjacentPos({i,j},isInverted),[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j:j-1},{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},],};};const createCellProps=(pos)=>{const isInverted=isCellInverted(pos);return{pos,isInverted,adjacentPos:getAdjacentPos(pos,isInverted),adjacentPosWithCorners:getAdjacentPosWithCorners(pos,isInverted),};};const createCell=(pos,block)=>{let cell=getCell(pos);if(!cell){cell=({});cell.entityType=null;if(block){cell.block=block;cell.layer=block.layer;cell.color=tweakColor(block.color);}}return{...createCellProps(pos),...cell};};const createEntitiesForCell=(cell,onMove=false)=>{if(!cell.block.spawnableEntities?.length)return;for(const sEntity of cell.block.spawnableEntities){const canSpawn=onMove?sEntity.spawnOnMove:!sEntity.spawnOnMove;if(!canSpawn)continue;let probability=sEntity.probability;if(sEntity.increaseWithTime)probability*=ENTITY_INFO.timeOfDay/2;if(Math.random()<probability){spawnEntity(sEntity.entityType,cell);return;}}};const getBiome=(pos)=>{switch(MENU_CONFIG.mapGeneration){case MAP_GENERATION.MIX:const biomeValue=getValue(pos.i,pos.j,PERLIN_VECTORS.BIOME);return BIOMES.find((b)=>biomeValue>=b.minValue);default:case MAP_GENERATION.DISTANCE:const distance=getPosDistance(INITIAL_POS,pos);return BIOMES.filter((b)=>(b.negativeJ===undefined||b.negativeJ===pos.j<0)&&(b.negativeI===undefined||b.negativeI===pos.i<0)).find((b)=>distance>=b.minDistance);}};const loadChunk=(initialPos)=>{const offsetPos=getChunkStart(initialPos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const biomeMap=({});let minesObj=(null);for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){const nI=i+offsetPos.i;for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){const nJ=j+offsetPos.j;const pos={i:nI,j:nJ};const biome=minesObj?MINE_BIOMES.MINES:getBiome(pos);biomeMap[biome.name]=(biomeMap[biome.name]||0)+1;const value=getValue(nI,nJ,PERLIN_VECTORS.BLOCK);const originalBlock=biome.ranges.find((r)=>value<=r.max);const isHighBlock=originalBlock.layer>0;const cellBlock=isHighBlock?biome.higherGroundBlock:originalBlock;const cell=createCell(pos,cellBlock);if(minesObj)cell.hasBomb=minesObj.isBomb({i,j});addCell(pos,cell);if(isHighBlock)cell.wall={block:originalBlock,color:tweakColor(originalBlock.color),};else createEntitiesForCell(cell);}}const biomeName=Object.entries(biomeMap).sort(([_,a],[__,b])=>b-a)[0][0];addBiomeToMap(offsetPos,BIOMES.find((b)=>b.name===biomeName));};const loadAndGetCell=(pos)=>{if(!getCell(pos))loadChunk(pos);return getCell(pos);};const getCenterCell=()=>{const{rows,columns}=getPolyInfo();const{iOffset,jOffset}=RENDER_INFO;const i=Math.floor(rows/2)+iOffset;const j=Math.floor(columns/2)+jOffset;return loadAndGetCell({i,j});};const getBorderCells=(baseCell)=>{const{rows,columns}=getPolyInfo();const halfR=Math.floor(rows/2);const halfC=Math.floor(columns/2);const{i,j}=baseCell.pos;const tI=i-halfR;const bI=i+halfR;const lJ=j-halfC;const rJ=j+halfC;const positions=([]);for(let index=lJ;index<=rJ;index++){positions.push({i:tI,j:index});positions.push({i:bI,j:index});}for(let index=tI;index<=bI;index++){positions.push({i:index,j:lJ});positions.push({i:index,j:rJ});}return positions.map(getCell);};const spawnEntities=(baseCell)=>{getBorderCells(baseCell).forEach((cell)=>{if(!!cell?.block&&!cell.wall&&!cell.entityType)createEntitiesForCell(cell,true);});};const destroyWall=(cell)=>{const onDestroy=cell.wall?.block?.onDestroy;if(cell.wall){cell.wall=null;}if(onDestroy)onDestroy(cell);};let BIOME_MAPS=([]);const resetBiomes=()=>(BIOME_MAPS=[]);const getPosBiomeOffset=({i,j})=>({i:i/GENERATION_CONFIG.chunkSize,j:j/GENERATION_CONFIG.chunkSize,});const addBiomeToMap=(pos,biome)=>{const{i,j}=getPosBiomeOffset(pos);if(!BIOME_MAPS[i])BIOME_MAPS[i]=[];if(BIOME_MAPS[i][j])return;BIOME_MAPS[i][j]=biome;};const getBiomeFromMap=(pos)=>{pos=getChunkStart(pos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const{i,j}=getPosBiomeOffset(pos);return BIOME_MAPS[i]?.[j];};const getBiomeMap=()=>BIOME_MAPS;const createMinesObj=()=>{const minefield=([]);const MINES_CONFIG={bombsNum:Math.round(GENERATION_CONFIG.chunkSize**2/4),};const createField=()=>{for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){minefield[i]=[];for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){minefield[i][j]=false;}}};const getIndexForBomb=()=>{const limit=GENERATION_CONFIG.chunkSize-2;return Math.floor(Math.random()*limit)+1;};const addBomb=()=>{const row=getIndexForBomb();const column=getIndexForBomb();if(minefield[row][column])return false;minefield[row][column]=true;return true;};const addBombs=()=>{for(let i=0;i<MINES_CONFIG.bombsNum;i++){if(!addBomb())i--;}};createField();addBombs();return{isBomb:(pos)=>minefield[pos.i][pos.j],};};const MINE_BLOCKS=({MINES_LOW:{name:"MINES_LOW",color:hexToRgb("#d3d3d3"),layer:0,indestructible:true,isFluid:false,},MINES_HIGH:{name:"MINES_HIGH",color:hexToRgb("#d3d3d3"),layer:1,isFluid:false,onDestroy:(cell)=>{const aCells=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);const isNextToBomb=!!aCells.find((c)=>c.hasBomb);if(isNextToBomb)return;cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell).filter((c)=>c.wall?.block?.name==="MINES_HIGH"&&!c.hasBomb).forEach((c)=>{const onDestroy=c.wall.block.onDestroy;c.wall=null;onDestroy(c);});},},});const MINE_BIOMES=({MINES:{name:"MINES",mapColor:MINE_BLOCKS.MINES_LOW.color,minValue:-1,minDistance:0,higherGroundBlock:MINE_BLOCKS.MINES_LOW,ranges:[addPropsToBlock(MINE_BLOCKS.MINES_HIGH,{max:1})],},});const ENTITIES=(new Set());const addEntity=(entity)=>ENTITIES.add(entity);const moveEntityToCell=(entity,cell)=>{if(!cell)return;const previousType=entity.cell?.entityType||cell.entityType;if(entity.cell)entity.cell.entityType=null;entity.cell=cell;entity.cell.entityType=previousType||entity.type;updateEntityPoint(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach((e)=>moveEntityToCell(e,cell));};const removeEntity=(entity)=>{entity.cell.entityType=null;removeEntityImage(entity);ENTITIES.delete(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach(removeEntity);};const getEntitiesFromCell=(cell)=>{const entities=([]);ENTITIES.forEach((entity)=>{if(entity.cell===cell)entities.push(entity);});return entities;};const createEntity=(cell,id,type,entityParams={})=>{if(entityParams.minTime&&ENTITY_INFO.timeOfDay<entityParams.minTime)return;const entity=({id:`${type}_${id}`,type,connectedEntities:{},currentImgType:cell.block?.biomeType,health:1,...entityParams,});createEntityImage(entity);moveEntityToCell(entity,cell);addEntity(entity);return entity;};const setEntitiesSize=()=>ENTITIES.forEach((e)=>setEntitySize(e));const removeGeneratedEntities=()=>ENTITIES.forEach((e)=>e.isGenerated&&removeEntity(e));const updateEntities=()=>ENTITIES.forEach((e)=>updateEntityPoint(e));const cellIsBlocked=(cell,entity)=>!MENU_CONFIG.debugMode&&(!cell||!cell.block||!!cell.wall||!!cell.entityType||(entity.connectedEntities[ENTITY_TYPES.BOAT]?!cell.block.isFluid:cell.block.isFluid));const getSelectedCell=(entity)=>getCell(getPosByIndex(entity.cell,entity.selectedCellIndex));const updateEntityDirection=(entity,direction)=>{updateEntityImage(entity,direction);Object.values(entity.connectedEntities).forEach((e)=>{updateEntityImage(e,MOVEMENT.RIGHT);});};const makeEntityUse=(entity)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.USING);setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},250);};const updateEntityHealth=(entity)=>{if(entity===PLAYER_ENTITY){if(entity.health>PLAYER_CONFIG.maxHealth)entity.health=PLAYER_CONFIG.maxHealth;updatePlayerHearts();}else if(entity.health<=0)removeEntity(entity);};const giveItemToEntity=(entity,item)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.WINNING);const callback=displayWinAnimation(entity,item.imgPos);if(item.health){entity.health+=item.health;updateEntityHealth(entity);}setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);callback();},1000);};const hurtEntity=(entity,damage)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.LOSING);entity.health-=damage;updateEntityHealth(entity);if(entity.health>0)setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},1000);};const makeEntityRun=(entity,direction)=>{const connectedEntities=Object.values(entity.connectedEntities);if(!connectedEntities.length){updateEntityImage(entity,direction,IMG_MAP_TYPES.RUNNING);return;}updateEntityImage(entity,direction);connectedEntities.forEach((e)=>{updateEntityImage(e,direction);cutEntityImage(e,direction);});};const ENTITY_ACTIONS_CONFIG={delayToBurn:1000,};const getClosestTarget=(entity)=>{let minDistance=Infinity;let selectedTarget=(null);ENTITIES.forEach((targetEntity)=>{entity.movementOptions.targets.forEach((t)=>{if(targetEntity.cell&&targetEntity.type===t){const distance=getPosDistance(entity.cell.pos,targetEntity.cell.pos);if(distance<minDistance){selectedTarget=targetEntity;minDistance=distance;}}});});return selectedTarget;};const getClosestCell=(entity,cell,targetCell)=>{let minDistance=Infinity;let selectedCell=(null);let selectedIndex=0;const aPos=cell.adjacentPos[RENDER_INFO.currentPoly];for(let index=0;index<aPos.length;index++){const pos=aPos[index];const aCell=getCell(pos);if(cellIsBlocked(aCell,entity)&&aCell.entityType!==targetCell.entityType)continue;const distance=getPosDistance(aCell.pos,targetCell.pos);if(distance<minDistance){selectedCell=aCell;selectedIndex=index;minDistance=distance;}}return{cell:selectedCell,index:selectedIndex};};const moveEntities=(baseCell)=>{const{indexToMove}=getMovementMaps(baseCell);ENTITIES.forEach((e)=>{if(!e.cell||e.deleted)return;moveEntity(e,indexToMove);updateEntityOpacity(e);});};const moveEntity=(e,indexToMove)=>{if(!e.movementOptions?.speed)return;const{targets,speed,random,damage}=e.movementOptions;let nextCell=e.cell;let nextIndex=0;let target=(null);for(let index=0;index<speed;index++){if(targets){target=getClosestTarget(e);if(!target)return;const nextCellInfo=getClosestCell(e,nextCell,target.cell);nextCell=nextCellInfo.cell;nextIndex=nextCellInfo.index;if(!nextCell)return;}else if(random){nextIndex=getRandomInt(RENDER_INFO.currentPoly);const aPos=nextCell.adjacentPos[RENDER_INFO.currentPoly];nextCell=getCell(aPos[nextIndex]);for(let i=0;i<aPos.length;i++){if(!cellIsBlocked(nextCell,e))break;nextIndex=getMod(nextIndex+1,RENDER_INFO.currentPoly);nextCell=getCell(aPos[nextIndex]);}}}if(target&&nextCell.entityType===target.type&&damage){removeEntity(e);hurtEntity(target,damage);}if(cellIsBlocked(nextCell,e))return;nextIndex=getMod(nextIndex,RENDER_INFO.currentPoly);updateEntityImage(e,indexToMove[nextIndex]);moveEntityToCell(e,nextCell);};const getMovementMaps=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>{currentPoly=currentPoly??RENDER_INFO.currentPoly;hasInverted=hasInverted??getPolyInfo().hasInverted;let topI=rotationTurns??RENDER_INFO.rotationTurns;let bottomI=topI+Math.floor(currentPoly/2);let topLeftI=topI+currentPoly-1;let topRightI=topI+1;let bottomLeftI=bottomI+1;let bottomRightI=bottomI-1;if(hasInverted){topLeftI=bottomLeftI=topI+(baseCell.isInverted?1:2);topRightI=bottomRightI=topI+(baseCell.isInverted?2:1);bottomI=baseCell.isInverted?topI:undefined;topI=baseCell.isInverted?undefined:topI;}return{moveToIndex:{[MOVEMENT.UP]:topI,[MOVEMENT.DOWN]:bottomI,[MOVEMENT.LEFT]:useDiagonal?bottomLeftI:topLeftI,[MOVEMENT.RIGHT]:useDiagonal?bottomRightI:topRightI,},indexToMove:{[topI]:MOVEMENT.UP,[bottomI]:MOVEMENT.DOWN,[bottomLeftI]:MOVEMENT.LEFT,[topLeftI]:MOVEMENT.LEFT,[bottomRightI]:MOVEMENT.RIGHT,[topRightI]:MOVEMENT.RIGHT,},};};const getMovementMap=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>getMovementMaps(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted).moveToIndex;const killEntitiesByTimeOfDay=()=>{if(MENU_CONFIG.rain)return;const entitiesToKill=([]);ENTITIES.forEach((e)=>{if(!e.cell||!e.minTime||e.deleted||e.minTime<=ENTITY_INFO.timeOfDay)return;const fireEntity=createEntity(e.cell,e.id,ENTITY_TYPES.FIRE,{zIndex:e.zIndex+1,});e.connectedEntities[ENTITY_TYPES.FIRE]=fireEntity;e.deleted=true;entitiesToKill.push(e);});setTimeout(()=>{entitiesToKill.forEach(removeEntity);},ENTITY_ACTIONS_CONFIG.delayToBurn);};const BOAT_ENTITIES=({});const getInBoat=(entity)=>{if(!BOAT_ENTITIES[entity.id])addBoat(entity.cell,entity);BOAT_ENTITIES[entity.id].isConnected=true;entity.connectedEntities[ENTITY_TYPES.BOAT]=BOAT_ENTITIES[entity.id];};const getOutBoat=(entity)=>{if(entity.connectedEntities[ENTITY_TYPES.BOAT]){delete entity.connectedEntities[ENTITY_TYPES.BOAT];BOAT_ENTITIES[entity.id].isConnected=false;moveEntityToCell(BOAT_ENTITIES[entity.id],entity.cell);}};const addBoat=(cell,entity)=>{let boatEntity=BOAT_ENTITIES[entity.id];if(!boatEntity)boatEntity=BOAT_ENTITIES[entity.id]=createEntity(cell,entity.id,ENTITY_TYPES.BOAT,{zIndex:1,movementsToCut:[MOVEMENT.UP,MOVEMENT.DOWN],currentDirection:MOVEMENT.RIGHT,});moveEntityToCell(boatEntity,cell);};const addEnemy=(cell)=>{const enemyEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.ENEMY,{minTime:40,movementOptions:{speed:1,targets:new Set([ENTITY_TYPES.PLAYER]),damage:1,},});if(enemyEntity&&cell.block.isFluid)getInBoat(enemyEntity);};const spawnEntity=(entityType,cell)=>{switch(entityType){case ENTITY_TYPES.TREE:return addTree(cell);case ENTITY_TYPES.RABBIT:return addRabbit(cell);case ENTITY_TYPES.ENEMY:return addEnemy(cell);}};const PLAYER_CONFIG={maxHealth:10,};const PLAYER_ENTITY=({id:"PLAYER_1",type:ENTITY_TYPES.PLAYER,cell:null,img:document.getElementById("player"),connectedEntities:{},selectedCellIndex:0,health:PLAYER_CONFIG.maxHealth,});const addRabbit=(cell)=>{const rabbitEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.RABBIT,{isGenerated:true,movementOptions:{speed:1,random:true},});if(cell.block.isFluid)getInBoat(rabbitEntity);};const addTree=(cell)=>{const treeEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.TREE,{isGenerated:true});if(cell.block.isFluid)getInBoat(treeEntity);};const CUT_MOVEMENTS_MAP={[MOVEMENT.DOWN]:"marginTop",[MOVEMENT.LEFT]:"marginLeft",[MOVEMENT.RIGHT]:"marginRight",[MOVEMENT.UP]:"marginTop",};const container=document.getElementById("entities");const createImageElement=()=>{const img=document.createElement("div");img.className="image";return img;};const createEntityImage=(entity)=>{const img=createImageElement();img.id=entity.id;img.style.zIndex=`${entity.zIndex ||2}`;container.appendChild(img);entity.img=img;setEntitySize(entity);};const displayWinAnimation=(entity,itemPos)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);const img=createImageElement();img.classList.add("won-item");img.style.marginTop=`-${ySide}px`;setImagePos(img,itemPos);container.appendChild(img);setEntityImageSize(img,ySide/2);setImagePoint(img,point,false,ySide/2);return()=>{container.removeChild(img);};};const removeEntityImage=(entity)=>{if(entity.img)container.removeChild(entity.img);entity.img=null;};const updateEntityPoint=(entity,parentPoint)=>{if(!parentPoint&&entity.isConnected)return;const{hasInverted,canvasHeight,canvasWidth}=getPolyInfo();const point=parentPoint||calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);if(isPointOutside(point,canvasHeight,canvasWidth)){if(entity.img)removeEntityImage(entity);}else if(!entity.img){createEntityImage(entity);}if(entity.img)setImagePoint(entity.img,point);verifyEntityHeight(entity);Object.values(entity.connectedEntities).forEach((e)=>updateEntityPoint(e,point));};const updateEntityOpacity=(entity)=>{if(!entity?.img||entity?.deleted)return;entity.img.style.setProperty("--entity-opacity",`${entity.cell.modifier ||1}`);};const getEntitySize=(ySide)=>Math.round((ySide||getPolyInfo().ySide)*2.5);const setImagePos=(img,pos)=>{img.style.setProperty("--entity-position-i",`${pos.i}`);img.style.setProperty("--entity-position-j",`${pos.j}`);};const setEntityImageSize=(img,ySide)=>{if(!img)return;const size=getEntitySize(ySide);img.style.setProperty("--entity-size",`${size}px`);};const setEntitySize=(entity,ySide)=>{if(!entity?.img)return;setEntityImageSize(entity.img,ySide);setEntityImageInfo(entity);};const setEntityImageInfo=(entity)=>{const imgInfo=getEntityImageInfo(entity);if(!imgInfo.src){entity.img.style.removeProperty("--entity-img");entity.img.classList.remove("dont-use-spritesheet");}if(imgInfo.pos){setImagePos(entity.img,imgInfo.pos);}else if(imgInfo.posFn){const pos=imgInfo.posFn(!!entity.leftFootWalk);entity.leftFootWalk=!entity.leftFootWalk;setImagePos(entity.img,pos);}else if(imgInfo.src){entity.img.style.setProperty("--entity-img",`url(${imgInfo.src})`);entity.img.classList.add("dont-use-spritesheet");setImagePos(entity.img,{i:0,j:0});}};const setImagePoint=(img,point,shouldCenter,ySide)=>{if(!point)return;const entitySize=getEntitySize(ySide);img.style.setProperty("--entity-top",`${point.y -entitySize /(shouldCenter ?2 :1.25)}px`);img.style.setProperty("--entity-left",`${point.x -entitySize /2}px`);};const verifyEntityHeight=(entity)=>{if(!entity?.cell||!entity?.img)return;const{hasInverted}=getPolyInfo();const downI=hasInverted&&entity.cell.isInverted?RENDER_INFO.rotationTurns:RENDER_INFO.rotationTurns+Math.floor(RENDER_INFO.currentPoly/2);const downPos=getPosByIndex(entity.cell,downI);const downCell=getCell(downPos);if(!downCell)return;entity.img.classList.remove("not-inverted-both-walls");entity.img.classList.remove("not-inverted-right-wall");entity.img.classList.remove("not-inverted-left-wall");entity.img.classList.remove("behind-wall");if(hasInverted&&!entity.cell.isInverted){const rightCell=downCell;const leftI=RENDER_INFO.rotationTurns+RENDER_INFO.currentPoly-1;const leftPos=getPosByIndex(entity.cell,leftI);const leftCell=getCell(leftPos);if(rightCell.wall&&leftCell.wall){entity.img.classList.add("not-inverted-both-walls");}else if(rightCell.wall){entity.img.classList.add("not-inverted-right-wall");}else if(leftCell.wall){entity.img.classList.add("not-inverted-left-wall");}}else if(downCell.wall){entity.img.classList.add("behind-wall");}if(Object.values(entity.connectedEntities).length)entity.img.classList.add("behind-wall");};const getEntityImageInfo=(entity)=>{const typeMap=ENTITY_IMAGES_MAP[entity.type];const mapType=typeMap[entity.currentImgType]||typeMap[IMG_MAP_TYPES.DEFAULT];return(mapType[entity.currentDirection||MOVEMENT.DOWN]||mapType[MOVEMENT.DOWN]);};const updateEntityImage=(entity,direction,imgMapType)=>{if(!entity?.img)return;entity.currentImgType=imgMapType;entity.currentDirection=direction;setEntityImageInfo(entity);entity.img.style.marginTop=null;entity.img.style.marginLeft=null;entity.img.style.marginRight=null;};const cutEntityImage=(entity,direction)=>{if(entity.movementsToCut?.length){if(entity.movementsToCut.includes(direction)){const{ySide}=getPolyInfo();entity.img.style[CUT_MOVEMENTS_MAP[direction]]=`${ySide}px`;}}};const playerHealthContainer=document.getElementById("health-container");const updatePlayerHearts=()=>{playerHealthContainer.innerHTML="";let curretnHealth=PLAYER_ENTITY.health;for(let i=0;i<PLAYER_CONFIG.maxHealth;i++){const heartImg=createImageElement();if(curretnHealth){setImagePos(heartImg,{i:2,j:3});heartImg.classList.add("filled");curretnHealth--;}else{setImagePos(heartImg,{i:2,j:2});}playerHealthContainer.appendChild(heartImg);}};updatePlayerHearts();const ENTITIES=(new Set());const addEntity=(entity)=>ENTITIES.add(entity);const moveEntityToCell=(entity,cell)=>{if(!cell)return;const previousType=entity.cell?.entityType||cell.entityType;if(entity.cell)entity.cell.entityType=null;entity.cell=cell;entity.cell.entityType=previousType||entity.type;updateEntityPoint(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach((e)=>moveEntityToCell(e,cell));};const removeEntity=(entity)=>{entity.cell.entityType=null;removeEntityImage(entity);ENTITIES.delete(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach(removeEntity);};const getEntitiesFromCell=(cell)=>{const entities=([]);ENTITIES.forEach((entity)=>{if(entity.cell===cell)entities.push(entity);});return entities;};const createEntity=(cell,id,type,entityParams={})=>{if(entityParams.minTime&&ENTITY_INFO.timeOfDay<entityParams.minTime)return;const entity=({id:`${type}_${id}`,type,connectedEntities:{},currentImgType:cell.block?.biomeType,health:1,...entityParams,});createEntityImage(entity);moveEntityToCell(entity,cell);addEntity(entity);return entity;};const setEntitiesSize=()=>ENTITIES.forEach((e)=>setEntitySize(e));const removeGeneratedEntities=()=>ENTITIES.forEach((e)=>e.isGenerated&&removeEntity(e));const updateEntities=()=>ENTITIES.forEach((e)=>updateEntityPoint(e));const cellIsBlocked=(cell,entity)=>!MENU_CONFIG.debugMode&&(!cell||!cell.block||!!cell.wall||!!cell.entityType||(entity.connectedEntities[ENTITY_TYPES.BOAT]?!cell.block.isFluid:cell.block.isFluid));const getSelectedCell=(entity)=>getCell(getPosByIndex(entity.cell,entity.selectedCellIndex));const updateEntityDirection=(entity,direction)=>{updateEntityImage(entity,direction);Object.values(entity.connectedEntities).forEach((e)=>{updateEntityImage(e,MOVEMENT.RIGHT);});};const makeEntityUse=(entity)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.USING);setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},250);};const updateEntityHealth=(entity)=>{if(entity===PLAYER_ENTITY){if(entity.health>PLAYER_CONFIG.maxHealth)entity.health=PLAYER_CONFIG.maxHealth;updatePlayerHearts();}else if(entity.health<=0)removeEntity(entity);};const giveItemToEntity=(entity,item)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.WINNING);const callback=displayWinAnimation(entity,item.imgPos);if(item.health){entity.health+=item.health;updateEntityHealth(entity);}setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);callback();},1000);};const hurtEntity=(entity,damage)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.LOSING);entity.health-=damage;updateEntityHealth(entity);if(entity.health>0)setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},1000);};const makeEntityRun=(entity,direction)=>{const connectedEntities=Object.values(entity.connectedEntities);if(!connectedEntities.length){updateEntityImage(entity,direction,IMG_MAP_TYPES.RUNNING);return;}updateEntityImage(entity,direction);connectedEntities.forEach((e)=>{updateEntityImage(e,direction);cutEntityImage(e,direction);});};const GENERATION_CONFIG={chunkSize:50,};const getRange=(n,range)=>Math.floor(n/range)*range;const getChunkStart=(pos,height,width)=>({i:getRange(pos.i,height),j:getRange(pos.j,width),});const hexToRgb=(hexColor)=>{let hex=hexColor.trim().slice(1);let r=parseInt(hex.substring(0,2),16);let g=parseInt(hex.substring(2,4),16);let b=parseInt(hex.substring(4,6),16);return{r,g,b};};const TRACK_TYPES={TRACK1:"TRACK1",TRACK2:"TRACK2",TRACK3:"TRACK3",TRACK4:"TRACK4",TRACK5:"TRACK5",TRACK6:"TRACK6",TRACK7:"TRACK7",TRACK8:"TRACK8",TRACK9:"TRACK9",TRACK11:"TRACK11",TRACK10:"TRACK10",TRACK12:"TRACK12",TRACK13:"TRACK13",TRACK14:"TRACK14",TRACK15:"TRACK15",TRACK16:"TRACK16",};const ENEMY_SPAWN={probability:0.00001,entityType:ENTITY_TYPES.ENEMY,spawnOnMove:true,increaseWithTime:true,};const WATER_SPAWNS=[{probability:0.0005,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const FOREST_SPAWNS=[{probability:0.01,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const SNOW_PROPS={biomeType:BIOME_TYPES.SNOW,spawnableEntities:[{probability:0.01,entityType:ENTITY_TYPES.TREE},ENEMY_SPAWN,],};const DESERT_PROPS={biomeType:BIOME_TYPES.DESERT,spawnableEntities:[{probability:0.001,entityType:ENTITY_TYPES.TREE},{...ENEMY_SPAWN,probability:0.00005,},],};const EMPTY_BLOCK=({layer:0,color:{r:-1,g:-1,b:-1},});const BLOCKS=({DEEP_WATER:{name:"DEEP_WATER",color:hexToRgb("#256299"),layer:0,isFluid:true,spawnableEntities:WATER_SPAWNS,trackType:TRACK_TYPES.TRACK5,},WATER:{name:"WATER",color:hexToRgb("#2375b4"),layer:0,isFluid:true,trackType:TRACK_TYPES.TRACK4,},LOW_GRASS:{name:"LOW_GRASS",color:hexToRgb("#457950"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK2,},MID_GRASS:{name:"MID_GRASS",color:hexToRgb("#2d673e"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK1,},HIGH_GRASS:{name:"HIGH_GRASS",color:hexToRgb("#2d673e"),layer:1,trackType:TRACK_TYPES.TRACK1,},DIRT:{name:"DIRT",color:hexToRgb("#3F573A"),layer:1,trackType:TRACK_TYPES.TRACK6,},ROCK:{name:"ROCK",color:hexToRgb("#CBC0BB"),layer:1,},BEACH_SAND:{name:"BEACH_SAND",color:hexToRgb("#ab976a"),layer:0,spawnableEntities:[ENEMY_SPAWN],trackType:TRACK_TYPES.TRACK3,},FROZEN_WATER:{name:"FROZEN_WATER",color:hexToRgb("#94F2F4"),layer:0,trackType:TRACK_TYPES.TRACK11,...SNOW_PROPS,},FROZEN_SEA_SHORE:{name:"FROZEN_SEA_SHORE",color:hexToRgb("#A0E6EC"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},SLUSH:{name:"SLUSH",color:hexToRgb("#D0ECEB"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},ICE:{name:"ICE",color:hexToRgb("#ECFFFD"),layer:0,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},HIGH_ICE:{name:"HIGH_ICE",color:hexToRgb("#ECFFFD"),layer:1,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},DUST:{name:"DUST",color:hexToRgb("#DAA98B"),layer:0,trackType:TRACK_TYPES.TRACK16,...DESERT_PROPS,},SAND:{name:"SAND",color:hexToRgb("#EC912E"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},DARK_SAND:{name:"DARK_SAND",color:hexToRgb("#CC7025"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},TERRACOTA:{name:"TERRACOTA",color:hexToRgb("#9F561A"),layer:0,trackType:TRACK_TYPES.TRACK15,...DESERT_PROPS,},HIGH_TERRACOTA:{name:"HIGH_TERRACOTA",color:hexToRgb("#9F561A"),layer:1,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},});const ENTITIES=(new Set());const addEntity=(entity)=>ENTITIES.add(entity);const moveEntityToCell=(entity,cell)=>{if(!cell)return;const previousType=entity.cell?.entityType||cell.entityType;if(entity.cell)entity.cell.entityType=null;entity.cell=cell;entity.cell.entityType=previousType||entity.type;updateEntityPoint(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach((e)=>moveEntityToCell(e,cell));};const removeEntity=(entity)=>{entity.cell.entityType=null;removeEntityImage(entity);ENTITIES.delete(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach(removeEntity);};const getEntitiesFromCell=(cell)=>{const entities=([]);ENTITIES.forEach((entity)=>{if(entity.cell===cell)entities.push(entity);});return entities;};const createEntity=(cell,id,type,entityParams={})=>{if(entityParams.minTime&&ENTITY_INFO.timeOfDay<entityParams.minTime)return;const entity=({id:`${type}_${id}`,type,connectedEntities:{},currentImgType:cell.block?.biomeType,health:1,...entityParams,});createEntityImage(entity);moveEntityToCell(entity,cell);addEntity(entity);return entity;};const setEntitiesSize=()=>ENTITIES.forEach((e)=>setEntitySize(e));const removeGeneratedEntities=()=>ENTITIES.forEach((e)=>e.isGenerated&&removeEntity(e));const updateEntities=()=>ENTITIES.forEach((e)=>updateEntityPoint(e));const cellIsBlocked=(cell,entity)=>!MENU_CONFIG.debugMode&&(!cell||!cell.block||!!cell.wall||!!cell.entityType||(entity.connectedEntities[ENTITY_TYPES.BOAT]?!cell.block.isFluid:cell.block.isFluid));const getSelectedCell=(entity)=>getCell(getPosByIndex(entity.cell,entity.selectedCellIndex));const updateEntityDirection=(entity,direction)=>{updateEntityImage(entity,direction);Object.values(entity.connectedEntities).forEach((e)=>{updateEntityImage(e,MOVEMENT.RIGHT);});};const makeEntityUse=(entity)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.USING);setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},250);};const updateEntityHealth=(entity)=>{if(entity===PLAYER_ENTITY){if(entity.health>PLAYER_CONFIG.maxHealth)entity.health=PLAYER_CONFIG.maxHealth;updatePlayerHearts();}else if(entity.health<=0)removeEntity(entity);};const giveItemToEntity=(entity,item)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.WINNING);const callback=displayWinAnimation(entity,item.imgPos);if(item.health){entity.health+=item.health;updateEntityHealth(entity);}setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);callback();},1000);};const hurtEntity=(entity,damage)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.LOSING);entity.health-=damage;updateEntityHealth(entity);if(entity.health>0)setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},1000);};const makeEntityRun=(entity,direction)=>{const connectedEntities=Object.values(entity.connectedEntities);if(!connectedEntities.length){updateEntityImage(entity,direction,IMG_MAP_TYPES.RUNNING);return;}updateEntityImage(entity,direction);connectedEntities.forEach((e)=>{updateEntityImage(e,direction);cutEntityImage(e,direction);});};const addPropsToBlock=(block,props)=>({...block,...props});const BIOMES_RAW=({FOREST:{name:"FOREST",mapColor:BLOCKS.MID_GRASS.color,minValue:-1,minDistance:0,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.WATER,{max:-0.4}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:-0.2}),addPropsToBlock(BLOCKS.MID_GRASS,{max:0.4}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.5}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},OCEAN:{name:"OCEAN",mapColor:BLOCKS.WATER.color,minValue:-0.2,minDistance:75,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.DEEP_WATER,{max:-0.1}),addPropsToBlock(BLOCKS.WATER,{max:0.3}),addPropsToBlock(BLOCKS.BEACH_SAND,{max:0.5}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:0.7}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.8}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},SNOW:{name:"SNOW",mapColor:BLOCKS.ICE.color,minValue:0.2,minDistance:150,higherGroundBlock:BLOCKS.ICE,negativeJ:false,ranges:[addPropsToBlock(BLOCKS.FROZEN_WATER,{max:-0.2}),addPropsToBlock(BLOCKS.FROZEN_SEA_SHORE,{max:0}),addPropsToBlock(BLOCKS.SLUSH,{max:0.1}),addPropsToBlock(BLOCKS.HIGH_ICE,{max:1}),],},DESERT:{name:"DESERT",mapColor:BLOCKS.SAND.color,minValue:0,minDistance:150,higherGroundBlock:BLOCKS.TERRACOTA,negativeJ:true,ranges:[addPropsToBlock(BLOCKS.DUST,{max:-0.4}),addPropsToBlock(BLOCKS.SAND,{max:-0.2}),addPropsToBlock(BLOCKS.DARK_SAND,{max:0}),addPropsToBlock(BLOCKS.TERRACOTA,{max:0.2}),addPropsToBlock(BLOCKS.HIGH_TERRACOTA,{max:1}),],},});const BIOMES=Object.values(BIOMES_RAW).sort((a,b)=>b.minDistance-a.minDistance);let BIOME_MAPS=([]);const resetBiomes=()=>(BIOME_MAPS=[]);const getPosBiomeOffset=({i,j})=>({i:i/GENERATION_CONFIG.chunkSize,j:j/GENERATION_CONFIG.chunkSize,});const addBiomeToMap=(pos,biome)=>{const{i,j}=getPosBiomeOffset(pos);if(!BIOME_MAPS[i])BIOME_MAPS[i]=[];if(BIOME_MAPS[i][j])return;BIOME_MAPS[i][j]=biome;};const getBiomeFromMap=(pos)=>{pos=getChunkStart(pos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const{i,j}=getPosBiomeOffset(pos);return BIOME_MAPS[i]?.[j];};const getBiomeMap=()=>BIOME_MAPS;const CUT_MOVEMENTS_MAP={[MOVEMENT.DOWN]:"marginTop",[MOVEMENT.LEFT]:"marginLeft",[MOVEMENT.RIGHT]:"marginRight",[MOVEMENT.UP]:"marginTop",};const container=document.getElementById("entities");const createImageElement=()=>{const img=document.createElement("div");img.className="image";return img;};const createEntityImage=(entity)=>{const img=createImageElement();img.id=entity.id;img.style.zIndex=`${entity.zIndex ||2}`;container.appendChild(img);entity.img=img;setEntitySize(entity);};const displayWinAnimation=(entity,itemPos)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);const img=createImageElement();img.classList.add("won-item");img.style.marginTop=`-${ySide}px`;setImagePos(img,itemPos);container.appendChild(img);setEntityImageSize(img,ySide/2);setImagePoint(img,point,false,ySide/2);return()=>{container.removeChild(img);};};const removeEntityImage=(entity)=>{if(entity.img)container.removeChild(entity.img);entity.img=null;};const updateEntityPoint=(entity,parentPoint)=>{if(!parentPoint&&entity.isConnected)return;const{hasInverted,canvasHeight,canvasWidth}=getPolyInfo();const point=parentPoint||calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);if(isPointOutside(point,canvasHeight,canvasWidth)){if(entity.img)removeEntityImage(entity);}else if(!entity.img){createEntityImage(entity);}if(entity.img)setImagePoint(entity.img,point);verifyEntityHeight(entity);Object.values(entity.connectedEntities).forEach((e)=>updateEntityPoint(e,point));};const updateEntityOpacity=(entity)=>{if(!entity?.img||entity?.deleted)return;entity.img.style.setProperty("--entity-opacity",`${entity.cell.modifier ||1}`);};const getEntitySize=(ySide)=>Math.round((ySide||getPolyInfo().ySide)*2.5);const setImagePos=(img,pos)=>{img.style.setProperty("--entity-position-i",`${pos.i}`);img.style.setProperty("--entity-position-j",`${pos.j}`);};const setEntityImageSize=(img,ySide)=>{if(!img)return;const size=getEntitySize(ySide);img.style.setProperty("--entity-size",`${size}px`);};const setEntitySize=(entity,ySide)=>{if(!entity?.img)return;setEntityImageSize(entity.img,ySide);setEntityImageInfo(entity);};const setEntityImageInfo=(entity)=>{const imgInfo=getEntityImageInfo(entity);if(!imgInfo.src){entity.img.style.removeProperty("--entity-img");entity.img.classList.remove("dont-use-spritesheet");}if(imgInfo.pos){setImagePos(entity.img,imgInfo.pos);}else if(imgInfo.posFn){const pos=imgInfo.posFn(!!entity.leftFootWalk);entity.leftFootWalk=!entity.leftFootWalk;setImagePos(entity.img,pos);}else if(imgInfo.src){entity.img.style.setProperty("--entity-img",`url(${imgInfo.src})`);entity.img.classList.add("dont-use-spritesheet");setImagePos(entity.img,{i:0,j:0});}};const setImagePoint=(img,point,shouldCenter,ySide)=>{if(!point)return;const entitySize=getEntitySize(ySide);img.style.setProperty("--entity-top",`${point.y -entitySize /(shouldCenter ?2 :1.25)}px`);img.style.setProperty("--entity-left",`${point.x -entitySize /2}px`);};const verifyEntityHeight=(entity)=>{if(!entity?.cell||!entity?.img)return;const{hasInverted}=getPolyInfo();const downI=hasInverted&&entity.cell.isInverted?RENDER_INFO.rotationTurns:RENDER_INFO.rotationTurns+Math.floor(RENDER_INFO.currentPoly/2);const downPos=getPosByIndex(entity.cell,downI);const downCell=getCell(downPos);if(!downCell)return;entity.img.classList.remove("not-inverted-both-walls");entity.img.classList.remove("not-inverted-right-wall");entity.img.classList.remove("not-inverted-left-wall");entity.img.classList.remove("behind-wall");if(hasInverted&&!entity.cell.isInverted){const rightCell=downCell;const leftI=RENDER_INFO.rotationTurns+RENDER_INFO.currentPoly-1;const leftPos=getPosByIndex(entity.cell,leftI);const leftCell=getCell(leftPos);if(rightCell.wall&&leftCell.wall){entity.img.classList.add("not-inverted-both-walls");}else if(rightCell.wall){entity.img.classList.add("not-inverted-right-wall");}else if(leftCell.wall){entity.img.classList.add("not-inverted-left-wall");}}else if(downCell.wall){entity.img.classList.add("behind-wall");}if(Object.values(entity.connectedEntities).length)entity.img.classList.add("behind-wall");};const getEntityImageInfo=(entity)=>{const typeMap=ENTITY_IMAGES_MAP[entity.type];const mapType=typeMap[entity.currentImgType]||typeMap[IMG_MAP_TYPES.DEFAULT];return(mapType[entity.currentDirection||MOVEMENT.DOWN]||mapType[MOVEMENT.DOWN]);};const updateEntityImage=(entity,direction,imgMapType)=>{if(!entity?.img)return;entity.currentImgType=imgMapType;entity.currentDirection=direction;setEntityImageInfo(entity);entity.img.style.marginTop=null;entity.img.style.marginLeft=null;entity.img.style.marginRight=null;};const cutEntityImage=(entity,direction)=>{if(entity.movementsToCut?.length){if(entity.movementsToCut.includes(direction)){const{ySide}=getPolyInfo();entity.img.style[CUT_MOVEMENTS_MAP[direction]]=`${ySide}px`;}}};const playerHealthContainer=document.getElementById("health-container");const updatePlayerHearts=()=>{playerHealthContainer.innerHTML="";let curretnHealth=PLAYER_ENTITY.health;for(let i=0;i<PLAYER_CONFIG.maxHealth;i++){const heartImg=createImageElement();if(curretnHealth){setImagePos(heartImg,{i:2,j:3});heartImg.classList.add("filled");curretnHealth--;}else{setImagePos(heartImg,{i:2,j:2});}playerHealthContainer.appendChild(heartImg);}};updatePlayerHearts();const GENERATION_CONFIG={chunkSize:50,};const createMinesObj=()=>{const minefield=([]);const MINES_CONFIG={bombsNum:Math.round(GENERATION_CONFIG.chunkSize**2/4),};const createField=()=>{for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){minefield[i]=[];for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){minefield[i][j]=false;}}};const getIndexForBomb=()=>{const limit=GENERATION_CONFIG.chunkSize-2;return Math.floor(Math.random()*limit)+1;};const addBomb=()=>{const row=getIndexForBomb();const column=getIndexForBomb();if(minefield[row][column])return false;minefield[row][column]=true;return true;};const addBombs=()=>{for(let i=0;i<MINES_CONFIG.bombsNum;i++){if(!addBomb())i--;}};createField();addBombs();return{isBomb:(pos)=>minefield[pos.i][pos.j],};};const MINE_BLOCKS=({MINES_LOW:{name:"MINES_LOW",color:hexToRgb("#d3d3d3"),layer:0,indestructible:true,isFluid:false,},MINES_HIGH:{name:"MINES_HIGH",color:hexToRgb("#d3d3d3"),layer:1,isFluid:false,onDestroy:(cell)=>{const aCells=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);const isNextToBomb=!!aCells.find((c)=>c.hasBomb);if(isNextToBomb)return;cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell).filter((c)=>c.wall?.block?.name==="MINES_HIGH"&&!c.hasBomb).forEach((c)=>{const onDestroy=c.wall.block.onDestroy;c.wall=null;onDestroy(c);});},},});const MINE_BIOMES=({MINES:{name:"MINES",mapColor:MINE_BLOCKS.MINES_LOW.color,minValue:-1,minDistance:0,higherGroundBlock:MINE_BLOCKS.MINES_LOW,ranges:[addPropsToBlock(MINE_BLOCKS.MINES_HIGH,{max:1})],},});const getRange=(n,range)=>Math.floor(n/range)*range;const getChunkStart=(pos,height,width)=>({i:getRange(pos.i,height),j:getRange(pos.j,width),});const hexToRgb=(hexColor)=>{let hex=hexColor.trim().slice(1);let r=parseInt(hex.substring(0,2),16);let g=parseInt(hex.substring(2,4),16);let b=parseInt(hex.substring(4,6),16);return{r,g,b};};const TRACK_TYPES={TRACK1:"TRACK1",TRACK2:"TRACK2",TRACK3:"TRACK3",TRACK4:"TRACK4",TRACK5:"TRACK5",TRACK6:"TRACK6",TRACK7:"TRACK7",TRACK8:"TRACK8",TRACK9:"TRACK9",TRACK11:"TRACK11",TRACK10:"TRACK10",TRACK12:"TRACK12",TRACK13:"TRACK13",TRACK14:"TRACK14",TRACK15:"TRACK15",TRACK16:"TRACK16",};const ENEMY_SPAWN={probability:0.00001,entityType:ENTITY_TYPES.ENEMY,spawnOnMove:true,increaseWithTime:true,};const WATER_SPAWNS=[{probability:0.0005,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const FOREST_SPAWNS=[{probability:0.01,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const SNOW_PROPS={biomeType:BIOME_TYPES.SNOW,spawnableEntities:[{probability:0.01,entityType:ENTITY_TYPES.TREE},ENEMY_SPAWN,],};const DESERT_PROPS={biomeType:BIOME_TYPES.DESERT,spawnableEntities:[{probability:0.001,entityType:ENTITY_TYPES.TREE},{...ENEMY_SPAWN,probability:0.00005,},],};const EMPTY_BLOCK=({layer:0,color:{r:-1,g:-1,b:-1},});const BLOCKS=({DEEP_WATER:{name:"DEEP_WATER",color:hexToRgb("#256299"),layer:0,isFluid:true,spawnableEntities:WATER_SPAWNS,trackType:TRACK_TYPES.TRACK5,},WATER:{name:"WATER",color:hexToRgb("#2375b4"),layer:0,isFluid:true,trackType:TRACK_TYPES.TRACK4,},LOW_GRASS:{name:"LOW_GRASS",color:hexToRgb("#457950"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK2,},MID_GRASS:{name:"MID_GRASS",color:hexToRgb("#2d673e"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK1,},HIGH_GRASS:{name:"HIGH_GRASS",color:hexToRgb("#2d673e"),layer:1,trackType:TRACK_TYPES.TRACK1,},DIRT:{name:"DIRT",color:hexToRgb("#3F573A"),layer:1,trackType:TRACK_TYPES.TRACK6,},ROCK:{name:"ROCK",color:hexToRgb("#CBC0BB"),layer:1,},BEACH_SAND:{name:"BEACH_SAND",color:hexToRgb("#ab976a"),layer:0,spawnableEntities:[ENEMY_SPAWN],trackType:TRACK_TYPES.TRACK3,},FROZEN_WATER:{name:"FROZEN_WATER",color:hexToRgb("#94F2F4"),layer:0,trackType:TRACK_TYPES.TRACK11,...SNOW_PROPS,},FROZEN_SEA_SHORE:{name:"FROZEN_SEA_SHORE",color:hexToRgb("#A0E6EC"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},SLUSH:{name:"SLUSH",color:hexToRgb("#D0ECEB"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},ICE:{name:"ICE",color:hexToRgb("#ECFFFD"),layer:0,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},HIGH_ICE:{name:"HIGH_ICE",color:hexToRgb("#ECFFFD"),layer:1,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},DUST:{name:"DUST",color:hexToRgb("#DAA98B"),layer:0,trackType:TRACK_TYPES.TRACK16,...DESERT_PROPS,},SAND:{name:"SAND",color:hexToRgb("#EC912E"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},DARK_SAND:{name:"DARK_SAND",color:hexToRgb("#CC7025"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},TERRACOTA:{name:"TERRACOTA",color:hexToRgb("#9F561A"),layer:0,trackType:TRACK_TYPES.TRACK15,...DESERT_PROPS,},HIGH_TERRACOTA:{name:"HIGH_TERRACOTA",color:hexToRgb("#9F561A"),layer:1,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},});const isCellInverted=({i,j})=>(i+j)%2!==0;const getAdjacentPos=({i,j},isInverted)=>{return{[KNOWN_POLYGONS.TRIANGLE]:isInverted?[{i:i+1,j},{i,j:j-1},{i,j:j+1},]:[{i:i-1,j},{i,j:j+1},{i,j:j-1},],[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j},{i,j:j+1},{i:i+1,j},{i,j:j-1},],[KNOWN_POLYGONS.HEXAGON]:j%2?[{i:i-1,j},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},]:[{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j},{i,j:j-1},{i:i-1,j:j-1},],};};const getAdjacentPosWithCorners=({i,j},isInverted)=>{return{...getAdjacentPos({i,j},isInverted),[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j:j-1},{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},],};};const createCellProps=(pos)=>{const isInverted=isCellInverted(pos);return{pos,isInverted,adjacentPos:getAdjacentPos(pos,isInverted),adjacentPosWithCorners:getAdjacentPosWithCorners(pos,isInverted),};};const createCell=(pos,block)=>{let cell=getCell(pos);if(!cell){cell=({});cell.entityType=null;if(block){cell.block=block;cell.layer=block.layer;cell.color=tweakColor(block.color);}}return{...createCellProps(pos),...cell};};const createEntitiesForCell=(cell,onMove=false)=>{if(!cell.block.spawnableEntities?.length)return;for(const sEntity of cell.block.spawnableEntities){const canSpawn=onMove?sEntity.spawnOnMove:!sEntity.spawnOnMove;if(!canSpawn)continue;let probability=sEntity.probability;if(sEntity.increaseWithTime)probability*=ENTITY_INFO.timeOfDay/2;if(Math.random()<probability){spawnEntity(sEntity.entityType,cell);return;}}};const getBiome=(pos)=>{switch(MENU_CONFIG.mapGeneration){case MAP_GENERATION.MIX:const biomeValue=getValue(pos.i,pos.j,PERLIN_VECTORS.BIOME);return BIOMES.find((b)=>biomeValue>=b.minValue);default:case MAP_GENERATION.DISTANCE:const distance=getPosDistance(INITIAL_POS,pos);return BIOMES.filter((b)=>(b.negativeJ===undefined||b.negativeJ===pos.j<0)&&(b.negativeI===undefined||b.negativeI===pos.i<0)).find((b)=>distance>=b.minDistance);}};const loadChunk=(initialPos)=>{const offsetPos=getChunkStart(initialPos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const biomeMap=({});let minesObj=(null);for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){const nI=i+offsetPos.i;for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){const nJ=j+offsetPos.j;const pos={i:nI,j:nJ};const biome=minesObj?MINE_BIOMES.MINES:getBiome(pos);biomeMap[biome.name]=(biomeMap[biome.name]||0)+1;const value=getValue(nI,nJ,PERLIN_VECTORS.BLOCK);const originalBlock=biome.ranges.find((r)=>value<=r.max);const isHighBlock=originalBlock.layer>0;const cellBlock=isHighBlock?biome.higherGroundBlock:originalBlock;const cell=createCell(pos,cellBlock);if(minesObj)cell.hasBomb=minesObj.isBomb({i,j});addCell(pos,cell);if(isHighBlock)cell.wall={block:originalBlock,color:tweakColor(originalBlock.color),};else createEntitiesForCell(cell);}}const biomeName=Object.entries(biomeMap).sort(([_,a],[__,b])=>b-a)[0][0];addBiomeToMap(offsetPos,BIOMES.find((b)=>b.name===biomeName));};const loadAndGetCell=(pos)=>{if(!getCell(pos))loadChunk(pos);return getCell(pos);};const getCenterCell=()=>{const{rows,columns}=getPolyInfo();const{iOffset,jOffset}=RENDER_INFO;const i=Math.floor(rows/2)+iOffset;const j=Math.floor(columns/2)+jOffset;return loadAndGetCell({i,j});};const getBorderCells=(baseCell)=>{const{rows,columns}=getPolyInfo();const halfR=Math.floor(rows/2);const halfC=Math.floor(columns/2);const{i,j}=baseCell.pos;const tI=i-halfR;const bI=i+halfR;const lJ=j-halfC;const rJ=j+halfC;const positions=([]);for(let index=lJ;index<=rJ;index++){positions.push({i:tI,j:index});positions.push({i:bI,j:index});}for(let index=tI;index<=bI;index++){positions.push({i:index,j:lJ});positions.push({i:index,j:rJ});}return positions.map(getCell);};const spawnEntities=(baseCell)=>{getBorderCells(baseCell).forEach((cell)=>{if(!!cell?.block&&!cell.wall&&!cell.entityType)createEntitiesForCell(cell,true);});};const destroyWall=(cell)=>{const onDestroy=cell.wall?.block?.onDestroy;if(cell.wall){cell.wall=null;}if(onDestroy)onDestroy(cell);};const addPropsToBlock=(block,props)=>({...block,...props});const BIOMES_RAW=({FOREST:{name:"FOREST",mapColor:BLOCKS.MID_GRASS.color,minValue:-1,minDistance:0,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.WATER,{max:-0.4}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:-0.2}),addPropsToBlock(BLOCKS.MID_GRASS,{max:0.4}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.5}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},OCEAN:{name:"OCEAN",mapColor:BLOCKS.WATER.color,minValue:-0.2,minDistance:75,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.DEEP_WATER,{max:-0.1}),addPropsToBlock(BLOCKS.WATER,{max:0.3}),addPropsToBlock(BLOCKS.BEACH_SAND,{max:0.5}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:0.7}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.8}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},SNOW:{name:"SNOW",mapColor:BLOCKS.ICE.color,minValue:0.2,minDistance:150,higherGroundBlock:BLOCKS.ICE,negativeJ:false,ranges:[addPropsToBlock(BLOCKS.FROZEN_WATER,{max:-0.2}),addPropsToBlock(BLOCKS.FROZEN_SEA_SHORE,{max:0}),addPropsToBlock(BLOCKS.SLUSH,{max:0.1}),addPropsToBlock(BLOCKS.HIGH_ICE,{max:1}),],},DESERT:{name:"DESERT",mapColor:BLOCKS.SAND.color,minValue:0,minDistance:150,higherGroundBlock:BLOCKS.TERRACOTA,negativeJ:true,ranges:[addPropsToBlock(BLOCKS.DUST,{max:-0.4}),addPropsToBlock(BLOCKS.SAND,{max:-0.2}),addPropsToBlock(BLOCKS.DARK_SAND,{max:0}),addPropsToBlock(BLOCKS.TERRACOTA,{max:0.2}),addPropsToBlock(BLOCKS.HIGH_TERRACOTA,{max:1}),],},});const BIOMES=Object.values(BIOMES_RAW).sort((a,b)=>b.minDistance-a.minDistance);const CUT_MOVEMENTS_MAP={[MOVEMENT.DOWN]:"marginTop",[MOVEMENT.LEFT]:"marginLeft",[MOVEMENT.RIGHT]:"marginRight",[MOVEMENT.UP]:"marginTop",};const container=document.getElementById("entities");const createImageElement=()=>{const img=document.createElement("div");img.className="image";return img;};const createEntityImage=(entity)=>{const img=createImageElement();img.id=entity.id;img.style.zIndex=`${entity.zIndex ||2}`;container.appendChild(img);entity.img=img;setEntitySize(entity);};const displayWinAnimation=(entity,itemPos)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);const img=createImageElement();img.classList.add("won-item");img.style.marginTop=`-${ySide}px`;setImagePos(img,itemPos);container.appendChild(img);setEntityImageSize(img,ySide/2);setImagePoint(img,point,false,ySide/2);return()=>{container.removeChild(img);};};const removeEntityImage=(entity)=>{if(entity.img)container.removeChild(entity.img);entity.img=null;};const updateEntityPoint=(entity,parentPoint)=>{if(!parentPoint&&entity.isConnected)return;const{hasInverted,canvasHeight,canvasWidth}=getPolyInfo();const point=parentPoint||calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);if(isPointOutside(point,canvasHeight,canvasWidth)){if(entity.img)removeEntityImage(entity);}else if(!entity.img){createEntityImage(entity);}if(entity.img)setImagePoint(entity.img,point);verifyEntityHeight(entity);Object.values(entity.connectedEntities).forEach((e)=>updateEntityPoint(e,point));};const updateEntityOpacity=(entity)=>{if(!entity?.img||entity?.deleted)return;entity.img.style.setProperty("--entity-opacity",`${entity.cell.modifier ||1}`);};const getEntitySize=(ySide)=>Math.round((ySide||getPolyInfo().ySide)*2.5);const setImagePos=(img,pos)=>{img.style.setProperty("--entity-position-i",`${pos.i}`);img.style.setProperty("--entity-position-j",`${pos.j}`);};const setEntityImageSize=(img,ySide)=>{if(!img)return;const size=getEntitySize(ySide);img.style.setProperty("--entity-size",`${size}px`);};const setEntitySize=(entity,ySide)=>{if(!entity?.img)return;setEntityImageSize(entity.img,ySide);setEntityImageInfo(entity);};const setEntityImageInfo=(entity)=>{const imgInfo=getEntityImageInfo(entity);if(!imgInfo.src){entity.img.style.removeProperty("--entity-img");entity.img.classList.remove("dont-use-spritesheet");}if(imgInfo.pos){setImagePos(entity.img,imgInfo.pos);}else if(imgInfo.posFn){const pos=imgInfo.posFn(!!entity.leftFootWalk);entity.leftFootWalk=!entity.leftFootWalk;setImagePos(entity.img,pos);}else if(imgInfo.src){entity.img.style.setProperty("--entity-img",`url(${imgInfo.src})`);entity.img.classList.add("dont-use-spritesheet");setImagePos(entity.img,{i:0,j:0});}};const setImagePoint=(img,point,shouldCenter,ySide)=>{if(!point)return;const entitySize=getEntitySize(ySide);img.style.setProperty("--entity-top",`${point.y -entitySize /(shouldCenter ?2 :1.25)}px`);img.style.setProperty("--entity-left",`${point.x -entitySize /2}px`);};const verifyEntityHeight=(entity)=>{if(!entity?.cell||!entity?.img)return;const{hasInverted}=getPolyInfo();const downI=hasInverted&&entity.cell.isInverted?RENDER_INFO.rotationTurns:RENDER_INFO.rotationTurns+Math.floor(RENDER_INFO.currentPoly/2);const downPos=getPosByIndex(entity.cell,downI);const downCell=getCell(downPos);if(!downCell)return;entity.img.classList.remove("not-inverted-both-walls");entity.img.classList.remove("not-inverted-right-wall");entity.img.classList.remove("not-inverted-left-wall");entity.img.classList.remove("behind-wall");if(hasInverted&&!entity.cell.isInverted){const rightCell=downCell;const leftI=RENDER_INFO.rotationTurns+RENDER_INFO.currentPoly-1;const leftPos=getPosByIndex(entity.cell,leftI);const leftCell=getCell(leftPos);if(rightCell.wall&&leftCell.wall){entity.img.classList.add("not-inverted-both-walls");}else if(rightCell.wall){entity.img.classList.add("not-inverted-right-wall");}else if(leftCell.wall){entity.img.classList.add("not-inverted-left-wall");}}else if(downCell.wall){entity.img.classList.add("behind-wall");}if(Object.values(entity.connectedEntities).length)entity.img.classList.add("behind-wall");};const getEntityImageInfo=(entity)=>{const typeMap=ENTITY_IMAGES_MAP[entity.type];const mapType=typeMap[entity.currentImgType]||typeMap[IMG_MAP_TYPES.DEFAULT];return(mapType[entity.currentDirection||MOVEMENT.DOWN]||mapType[MOVEMENT.DOWN]);};const updateEntityImage=(entity,direction,imgMapType)=>{if(!entity?.img)return;entity.currentImgType=imgMapType;entity.currentDirection=direction;setEntityImageInfo(entity);entity.img.style.marginTop=null;entity.img.style.marginLeft=null;entity.img.style.marginRight=null;};const cutEntityImage=(entity,direction)=>{if(entity.movementsToCut?.length){if(entity.movementsToCut.includes(direction)){const{ySide}=getPolyInfo();entity.img.style[CUT_MOVEMENTS_MAP[direction]]=`${ySide}px`;}}};const playerHealthContainer=document.getElementById("health-container");const updatePlayerHearts=()=>{playerHealthContainer.innerHTML="";let curretnHealth=PLAYER_ENTITY.health;for(let i=0;i<PLAYER_CONFIG.maxHealth;i++){const heartImg=createImageElement();if(curretnHealth){setImagePos(heartImg,{i:2,j:3});heartImg.classList.add("filled");curretnHealth--;}else{setImagePos(heartImg,{i:2,j:2});}playerHealthContainer.appendChild(heartImg);}};updatePlayerHearts();let BIOME_MAPS=([]);const resetBiomes=()=>(BIOME_MAPS=[]);const getPosBiomeOffset=({i,j})=>({i:i/GENERATION_CONFIG.chunkSize,j:j/GENERATION_CONFIG.chunkSize,});const addBiomeToMap=(pos,biome)=>{const{i,j}=getPosBiomeOffset(pos);if(!BIOME_MAPS[i])BIOME_MAPS[i]=[];if(BIOME_MAPS[i][j])return;BIOME_MAPS[i][j]=biome;};const getBiomeFromMap=(pos)=>{pos=getChunkStart(pos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const{i,j}=getPosBiomeOffset(pos);return BIOME_MAPS[i]?.[j];};const getBiomeMap=()=>BIOME_MAPS;const GENERATION_CONFIG={chunkSize:50,};const getRange=(n,range)=>Math.floor(n/range)*range;const getChunkStart=(pos,height,width)=>({i:getRange(pos.i,height),j:getRange(pos.j,width),});const createMinesObj=()=>{const minefield=([]);const MINES_CONFIG={bombsNum:Math.round(GENERATION_CONFIG.chunkSize**2/4),};const createField=()=>{for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){minefield[i]=[];for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){minefield[i][j]=false;}}};const getIndexForBomb=()=>{const limit=GENERATION_CONFIG.chunkSize-2;return Math.floor(Math.random()*limit)+1;};const addBomb=()=>{const row=getIndexForBomb();const column=getIndexForBomb();if(minefield[row][column])return false;minefield[row][column]=true;return true;};const addBombs=()=>{for(let i=0;i<MINES_CONFIG.bombsNum;i++){if(!addBomb())i--;}};createField();addBombs();return{isBomb:(pos)=>minefield[pos.i][pos.j],};};const MINE_BLOCKS=({MINES_LOW:{name:"MINES_LOW",color:hexToRgb("#d3d3d3"),layer:0,indestructible:true,isFluid:false,},MINES_HIGH:{name:"MINES_HIGH",color:hexToRgb("#d3d3d3"),layer:1,isFluid:false,onDestroy:(cell)=>{const aCells=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);const isNextToBomb=!!aCells.find((c)=>c.hasBomb);if(isNextToBomb)return;cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell).filter((c)=>c.wall?.block?.name==="MINES_HIGH"&&!c.hasBomb).forEach((c)=>{const onDestroy=c.wall.block.onDestroy;c.wall=null;onDestroy(c);});},},});const MINE_BIOMES=({MINES:{name:"MINES",mapColor:MINE_BLOCKS.MINES_LOW.color,minValue:-1,minDistance:0,higherGroundBlock:MINE_BLOCKS.MINES_LOW,ranges:[addPropsToBlock(MINE_BLOCKS.MINES_HIGH,{max:1})],},});const hexToRgb=(hexColor)=>{let hex=hexColor.trim().slice(1);let r=parseInt(hex.substring(0,2),16);let g=parseInt(hex.substring(2,4),16);let b=parseInt(hex.substring(4,6),16);return{r,g,b};};const TRACK_TYPES={TRACK1:"TRACK1",TRACK2:"TRACK2",TRACK3:"TRACK3",TRACK4:"TRACK4",TRACK5:"TRACK5",TRACK6:"TRACK6",TRACK7:"TRACK7",TRACK8:"TRACK8",TRACK9:"TRACK9",TRACK11:"TRACK11",TRACK10:"TRACK10",TRACK12:"TRACK12",TRACK13:"TRACK13",TRACK14:"TRACK14",TRACK15:"TRACK15",TRACK16:"TRACK16",};const ENEMY_SPAWN={probability:0.00001,entityType:ENTITY_TYPES.ENEMY,spawnOnMove:true,increaseWithTime:true,};const WATER_SPAWNS=[{probability:0.0005,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const FOREST_SPAWNS=[{probability:0.01,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const SNOW_PROPS={biomeType:BIOME_TYPES.SNOW,spawnableEntities:[{probability:0.01,entityType:ENTITY_TYPES.TREE},ENEMY_SPAWN,],};const DESERT_PROPS={biomeType:BIOME_TYPES.DESERT,spawnableEntities:[{probability:0.001,entityType:ENTITY_TYPES.TREE},{...ENEMY_SPAWN,probability:0.00005,},],};const EMPTY_BLOCK=({layer:0,color:{r:-1,g:-1,b:-1},});const BLOCKS=({DEEP_WATER:{name:"DEEP_WATER",color:hexToRgb("#256299"),layer:0,isFluid:true,spawnableEntities:WATER_SPAWNS,trackType:TRACK_TYPES.TRACK5,},WATER:{name:"WATER",color:hexToRgb("#2375b4"),layer:0,isFluid:true,trackType:TRACK_TYPES.TRACK4,},LOW_GRASS:{name:"LOW_GRASS",color:hexToRgb("#457950"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK2,},MID_GRASS:{name:"MID_GRASS",color:hexToRgb("#2d673e"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK1,},HIGH_GRASS:{name:"HIGH_GRASS",color:hexToRgb("#2d673e"),layer:1,trackType:TRACK_TYPES.TRACK1,},DIRT:{name:"DIRT",color:hexToRgb("#3F573A"),layer:1,trackType:TRACK_TYPES.TRACK6,},ROCK:{name:"ROCK",color:hexToRgb("#CBC0BB"),layer:1,},BEACH_SAND:{name:"BEACH_SAND",color:hexToRgb("#ab976a"),layer:0,spawnableEntities:[ENEMY_SPAWN],trackType:TRACK_TYPES.TRACK3,},FROZEN_WATER:{name:"FROZEN_WATER",color:hexToRgb("#94F2F4"),layer:0,trackType:TRACK_TYPES.TRACK11,...SNOW_PROPS,},FROZEN_SEA_SHORE:{name:"FROZEN_SEA_SHORE",color:hexToRgb("#A0E6EC"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},SLUSH:{name:"SLUSH",color:hexToRgb("#D0ECEB"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},ICE:{name:"ICE",color:hexToRgb("#ECFFFD"),layer:0,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},HIGH_ICE:{name:"HIGH_ICE",color:hexToRgb("#ECFFFD"),layer:1,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},DUST:{name:"DUST",color:hexToRgb("#DAA98B"),layer:0,trackType:TRACK_TYPES.TRACK16,...DESERT_PROPS,},SAND:{name:"SAND",color:hexToRgb("#EC912E"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},DARK_SAND:{name:"DARK_SAND",color:hexToRgb("#CC7025"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},TERRACOTA:{name:"TERRACOTA",color:hexToRgb("#9F561A"),layer:0,trackType:TRACK_TYPES.TRACK15,...DESERT_PROPS,},HIGH_TERRACOTA:{name:"HIGH_TERRACOTA",color:hexToRgb("#9F561A"),layer:1,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},});const addPropsToBlock=(block,props)=>({...block,...props});const BIOMES_RAW=({FOREST:{name:"FOREST",mapColor:BLOCKS.MID_GRASS.color,minValue:-1,minDistance:0,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.WATER,{max:-0.4}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:-0.2}),addPropsToBlock(BLOCKS.MID_GRASS,{max:0.4}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.5}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},OCEAN:{name:"OCEAN",mapColor:BLOCKS.WATER.color,minValue:-0.2,minDistance:75,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.DEEP_WATER,{max:-0.1}),addPropsToBlock(BLOCKS.WATER,{max:0.3}),addPropsToBlock(BLOCKS.BEACH_SAND,{max:0.5}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:0.7}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.8}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},SNOW:{name:"SNOW",mapColor:BLOCKS.ICE.color,minValue:0.2,minDistance:150,higherGroundBlock:BLOCKS.ICE,negativeJ:false,ranges:[addPropsToBlock(BLOCKS.FROZEN_WATER,{max:-0.2}),addPropsToBlock(BLOCKS.FROZEN_SEA_SHORE,{max:0}),addPropsToBlock(BLOCKS.SLUSH,{max:0.1}),addPropsToBlock(BLOCKS.HIGH_ICE,{max:1}),],},DESERT:{name:"DESERT",mapColor:BLOCKS.SAND.color,minValue:0,minDistance:150,higherGroundBlock:BLOCKS.TERRACOTA,negativeJ:true,ranges:[addPropsToBlock(BLOCKS.DUST,{max:-0.4}),addPropsToBlock(BLOCKS.SAND,{max:-0.2}),addPropsToBlock(BLOCKS.DARK_SAND,{max:0}),addPropsToBlock(BLOCKS.TERRACOTA,{max:0.2}),addPropsToBlock(BLOCKS.HIGH_TERRACOTA,{max:1}),],},});const BIOMES=Object.values(BIOMES_RAW).sort((a,b)=>b.minDistance-a.minDistance);let BIOME_MAPS=([]);const resetBiomes=()=>(BIOME_MAPS=[]);const getPosBiomeOffset=({i,j})=>({i:i/GENERATION_CONFIG.chunkSize,j:j/GENERATION_CONFIG.chunkSize,});const addBiomeToMap=(pos,biome)=>{const{i,j}=getPosBiomeOffset(pos);if(!BIOME_MAPS[i])BIOME_MAPS[i]=[];if(BIOME_MAPS[i][j])return;BIOME_MAPS[i][j]=biome;};const getBiomeFromMap=(pos)=>{pos=getChunkStart(pos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const{i,j}=getPosBiomeOffset(pos);return BIOME_MAPS[i]?.[j];};const getBiomeMap=()=>BIOME_MAPS;const createMinesObj=()=>{const minefield=([]);const MINES_CONFIG={bombsNum:Math.round(GENERATION_CONFIG.chunkSize**2/4),};const createField=()=>{for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){minefield[i]=[];for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){minefield[i][j]=false;}}};const getIndexForBomb=()=>{const limit=GENERATION_CONFIG.chunkSize-2;return Math.floor(Math.random()*limit)+1;};const addBomb=()=>{const row=getIndexForBomb();const column=getIndexForBomb();if(minefield[row][column])return false;minefield[row][column]=true;return true;};const addBombs=()=>{for(let i=0;i<MINES_CONFIG.bombsNum;i++){if(!addBomb())i--;}};createField();addBombs();return{isBomb:(pos)=>minefield[pos.i][pos.j],};};const MINE_BLOCKS=({MINES_LOW:{name:"MINES_LOW",color:hexToRgb("#d3d3d3"),layer:0,indestructible:true,isFluid:false,},MINES_HIGH:{name:"MINES_HIGH",color:hexToRgb("#d3d3d3"),layer:1,isFluid:false,onDestroy:(cell)=>{const aCells=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);const isNextToBomb=!!aCells.find((c)=>c.hasBomb);if(isNextToBomb)return;cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell).filter((c)=>c.wall?.block?.name==="MINES_HIGH"&&!c.hasBomb).forEach((c)=>{const onDestroy=c.wall.block.onDestroy;c.wall=null;onDestroy(c);});},},});const MINE_BIOMES=({MINES:{name:"MINES",mapColor:MINE_BLOCKS.MINES_LOW.color,minValue:-1,minDistance:0,higherGroundBlock:MINE_BLOCKS.MINES_LOW,ranges:[addPropsToBlock(MINE_BLOCKS.MINES_HIGH,{max:1})],},});const addEnemy=(cell)=>{const enemyEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.ENEMY,{minTime:40,movementOptions:{speed:1,targets:new Set([ENTITY_TYPES.PLAYER]),damage:1,},});if(enemyEntity&&cell.block.isFluid)getInBoat(enemyEntity);};const spawnEntity=(entityType,cell)=>{switch(entityType){case ENTITY_TYPES.TREE:return addTree(cell);case ENTITY_TYPES.RABBIT:return addRabbit(cell);case ENTITY_TYPES.ENEMY:return addEnemy(cell);}};const addRabbit=(cell)=>{const rabbitEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.RABBIT,{isGenerated:true,movementOptions:{speed:1,random:true},});if(cell.block.isFluid)getInBoat(rabbitEntity);};const PLAYER_CONFIG={maxHealth:10,};const PLAYER_ENTITY=({id:"PLAYER_1",type:ENTITY_TYPES.PLAYER,cell:null,img:document.getElementById("player"),connectedEntities:{},selectedCellIndex:0,health:PLAYER_CONFIG.maxHealth,});const addTree=(cell)=>{const treeEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.TREE,{isGenerated:true});if(cell.block.isFluid)getInBoat(treeEntity);};const addRabbit=(cell)=>{const rabbitEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.RABBIT,{isGenerated:true,movementOptions:{speed:1,random:true},});if(cell.block.isFluid)getInBoat(rabbitEntity);};const addTree=(cell)=>{const treeEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.TREE,{isGenerated:true});if(cell.block.isFluid)getInBoat(treeEntity);};const ENTITIES=(new Set());const addEntity=(entity)=>ENTITIES.add(entity);const moveEntityToCell=(entity,cell)=>{if(!cell)return;const previousType=entity.cell?.entityType||cell.entityType;if(entity.cell)entity.cell.entityType=null;entity.cell=cell;entity.cell.entityType=previousType||entity.type;updateEntityPoint(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach((e)=>moveEntityToCell(e,cell));};const removeEntity=(entity)=>{entity.cell.entityType=null;removeEntityImage(entity);ENTITIES.delete(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach(removeEntity);};const getEntitiesFromCell=(cell)=>{const entities=([]);ENTITIES.forEach((entity)=>{if(entity.cell===cell)entities.push(entity);});return entities;};const createEntity=(cell,id,type,entityParams={})=>{if(entityParams.minTime&&ENTITY_INFO.timeOfDay<entityParams.minTime)return;const entity=({id:`${type}_${id}`,type,connectedEntities:{},currentImgType:cell.block?.biomeType,health:1,...entityParams,});createEntityImage(entity);moveEntityToCell(entity,cell);addEntity(entity);return entity;};const setEntitiesSize=()=>ENTITIES.forEach((e)=>setEntitySize(e));const removeGeneratedEntities=()=>ENTITIES.forEach((e)=>e.isGenerated&&removeEntity(e));const updateEntities=()=>ENTITIES.forEach((e)=>updateEntityPoint(e));const cellIsBlocked=(cell,entity)=>!MENU_CONFIG.debugMode&&(!cell||!cell.block||!!cell.wall||!!cell.entityType||(entity.connectedEntities[ENTITY_TYPES.BOAT]?!cell.block.isFluid:cell.block.isFluid));const getSelectedCell=(entity)=>getCell(getPosByIndex(entity.cell,entity.selectedCellIndex));const updateEntityDirection=(entity,direction)=>{updateEntityImage(entity,direction);Object.values(entity.connectedEntities).forEach((e)=>{updateEntityImage(e,MOVEMENT.RIGHT);});};const makeEntityUse=(entity)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.USING);setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},250);};const updateEntityHealth=(entity)=>{if(entity===PLAYER_ENTITY){if(entity.health>PLAYER_CONFIG.maxHealth)entity.health=PLAYER_CONFIG.maxHealth;updatePlayerHearts();}else if(entity.health<=0)removeEntity(entity);};const giveItemToEntity=(entity,item)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.WINNING);const callback=displayWinAnimation(entity,item.imgPos);if(item.health){entity.health+=item.health;updateEntityHealth(entity);}setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);callback();},1000);};const hurtEntity=(entity,damage)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.LOSING);entity.health-=damage;updateEntityHealth(entity);if(entity.health>0)setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},1000);};const makeEntityRun=(entity,direction)=>{const connectedEntities=Object.values(entity.connectedEntities);if(!connectedEntities.length){updateEntityImage(entity,direction,IMG_MAP_TYPES.RUNNING);return;}updateEntityImage(entity,direction);connectedEntities.forEach((e)=>{updateEntityImage(e,direction);cutEntityImage(e,direction);});};const ENTITIES=(new Set());const addEntity=(entity)=>ENTITIES.add(entity);const moveEntityToCell=(entity,cell)=>{if(!cell)return;const previousType=entity.cell?.entityType||cell.entityType;if(entity.cell)entity.cell.entityType=null;entity.cell=cell;entity.cell.entityType=previousType||entity.type;updateEntityPoint(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach((e)=>moveEntityToCell(e,cell));};const removeEntity=(entity)=>{entity.cell.entityType=null;removeEntityImage(entity);ENTITIES.delete(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach(removeEntity);};const getEntitiesFromCell=(cell)=>{const entities=([]);ENTITIES.forEach((entity)=>{if(entity.cell===cell)entities.push(entity);});return entities;};const createEntity=(cell,id,type,entityParams={})=>{if(entityParams.minTime&&ENTITY_INFO.timeOfDay<entityParams.minTime)return;const entity=({id:`${type}_${id}`,type,connectedEntities:{},currentImgType:cell.block?.biomeType,health:1,...entityParams,});createEntityImage(entity);moveEntityToCell(entity,cell);addEntity(entity);return entity;};const setEntitiesSize=()=>ENTITIES.forEach((e)=>setEntitySize(e));const removeGeneratedEntities=()=>ENTITIES.forEach((e)=>e.isGenerated&&removeEntity(e));const updateEntities=()=>ENTITIES.forEach((e)=>updateEntityPoint(e));const cellIsBlocked=(cell,entity)=>!MENU_CONFIG.debugMode&&(!cell||!cell.block||!!cell.wall||!!cell.entityType||(entity.connectedEntities[ENTITY_TYPES.BOAT]?!cell.block.isFluid:cell.block.isFluid));const getSelectedCell=(entity)=>getCell(getPosByIndex(entity.cell,entity.selectedCellIndex));const updateEntityDirection=(entity,direction)=>{updateEntityImage(entity,direction);Object.values(entity.connectedEntities).forEach((e)=>{updateEntityImage(e,MOVEMENT.RIGHT);});};const makeEntityUse=(entity)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.USING);setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},250);};const updateEntityHealth=(entity)=>{if(entity===PLAYER_ENTITY){if(entity.health>PLAYER_CONFIG.maxHealth)entity.health=PLAYER_CONFIG.maxHealth;updatePlayerHearts();}else if(entity.health<=0)removeEntity(entity);};const giveItemToEntity=(entity,item)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.WINNING);const callback=displayWinAnimation(entity,item.imgPos);if(item.health){entity.health+=item.health;updateEntityHealth(entity);}setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);callback();},1000);};const hurtEntity=(entity,damage)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.LOSING);entity.health-=damage;updateEntityHealth(entity);if(entity.health>0)setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},1000);};const makeEntityRun=(entity,direction)=>{const connectedEntities=Object.values(entity.connectedEntities);if(!connectedEntities.length){updateEntityImage(entity,direction,IMG_MAP_TYPES.RUNNING);return;}updateEntityImage(entity,direction);connectedEntities.forEach((e)=>{updateEntityImage(e,direction);cutEntityImage(e,direction);});};const ENTITY_ACTIONS_CONFIG={delayToBurn:1000,};const getClosestTarget=(entity)=>{let minDistance=Infinity;let selectedTarget=(null);ENTITIES.forEach((targetEntity)=>{entity.movementOptions.targets.forEach((t)=>{if(targetEntity.cell&&targetEntity.type===t){const distance=getPosDistance(entity.cell.pos,targetEntity.cell.pos);if(distance<minDistance){selectedTarget=targetEntity;minDistance=distance;}}});});return selectedTarget;};const getClosestCell=(entity,cell,targetCell)=>{let minDistance=Infinity;let selectedCell=(null);let selectedIndex=0;const aPos=cell.adjacentPos[RENDER_INFO.currentPoly];for(let index=0;index<aPos.length;index++){const pos=aPos[index];const aCell=getCell(pos);if(cellIsBlocked(aCell,entity)&&aCell.entityType!==targetCell.entityType)continue;const distance=getPosDistance(aCell.pos,targetCell.pos);if(distance<minDistance){selectedCell=aCell;selectedIndex=index;minDistance=distance;}}return{cell:selectedCell,index:selectedIndex};};const moveEntities=(baseCell)=>{const{indexToMove}=getMovementMaps(baseCell);ENTITIES.forEach((e)=>{if(!e.cell||e.deleted)return;moveEntity(e,indexToMove);updateEntityOpacity(e);});};const moveEntity=(e,indexToMove)=>{if(!e.movementOptions?.speed)return;const{targets,speed,random,damage}=e.movementOptions;let nextCell=e.cell;let nextIndex=0;let target=(null);for(let index=0;index<speed;index++){if(targets){target=getClosestTarget(e);if(!target)return;const nextCellInfo=getClosestCell(e,nextCell,target.cell);nextCell=nextCellInfo.cell;nextIndex=nextCellInfo.index;if(!nextCell)return;}else if(random){nextIndex=getRandomInt(RENDER_INFO.currentPoly);const aPos=nextCell.adjacentPos[RENDER_INFO.currentPoly];nextCell=getCell(aPos[nextIndex]);for(let i=0;i<aPos.length;i++){if(!cellIsBlocked(nextCell,e))break;nextIndex=getMod(nextIndex+1,RENDER_INFO.currentPoly);nextCell=getCell(aPos[nextIndex]);}}}if(target&&nextCell.entityType===target.type&&damage){removeEntity(e);hurtEntity(target,damage);}if(cellIsBlocked(nextCell,e))return;nextIndex=getMod(nextIndex,RENDER_INFO.currentPoly);updateEntityImage(e,indexToMove[nextIndex]);moveEntityToCell(e,nextCell);};const getMovementMaps=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>{currentPoly=currentPoly??RENDER_INFO.currentPoly;hasInverted=hasInverted??getPolyInfo().hasInverted;let topI=rotationTurns??RENDER_INFO.rotationTurns;let bottomI=topI+Math.floor(currentPoly/2);let topLeftI=topI+currentPoly-1;let topRightI=topI+1;let bottomLeftI=bottomI+1;let bottomRightI=bottomI-1;if(hasInverted){topLeftI=bottomLeftI=topI+(baseCell.isInverted?1:2);topRightI=bottomRightI=topI+(baseCell.isInverted?2:1);bottomI=baseCell.isInverted?topI:undefined;topI=baseCell.isInverted?undefined:topI;}return{moveToIndex:{[MOVEMENT.UP]:topI,[MOVEMENT.DOWN]:bottomI,[MOVEMENT.LEFT]:useDiagonal?bottomLeftI:topLeftI,[MOVEMENT.RIGHT]:useDiagonal?bottomRightI:topRightI,},indexToMove:{[topI]:MOVEMENT.UP,[bottomI]:MOVEMENT.DOWN,[bottomLeftI]:MOVEMENT.LEFT,[topLeftI]:MOVEMENT.LEFT,[bottomRightI]:MOVEMENT.RIGHT,[topRightI]:MOVEMENT.RIGHT,},};};const getMovementMap=(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted)=>getMovementMaps(baseCell,useDiagonal,rotationTurns,currentPoly,hasInverted).moveToIndex;const killEntitiesByTimeOfDay=()=>{if(MENU_CONFIG.rain)return;const entitiesToKill=([]);ENTITIES.forEach((e)=>{if(!e.cell||!e.minTime||e.deleted||e.minTime<=ENTITY_INFO.timeOfDay)return;const fireEntity=createEntity(e.cell,e.id,ENTITY_TYPES.FIRE,{zIndex:e.zIndex+1,});e.connectedEntities[ENTITY_TYPES.FIRE]=fireEntity;e.deleted=true;entitiesToKill.push(e);});setTimeout(()=>{entitiesToKill.forEach(removeEntity);},ENTITY_ACTIONS_CONFIG.delayToBurn);};const CUT_MOVEMENTS_MAP={[MOVEMENT.DOWN]:"marginTop",[MOVEMENT.LEFT]:"marginLeft",[MOVEMENT.RIGHT]:"marginRight",[MOVEMENT.UP]:"marginTop",};const container=document.getElementById("entities");const createImageElement=()=>{const img=document.createElement("div");img.className="image";return img;};const createEntityImage=(entity)=>{const img=createImageElement();img.id=entity.id;img.style.zIndex=`${entity.zIndex ||2}`;container.appendChild(img);entity.img=img;setEntitySize(entity);};const displayWinAnimation=(entity,itemPos)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);const img=createImageElement();img.classList.add("won-item");img.style.marginTop=`-${ySide}px`;setImagePos(img,itemPos);container.appendChild(img);setEntityImageSize(img,ySide/2);setImagePoint(img,point,false,ySide/2);return()=>{container.removeChild(img);};};const removeEntityImage=(entity)=>{if(entity.img)container.removeChild(entity.img);entity.img=null;};const updateEntityPoint=(entity,parentPoint)=>{if(!parentPoint&&entity.isConnected)return;const{hasInverted,canvasHeight,canvasWidth}=getPolyInfo();const point=parentPoint||calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);if(isPointOutside(point,canvasHeight,canvasWidth)){if(entity.img)removeEntityImage(entity);}else if(!entity.img){createEntityImage(entity);}if(entity.img)setImagePoint(entity.img,point);verifyEntityHeight(entity);Object.values(entity.connectedEntities).forEach((e)=>updateEntityPoint(e,point));};const updateEntityOpacity=(entity)=>{if(!entity?.img||entity?.deleted)return;entity.img.style.setProperty("--entity-opacity",`${entity.cell.modifier ||1}`);};const getEntitySize=(ySide)=>Math.round((ySide||getPolyInfo().ySide)*2.5);const setImagePos=(img,pos)=>{img.style.setProperty("--entity-position-i",`${pos.i}`);img.style.setProperty("--entity-position-j",`${pos.j}`);};const setEntityImageSize=(img,ySide)=>{if(!img)return;const size=getEntitySize(ySide);img.style.setProperty("--entity-size",`${size}px`);};const setEntitySize=(entity,ySide)=>{if(!entity?.img)return;setEntityImageSize(entity.img,ySide);setEntityImageInfo(entity);};const setEntityImageInfo=(entity)=>{const imgInfo=getEntityImageInfo(entity);if(!imgInfo.src){entity.img.style.removeProperty("--entity-img");entity.img.classList.remove("dont-use-spritesheet");}if(imgInfo.pos){setImagePos(entity.img,imgInfo.pos);}else if(imgInfo.posFn){const pos=imgInfo.posFn(!!entity.leftFootWalk);entity.leftFootWalk=!entity.leftFootWalk;setImagePos(entity.img,pos);}else if(imgInfo.src){entity.img.style.setProperty("--entity-img",`url(${imgInfo.src})`);entity.img.classList.add("dont-use-spritesheet");setImagePos(entity.img,{i:0,j:0});}};const setImagePoint=(img,point,shouldCenter,ySide)=>{if(!point)return;const entitySize=getEntitySize(ySide);img.style.setProperty("--entity-top",`${point.y -entitySize /(shouldCenter ?2 :1.25)}px`);img.style.setProperty("--entity-left",`${point.x -entitySize /2}px`);};const verifyEntityHeight=(entity)=>{if(!entity?.cell||!entity?.img)return;const{hasInverted}=getPolyInfo();const downI=hasInverted&&entity.cell.isInverted?RENDER_INFO.rotationTurns:RENDER_INFO.rotationTurns+Math.floor(RENDER_INFO.currentPoly/2);const downPos=getPosByIndex(entity.cell,downI);const downCell=getCell(downPos);if(!downCell)return;entity.img.classList.remove("not-inverted-both-walls");entity.img.classList.remove("not-inverted-right-wall");entity.img.classList.remove("not-inverted-left-wall");entity.img.classList.remove("behind-wall");if(hasInverted&&!entity.cell.isInverted){const rightCell=downCell;const leftI=RENDER_INFO.rotationTurns+RENDER_INFO.currentPoly-1;const leftPos=getPosByIndex(entity.cell,leftI);const leftCell=getCell(leftPos);if(rightCell.wall&&leftCell.wall){entity.img.classList.add("not-inverted-both-walls");}else if(rightCell.wall){entity.img.classList.add("not-inverted-right-wall");}else if(leftCell.wall){entity.img.classList.add("not-inverted-left-wall");}}else if(downCell.wall){entity.img.classList.add("behind-wall");}if(Object.values(entity.connectedEntities).length)entity.img.classList.add("behind-wall");};const getEntityImageInfo=(entity)=>{const typeMap=ENTITY_IMAGES_MAP[entity.type];const mapType=typeMap[entity.currentImgType]||typeMap[IMG_MAP_TYPES.DEFAULT];return(mapType[entity.currentDirection||MOVEMENT.DOWN]||mapType[MOVEMENT.DOWN]);};const updateEntityImage=(entity,direction,imgMapType)=>{if(!entity?.img)return;entity.currentImgType=imgMapType;entity.currentDirection=direction;setEntityImageInfo(entity);entity.img.style.marginTop=null;entity.img.style.marginLeft=null;entity.img.style.marginRight=null;};const cutEntityImage=(entity,direction)=>{if(entity.movementsToCut?.length){if(entity.movementsToCut.includes(direction)){const{ySide}=getPolyInfo();entity.img.style[CUT_MOVEMENTS_MAP[direction]]=`${ySide}px`;}}};const playerHealthContainer=document.getElementById("health-container");const updatePlayerHearts=()=>{playerHealthContainer.innerHTML="";let curretnHealth=PLAYER_ENTITY.health;for(let i=0;i<PLAYER_CONFIG.maxHealth;i++){const heartImg=createImageElement();if(curretnHealth){setImagePos(heartImg,{i:2,j:3});heartImg.classList.add("filled");curretnHealth--;}else{setImagePos(heartImg,{i:2,j:2});}playerHealthContainer.appendChild(heartImg);}};updatePlayerHearts();const CUT_MOVEMENTS_MAP={[MOVEMENT.DOWN]:"marginTop",[MOVEMENT.LEFT]:"marginLeft",[MOVEMENT.RIGHT]:"marginRight",[MOVEMENT.UP]:"marginTop",};const container=document.getElementById("entities");const createImageElement=()=>{const img=document.createElement("div");img.className="image";return img;};const createEntityImage=(entity)=>{const img=createImageElement();img.id=entity.id;img.style.zIndex=`${entity.zIndex ||2}`;container.appendChild(img);entity.img=img;setEntitySize(entity);};const displayWinAnimation=(entity,itemPos)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);const img=createImageElement();img.classList.add("won-item");img.style.marginTop=`-${ySide}px`;setImagePos(img,itemPos);container.appendChild(img);setEntityImageSize(img,ySide/2);setImagePoint(img,point,false,ySide/2);return()=>{container.removeChild(img);};};const removeEntityImage=(entity)=>{if(entity.img)container.removeChild(entity.img);entity.img=null;};const updateEntityPoint=(entity,parentPoint)=>{if(!parentPoint&&entity.isConnected)return;const{hasInverted,canvasHeight,canvasWidth}=getPolyInfo();const point=parentPoint||calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);if(isPointOutside(point,canvasHeight,canvasWidth)){if(entity.img)removeEntityImage(entity);}else if(!entity.img){createEntityImage(entity);}if(entity.img)setImagePoint(entity.img,point);verifyEntityHeight(entity);Object.values(entity.connectedEntities).forEach((e)=>updateEntityPoint(e,point));};const updateEntityOpacity=(entity)=>{if(!entity?.img||entity?.deleted)return;entity.img.style.setProperty("--entity-opacity",`${entity.cell.modifier ||1}`);};const getEntitySize=(ySide)=>Math.round((ySide||getPolyInfo().ySide)*2.5);const setImagePos=(img,pos)=>{img.style.setProperty("--entity-position-i",`${pos.i}`);img.style.setProperty("--entity-position-j",`${pos.j}`);};const setEntityImageSize=(img,ySide)=>{if(!img)return;const size=getEntitySize(ySide);img.style.setProperty("--entity-size",`${size}px`);};const setEntitySize=(entity,ySide)=>{if(!entity?.img)return;setEntityImageSize(entity.img,ySide);setEntityImageInfo(entity);};const setEntityImageInfo=(entity)=>{const imgInfo=getEntityImageInfo(entity);if(!imgInfo.src){entity.img.style.removeProperty("--entity-img");entity.img.classList.remove("dont-use-spritesheet");}if(imgInfo.pos){setImagePos(entity.img,imgInfo.pos);}else if(imgInfo.posFn){const pos=imgInfo.posFn(!!entity.leftFootWalk);entity.leftFootWalk=!entity.leftFootWalk;setImagePos(entity.img,pos);}else if(imgInfo.src){entity.img.style.setProperty("--entity-img",`url(${imgInfo.src})`);entity.img.classList.add("dont-use-spritesheet");setImagePos(entity.img,{i:0,j:0});}};const setImagePoint=(img,point,shouldCenter,ySide)=>{if(!point)return;const entitySize=getEntitySize(ySide);img.style.setProperty("--entity-top",`${point.y -entitySize /(shouldCenter ?2 :1.25)}px`);img.style.setProperty("--entity-left",`${point.x -entitySize /2}px`);};const verifyEntityHeight=(entity)=>{if(!entity?.cell||!entity?.img)return;const{hasInverted}=getPolyInfo();const downI=hasInverted&&entity.cell.isInverted?RENDER_INFO.rotationTurns:RENDER_INFO.rotationTurns+Math.floor(RENDER_INFO.currentPoly/2);const downPos=getPosByIndex(entity.cell,downI);const downCell=getCell(downPos);if(!downCell)return;entity.img.classList.remove("not-inverted-both-walls");entity.img.classList.remove("not-inverted-right-wall");entity.img.classList.remove("not-inverted-left-wall");entity.img.classList.remove("behind-wall");if(hasInverted&&!entity.cell.isInverted){const rightCell=downCell;const leftI=RENDER_INFO.rotationTurns+RENDER_INFO.currentPoly-1;const leftPos=getPosByIndex(entity.cell,leftI);const leftCell=getCell(leftPos);if(rightCell.wall&&leftCell.wall){entity.img.classList.add("not-inverted-both-walls");}else if(rightCell.wall){entity.img.classList.add("not-inverted-right-wall");}else if(leftCell.wall){entity.img.classList.add("not-inverted-left-wall");}}else if(downCell.wall){entity.img.classList.add("behind-wall");}if(Object.values(entity.connectedEntities).length)entity.img.classList.add("behind-wall");};const getEntityImageInfo=(entity)=>{const typeMap=ENTITY_IMAGES_MAP[entity.type];const mapType=typeMap[entity.currentImgType]||typeMap[IMG_MAP_TYPES.DEFAULT];return(mapType[entity.currentDirection||MOVEMENT.DOWN]||mapType[MOVEMENT.DOWN]);};const updateEntityImage=(entity,direction,imgMapType)=>{if(!entity?.img)return;entity.currentImgType=imgMapType;entity.currentDirection=direction;setEntityImageInfo(entity);entity.img.style.marginTop=null;entity.img.style.marginLeft=null;entity.img.style.marginRight=null;};const cutEntityImage=(entity,direction)=>{if(entity.movementsToCut?.length){if(entity.movementsToCut.includes(direction)){const{ySide}=getPolyInfo();entity.img.style[CUT_MOVEMENTS_MAP[direction]]=`${ySide}px`;}}};const playerHealthContainer=document.getElementById("health-container");const updatePlayerHearts=()=>{playerHealthContainer.innerHTML="";let curretnHealth=PLAYER_ENTITY.health;for(let i=0;i<PLAYER_CONFIG.maxHealth;i++){const heartImg=createImageElement();if(curretnHealth){setImagePos(heartImg,{i:2,j:3});heartImg.classList.add("filled");curretnHealth--;}else{setImagePos(heartImg,{i:2,j:2});}playerHealthContainer.appendChild(heartImg);}};updatePlayerHearts();const BOAT_ENTITIES=({});const getInBoat=(entity)=>{if(!BOAT_ENTITIES[entity.id])addBoat(entity.cell,entity);BOAT_ENTITIES[entity.id].isConnected=true;entity.connectedEntities[ENTITY_TYPES.BOAT]=BOAT_ENTITIES[entity.id];};const getOutBoat=(entity)=>{if(entity.connectedEntities[ENTITY_TYPES.BOAT]){delete entity.connectedEntities[ENTITY_TYPES.BOAT];BOAT_ENTITIES[entity.id].isConnected=false;moveEntityToCell(BOAT_ENTITIES[entity.id],entity.cell);}};const addBoat=(cell,entity)=>{let boatEntity=BOAT_ENTITIES[entity.id];if(!boatEntity)boatEntity=BOAT_ENTITIES[entity.id]=createEntity(cell,entity.id,ENTITY_TYPES.BOAT,{zIndex:1,movementsToCut:[MOVEMENT.UP,MOVEMENT.DOWN],currentDirection:MOVEMENT.RIGHT,});moveEntityToCell(boatEntity,cell);};const GENERATION_CONFIG={chunkSize:50,};const addEnemy=(cell)=>{const enemyEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.ENEMY,{minTime:40,movementOptions:{speed:1,targets:new Set([ENTITY_TYPES.PLAYER]),damage:1,},});if(enemyEntity&&cell.block.isFluid)getInBoat(enemyEntity);};const GENERATION_CONFIG={chunkSize:50,};const getRange=(n,range)=>Math.floor(n/range)*range;const getChunkStart=(pos,height,width)=>({i:getRange(pos.i,height),j:getRange(pos.j,width),});const spawnEntity=(entityType,cell)=>{switch(entityType){case ENTITY_TYPES.TREE:return addTree(cell);case ENTITY_TYPES.RABBIT:return addRabbit(cell);case ENTITY_TYPES.ENEMY:return addEnemy(cell);}};const getRange=(n,range)=>Math.floor(n/range)*range;const getChunkStart=(pos,height,width)=>({i:getRange(pos.i,height),j:getRange(pos.j,width),});const hexToRgb=(hexColor)=>{let hex=hexColor.trim().slice(1);let r=parseInt(hex.substring(0,2),16);let g=parseInt(hex.substring(2,4),16);let b=parseInt(hex.substring(4,6),16);return{r,g,b};};const TRACK_TYPES={TRACK1:"TRACK1",TRACK2:"TRACK2",TRACK3:"TRACK3",TRACK4:"TRACK4",TRACK5:"TRACK5",TRACK6:"TRACK6",TRACK7:"TRACK7",TRACK8:"TRACK8",TRACK9:"TRACK9",TRACK11:"TRACK11",TRACK10:"TRACK10",TRACK12:"TRACK12",TRACK13:"TRACK13",TRACK14:"TRACK14",TRACK15:"TRACK15",TRACK16:"TRACK16",};const ENEMY_SPAWN={probability:0.00001,entityType:ENTITY_TYPES.ENEMY,spawnOnMove:true,increaseWithTime:true,};const WATER_SPAWNS=[{probability:0.0005,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const FOREST_SPAWNS=[{probability:0.01,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const SNOW_PROPS={biomeType:BIOME_TYPES.SNOW,spawnableEntities:[{probability:0.01,entityType:ENTITY_TYPES.TREE},ENEMY_SPAWN,],};const DESERT_PROPS={biomeType:BIOME_TYPES.DESERT,spawnableEntities:[{probability:0.001,entityType:ENTITY_TYPES.TREE},{...ENEMY_SPAWN,probability:0.00005,},],};const EMPTY_BLOCK=({layer:0,color:{r:-1,g:-1,b:-1},});const BLOCKS=({DEEP_WATER:{name:"DEEP_WATER",color:hexToRgb("#256299"),layer:0,isFluid:true,spawnableEntities:WATER_SPAWNS,trackType:TRACK_TYPES.TRACK5,},WATER:{name:"WATER",color:hexToRgb("#2375b4"),layer:0,isFluid:true,trackType:TRACK_TYPES.TRACK4,},LOW_GRASS:{name:"LOW_GRASS",color:hexToRgb("#457950"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK2,},MID_GRASS:{name:"MID_GRASS",color:hexToRgb("#2d673e"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK1,},HIGH_GRASS:{name:"HIGH_GRASS",color:hexToRgb("#2d673e"),layer:1,trackType:TRACK_TYPES.TRACK1,},DIRT:{name:"DIRT",color:hexToRgb("#3F573A"),layer:1,trackType:TRACK_TYPES.TRACK6,},ROCK:{name:"ROCK",color:hexToRgb("#CBC0BB"),layer:1,},BEACH_SAND:{name:"BEACH_SAND",color:hexToRgb("#ab976a"),layer:0,spawnableEntities:[ENEMY_SPAWN],trackType:TRACK_TYPES.TRACK3,},FROZEN_WATER:{name:"FROZEN_WATER",color:hexToRgb("#94F2F4"),layer:0,trackType:TRACK_TYPES.TRACK11,...SNOW_PROPS,},FROZEN_SEA_SHORE:{name:"FROZEN_SEA_SHORE",color:hexToRgb("#A0E6EC"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},SLUSH:{name:"SLUSH",color:hexToRgb("#D0ECEB"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},ICE:{name:"ICE",color:hexToRgb("#ECFFFD"),layer:0,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},HIGH_ICE:{name:"HIGH_ICE",color:hexToRgb("#ECFFFD"),layer:1,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},DUST:{name:"DUST",color:hexToRgb("#DAA98B"),layer:0,trackType:TRACK_TYPES.TRACK16,...DESERT_PROPS,},SAND:{name:"SAND",color:hexToRgb("#EC912E"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},DARK_SAND:{name:"DARK_SAND",color:hexToRgb("#CC7025"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},TERRACOTA:{name:"TERRACOTA",color:hexToRgb("#9F561A"),layer:0,trackType:TRACK_TYPES.TRACK15,...DESERT_PROPS,},HIGH_TERRACOTA:{name:"HIGH_TERRACOTA",color:hexToRgb("#9F561A"),layer:1,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},});const PLAYER_CONFIG={maxHealth:10,};const PLAYER_ENTITY=({id:"PLAYER_1",type:ENTITY_TYPES.PLAYER,cell:null,img:document.getElementById("player"),connectedEntities:{},selectedCellIndex:0,health:PLAYER_CONFIG.maxHealth,});const addRabbit=(cell)=>{const rabbitEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.RABBIT,{isGenerated:true,movementOptions:{speed:1,random:true},});if(cell.block.isFluid)getInBoat(rabbitEntity);};const addPropsToBlock=(block,props)=>({...block,...props});const BIOMES_RAW=({FOREST:{name:"FOREST",mapColor:BLOCKS.MID_GRASS.color,minValue:-1,minDistance:0,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.WATER,{max:-0.4}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:-0.2}),addPropsToBlock(BLOCKS.MID_GRASS,{max:0.4}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.5}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},OCEAN:{name:"OCEAN",mapColor:BLOCKS.WATER.color,minValue:-0.2,minDistance:75,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.DEEP_WATER,{max:-0.1}),addPropsToBlock(BLOCKS.WATER,{max:0.3}),addPropsToBlock(BLOCKS.BEACH_SAND,{max:0.5}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:0.7}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.8}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},SNOW:{name:"SNOW",mapColor:BLOCKS.ICE.color,minValue:0.2,minDistance:150,higherGroundBlock:BLOCKS.ICE,negativeJ:false,ranges:[addPropsToBlock(BLOCKS.FROZEN_WATER,{max:-0.2}),addPropsToBlock(BLOCKS.FROZEN_SEA_SHORE,{max:0}),addPropsToBlock(BLOCKS.SLUSH,{max:0.1}),addPropsToBlock(BLOCKS.HIGH_ICE,{max:1}),],},DESERT:{name:"DESERT",mapColor:BLOCKS.SAND.color,minValue:0,minDistance:150,higherGroundBlock:BLOCKS.TERRACOTA,negativeJ:true,ranges:[addPropsToBlock(BLOCKS.DUST,{max:-0.4}),addPropsToBlock(BLOCKS.SAND,{max:-0.2}),addPropsToBlock(BLOCKS.DARK_SAND,{max:0}),addPropsToBlock(BLOCKS.TERRACOTA,{max:0.2}),addPropsToBlock(BLOCKS.HIGH_TERRACOTA,{max:1}),],},});const BIOMES=Object.values(BIOMES_RAW).sort((a,b)=>b.minDistance-a.minDistance);const hexToRgb=(hexColor)=>{let hex=hexColor.trim().slice(1);let r=parseInt(hex.substring(0,2),16);let g=parseInt(hex.substring(2,4),16);let b=parseInt(hex.substring(4,6),16);return{r,g,b};};const TRACK_TYPES={TRACK1:"TRACK1",TRACK2:"TRACK2",TRACK3:"TRACK3",TRACK4:"TRACK4",TRACK5:"TRACK5",TRACK6:"TRACK6",TRACK7:"TRACK7",TRACK8:"TRACK8",TRACK9:"TRACK9",TRACK11:"TRACK11",TRACK10:"TRACK10",TRACK12:"TRACK12",TRACK13:"TRACK13",TRACK14:"TRACK14",TRACK15:"TRACK15",TRACK16:"TRACK16",};const ENEMY_SPAWN={probability:0.00001,entityType:ENTITY_TYPES.ENEMY,spawnOnMove:true,increaseWithTime:true,};const WATER_SPAWNS=[{probability:0.0005,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const FOREST_SPAWNS=[{probability:0.01,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const SNOW_PROPS={biomeType:BIOME_TYPES.SNOW,spawnableEntities:[{probability:0.01,entityType:ENTITY_TYPES.TREE},ENEMY_SPAWN,],};const DESERT_PROPS={biomeType:BIOME_TYPES.DESERT,spawnableEntities:[{probability:0.001,entityType:ENTITY_TYPES.TREE},{...ENEMY_SPAWN,probability:0.00005,},],};const EMPTY_BLOCK=({layer:0,color:{r:-1,g:-1,b:-1},});const BLOCKS=({DEEP_WATER:{name:"DEEP_WATER",color:hexToRgb("#256299"),layer:0,isFluid:true,spawnableEntities:WATER_SPAWNS,trackType:TRACK_TYPES.TRACK5,},WATER:{name:"WATER",color:hexToRgb("#2375b4"),layer:0,isFluid:true,trackType:TRACK_TYPES.TRACK4,},LOW_GRASS:{name:"LOW_GRASS",color:hexToRgb("#457950"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK2,},MID_GRASS:{name:"MID_GRASS",color:hexToRgb("#2d673e"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK1,},HIGH_GRASS:{name:"HIGH_GRASS",color:hexToRgb("#2d673e"),layer:1,trackType:TRACK_TYPES.TRACK1,},DIRT:{name:"DIRT",color:hexToRgb("#3F573A"),layer:1,trackType:TRACK_TYPES.TRACK6,},ROCK:{name:"ROCK",color:hexToRgb("#CBC0BB"),layer:1,},BEACH_SAND:{name:"BEACH_SAND",color:hexToRgb("#ab976a"),layer:0,spawnableEntities:[ENEMY_SPAWN],trackType:TRACK_TYPES.TRACK3,},FROZEN_WATER:{name:"FROZEN_WATER",color:hexToRgb("#94F2F4"),layer:0,trackType:TRACK_TYPES.TRACK11,...SNOW_PROPS,},FROZEN_SEA_SHORE:{name:"FROZEN_SEA_SHORE",color:hexToRgb("#A0E6EC"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},SLUSH:{name:"SLUSH",color:hexToRgb("#D0ECEB"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},ICE:{name:"ICE",color:hexToRgb("#ECFFFD"),layer:0,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},HIGH_ICE:{name:"HIGH_ICE",color:hexToRgb("#ECFFFD"),layer:1,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},DUST:{name:"DUST",color:hexToRgb("#DAA98B"),layer:0,trackType:TRACK_TYPES.TRACK16,...DESERT_PROPS,},SAND:{name:"SAND",color:hexToRgb("#EC912E"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},DARK_SAND:{name:"DARK_SAND",color:hexToRgb("#CC7025"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},TERRACOTA:{name:"TERRACOTA",color:hexToRgb("#9F561A"),layer:0,trackType:TRACK_TYPES.TRACK15,...DESERT_PROPS,},HIGH_TERRACOTA:{name:"HIGH_TERRACOTA",color:hexToRgb("#9F561A"),layer:1,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},});const addTree=(cell)=>{const treeEntity=createEntity(cell,`${cell.pos.i}_${cell.pos.j}`,ENTITY_TYPES.TREE,{isGenerated:true});if(cell.block.isFluid)getInBoat(treeEntity);};const addPropsToBlock=(block,props)=>({...block,...props});const BIOMES_RAW=({FOREST:{name:"FOREST",mapColor:BLOCKS.MID_GRASS.color,minValue:-1,minDistance:0,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.WATER,{max:-0.4}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:-0.2}),addPropsToBlock(BLOCKS.MID_GRASS,{max:0.4}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.5}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},OCEAN:{name:"OCEAN",mapColor:BLOCKS.WATER.color,minValue:-0.2,minDistance:75,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.DEEP_WATER,{max:-0.1}),addPropsToBlock(BLOCKS.WATER,{max:0.3}),addPropsToBlock(BLOCKS.BEACH_SAND,{max:0.5}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:0.7}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.8}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},SNOW:{name:"SNOW",mapColor:BLOCKS.ICE.color,minValue:0.2,minDistance:150,higherGroundBlock:BLOCKS.ICE,negativeJ:false,ranges:[addPropsToBlock(BLOCKS.FROZEN_WATER,{max:-0.2}),addPropsToBlock(BLOCKS.FROZEN_SEA_SHORE,{max:0}),addPropsToBlock(BLOCKS.SLUSH,{max:0.1}),addPropsToBlock(BLOCKS.HIGH_ICE,{max:1}),],},DESERT:{name:"DESERT",mapColor:BLOCKS.SAND.color,minValue:0,minDistance:150,higherGroundBlock:BLOCKS.TERRACOTA,negativeJ:true,ranges:[addPropsToBlock(BLOCKS.DUST,{max:-0.4}),addPropsToBlock(BLOCKS.SAND,{max:-0.2}),addPropsToBlock(BLOCKS.DARK_SAND,{max:0}),addPropsToBlock(BLOCKS.TERRACOTA,{max:0.2}),addPropsToBlock(BLOCKS.HIGH_TERRACOTA,{max:1}),],},});const BIOMES=Object.values(BIOMES_RAW).sort((a,b)=>b.minDistance-a.minDistance);let BIOME_MAPS=([]);const resetBiomes=()=>(BIOME_MAPS=[]);const getPosBiomeOffset=({i,j})=>({i:i/GENERATION_CONFIG.chunkSize,j:j/GENERATION_CONFIG.chunkSize,});const addBiomeToMap=(pos,biome)=>{const{i,j}=getPosBiomeOffset(pos);if(!BIOME_MAPS[i])BIOME_MAPS[i]=[];if(BIOME_MAPS[i][j])return;BIOME_MAPS[i][j]=biome;};const getBiomeFromMap=(pos)=>{pos=getChunkStart(pos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const{i,j}=getPosBiomeOffset(pos);return BIOME_MAPS[i]?.[j];};const getBiomeMap=()=>BIOME_MAPS;const isCellInverted=({i,j})=>(i+j)%2!==0;const getAdjacentPos=({i,j},isInverted)=>{return{[KNOWN_POLYGONS.TRIANGLE]:isInverted?[{i:i+1,j},{i,j:j-1},{i,j:j+1},]:[{i:i-1,j},{i,j:j+1},{i,j:j-1},],[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j},{i,j:j+1},{i:i+1,j},{i,j:j-1},],[KNOWN_POLYGONS.HEXAGON]:j%2?[{i:i-1,j},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},]:[{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j},{i,j:j-1},{i:i-1,j:j-1},],};};const getAdjacentPosWithCorners=({i,j},isInverted)=>{return{...getAdjacentPos({i,j},isInverted),[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j:j-1},{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},],};};const createCellProps=(pos)=>{const isInverted=isCellInverted(pos);return{pos,isInverted,adjacentPos:getAdjacentPos(pos,isInverted),adjacentPosWithCorners:getAdjacentPosWithCorners(pos,isInverted),};};const createCell=(pos,block)=>{let cell=getCell(pos);if(!cell){cell=({});cell.entityType=null;if(block){cell.block=block;cell.layer=block.layer;cell.color=tweakColor(block.color);}}return{...createCellProps(pos),...cell};};const createEntitiesForCell=(cell,onMove=false)=>{if(!cell.block.spawnableEntities?.length)return;for(const sEntity of cell.block.spawnableEntities){const canSpawn=onMove?sEntity.spawnOnMove:!sEntity.spawnOnMove;if(!canSpawn)continue;let probability=sEntity.probability;if(sEntity.increaseWithTime)probability*=ENTITY_INFO.timeOfDay/2;if(Math.random()<probability){spawnEntity(sEntity.entityType,cell);return;}}};const getBiome=(pos)=>{switch(MENU_CONFIG.mapGeneration){case MAP_GENERATION.MIX:const biomeValue=getValue(pos.i,pos.j,PERLIN_VECTORS.BIOME);return BIOMES.find((b)=>biomeValue>=b.minValue);default:case MAP_GENERATION.DISTANCE:const distance=getPosDistance(INITIAL_POS,pos);return BIOMES.filter((b)=>(b.negativeJ===undefined||b.negativeJ===pos.j<0)&&(b.negativeI===undefined||b.negativeI===pos.i<0)).find((b)=>distance>=b.minDistance);}};const loadChunk=(initialPos)=>{const offsetPos=getChunkStart(initialPos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const biomeMap=({});let minesObj=(null);for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){const nI=i+offsetPos.i;for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){const nJ=j+offsetPos.j;const pos={i:nI,j:nJ};const biome=minesObj?MINE_BIOMES.MINES:getBiome(pos);biomeMap[biome.name]=(biomeMap[biome.name]||0)+1;const value=getValue(nI,nJ,PERLIN_VECTORS.BLOCK);const originalBlock=biome.ranges.find((r)=>value<=r.max);const isHighBlock=originalBlock.layer>0;const cellBlock=isHighBlock?biome.higherGroundBlock:originalBlock;const cell=createCell(pos,cellBlock);if(minesObj)cell.hasBomb=minesObj.isBomb({i,j});addCell(pos,cell);if(isHighBlock)cell.wall={block:originalBlock,color:tweakColor(originalBlock.color),};else createEntitiesForCell(cell);}}const biomeName=Object.entries(biomeMap).sort(([_,a],[__,b])=>b-a)[0][0];addBiomeToMap(offsetPos,BIOMES.find((b)=>b.name===biomeName));};const loadAndGetCell=(pos)=>{if(!getCell(pos))loadChunk(pos);return getCell(pos);};const getCenterCell=()=>{const{rows,columns}=getPolyInfo();const{iOffset,jOffset}=RENDER_INFO;const i=Math.floor(rows/2)+iOffset;const j=Math.floor(columns/2)+jOffset;return loadAndGetCell({i,j});};const getBorderCells=(baseCell)=>{const{rows,columns}=getPolyInfo();const halfR=Math.floor(rows/2);const halfC=Math.floor(columns/2);const{i,j}=baseCell.pos;const tI=i-halfR;const bI=i+halfR;const lJ=j-halfC;const rJ=j+halfC;const positions=([]);for(let index=lJ;index<=rJ;index++){positions.push({i:tI,j:index});positions.push({i:bI,j:index});}for(let index=tI;index<=bI;index++){positions.push({i:index,j:lJ});positions.push({i:index,j:rJ});}return positions.map(getCell);};const spawnEntities=(baseCell)=>{getBorderCells(baseCell).forEach((cell)=>{if(!!cell?.block&&!cell.wall&&!cell.entityType)createEntitiesForCell(cell,true);});};const destroyWall=(cell)=>{const onDestroy=cell.wall?.block?.onDestroy;if(cell.wall){cell.wall=null;}if(onDestroy)onDestroy(cell);};let BIOME_MAPS=([]);const resetBiomes=()=>(BIOME_MAPS=[]);const getPosBiomeOffset=({i,j})=>({i:i/GENERATION_CONFIG.chunkSize,j:j/GENERATION_CONFIG.chunkSize,});const addBiomeToMap=(pos,biome)=>{const{i,j}=getPosBiomeOffset(pos);if(!BIOME_MAPS[i])BIOME_MAPS[i]=[];if(BIOME_MAPS[i][j])return;BIOME_MAPS[i][j]=biome;};const getBiomeFromMap=(pos)=>{pos=getChunkStart(pos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const{i,j}=getPosBiomeOffset(pos);return BIOME_MAPS[i]?.[j];};const getBiomeMap=()=>BIOME_MAPS;const createMinesObj=()=>{const minefield=([]);const MINES_CONFIG={bombsNum:Math.round(GENERATION_CONFIG.chunkSize**2/4),};const createField=()=>{for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){minefield[i]=[];for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){minefield[i][j]=false;}}};const getIndexForBomb=()=>{const limit=GENERATION_CONFIG.chunkSize-2;return Math.floor(Math.random()*limit)+1;};const addBomb=()=>{const row=getIndexForBomb();const column=getIndexForBomb();if(minefield[row][column])return false;minefield[row][column]=true;return true;};const addBombs=()=>{for(let i=0;i<MINES_CONFIG.bombsNum;i++){if(!addBomb())i--;}};createField();addBombs();return{isBomb:(pos)=>minefield[pos.i][pos.j],};};const MINE_BLOCKS=({MINES_LOW:{name:"MINES_LOW",color:hexToRgb("#d3d3d3"),layer:0,indestructible:true,isFluid:false,},MINES_HIGH:{name:"MINES_HIGH",color:hexToRgb("#d3d3d3"),layer:1,isFluid:false,onDestroy:(cell)=>{const aCells=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);const isNextToBomb=!!aCells.find((c)=>c.hasBomb);if(isNextToBomb)return;cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell).filter((c)=>c.wall?.block?.name==="MINES_HIGH"&&!c.hasBomb).forEach((c)=>{const onDestroy=c.wall.block.onDestroy;c.wall=null;onDestroy(c);});},},});const MINE_BIOMES=({MINES:{name:"MINES",mapColor:MINE_BLOCKS.MINES_LOW.color,minValue:-1,minDistance:0,higherGroundBlock:MINE_BLOCKS.MINES_LOW,ranges:[addPropsToBlock(MINE_BLOCKS.MINES_HIGH,{max:1})],},});const createMinesObj=()=>{const minefield=([]);const MINES_CONFIG={bombsNum:Math.round(GENERATION_CONFIG.chunkSize**2/4),};const createField=()=>{for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){minefield[i]=[];for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){minefield[i][j]=false;}}};const getIndexForBomb=()=>{const limit=GENERATION_CONFIG.chunkSize-2;return Math.floor(Math.random()*limit)+1;};const addBomb=()=>{const row=getIndexForBomb();const column=getIndexForBomb();if(minefield[row][column])return false;minefield[row][column]=true;return true;};const addBombs=()=>{for(let i=0;i<MINES_CONFIG.bombsNum;i++){if(!addBomb())i--;}};createField();addBombs();return{isBomb:(pos)=>minefield[pos.i][pos.j],};};const MINE_BLOCKS=({MINES_LOW:{name:"MINES_LOW",color:hexToRgb("#d3d3d3"),layer:0,indestructible:true,isFluid:false,},MINES_HIGH:{name:"MINES_HIGH",color:hexToRgb("#d3d3d3"),layer:1,isFluid:false,onDestroy:(cell)=>{const aCells=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);const isNextToBomb=!!aCells.find((c)=>c.hasBomb);if(isNextToBomb)return;cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell).filter((c)=>c.wall?.block?.name==="MINES_HIGH"&&!c.hasBomb).forEach((c)=>{const onDestroy=c.wall.block.onDestroy;c.wall=null;onDestroy(c);});},},});const MINE_BIOMES=({MINES:{name:"MINES",mapColor:MINE_BLOCKS.MINES_LOW.color,minValue:-1,minDistance:0,higherGroundBlock:MINE_BLOCKS.MINES_LOW,ranges:[addPropsToBlock(MINE_BLOCKS.MINES_HIGH,{max:1})],},});const ENTITIES=(new Set());const addEntity=(entity)=>ENTITIES.add(entity);const moveEntityToCell=(entity,cell)=>{if(!cell)return;const previousType=entity.cell?.entityType||cell.entityType;if(entity.cell)entity.cell.entityType=null;entity.cell=cell;entity.cell.entityType=previousType||entity.type;updateEntityPoint(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach((e)=>moveEntityToCell(e,cell));};const removeEntity=(entity)=>{entity.cell.entityType=null;removeEntityImage(entity);ENTITIES.delete(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach(removeEntity);};const getEntitiesFromCell=(cell)=>{const entities=([]);ENTITIES.forEach((entity)=>{if(entity.cell===cell)entities.push(entity);});return entities;};const createEntity=(cell,id,type,entityParams={})=>{if(entityParams.minTime&&ENTITY_INFO.timeOfDay<entityParams.minTime)return;const entity=({id:`${type}_${id}`,type,connectedEntities:{},currentImgType:cell.block?.biomeType,health:1,...entityParams,});createEntityImage(entity);moveEntityToCell(entity,cell);addEntity(entity);return entity;};const setEntitiesSize=()=>ENTITIES.forEach((e)=>setEntitySize(e));const removeGeneratedEntities=()=>ENTITIES.forEach((e)=>e.isGenerated&&removeEntity(e));const updateEntities=()=>ENTITIES.forEach((e)=>updateEntityPoint(e));const cellIsBlocked=(cell,entity)=>!MENU_CONFIG.debugMode&&(!cell||!cell.block||!!cell.wall||!!cell.entityType||(entity.connectedEntities[ENTITY_TYPES.BOAT]?!cell.block.isFluid:cell.block.isFluid));const getSelectedCell=(entity)=>getCell(getPosByIndex(entity.cell,entity.selectedCellIndex));const updateEntityDirection=(entity,direction)=>{updateEntityImage(entity,direction);Object.values(entity.connectedEntities).forEach((e)=>{updateEntityImage(e,MOVEMENT.RIGHT);});};const makeEntityUse=(entity)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.USING);setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},250);};const updateEntityHealth=(entity)=>{if(entity===PLAYER_ENTITY){if(entity.health>PLAYER_CONFIG.maxHealth)entity.health=PLAYER_CONFIG.maxHealth;updatePlayerHearts();}else if(entity.health<=0)removeEntity(entity);};const giveItemToEntity=(entity,item)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.WINNING);const callback=displayWinAnimation(entity,item.imgPos);if(item.health){entity.health+=item.health;updateEntityHealth(entity);}setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);callback();},1000);};const hurtEntity=(entity,damage)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.LOSING);entity.health-=damage;updateEntityHealth(entity);if(entity.health>0)setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},1000);};const makeEntityRun=(entity,direction)=>{const connectedEntities=Object.values(entity.connectedEntities);if(!connectedEntities.length){updateEntityImage(entity,direction,IMG_MAP_TYPES.RUNNING);return;}updateEntityImage(entity,direction);connectedEntities.forEach((e)=>{updateEntityImage(e,direction);cutEntityImage(e,direction);});};const CUT_MOVEMENTS_MAP={[MOVEMENT.DOWN]:"marginTop",[MOVEMENT.LEFT]:"marginLeft",[MOVEMENT.RIGHT]:"marginRight",[MOVEMENT.UP]:"marginTop",};const container=document.getElementById("entities");const createImageElement=()=>{const img=document.createElement("div");img.className="image";return img;};const createEntityImage=(entity)=>{const img=createImageElement();img.id=entity.id;img.style.zIndex=`${entity.zIndex ||2}`;container.appendChild(img);entity.img=img;setEntitySize(entity);};const displayWinAnimation=(entity,itemPos)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);const img=createImageElement();img.classList.add("won-item");img.style.marginTop=`-${ySide}px`;setImagePos(img,itemPos);container.appendChild(img);setEntityImageSize(img,ySide/2);setImagePoint(img,point,false,ySide/2);return()=>{container.removeChild(img);};};const removeEntityImage=(entity)=>{if(entity.img)container.removeChild(entity.img);entity.img=null;};const updateEntityPoint=(entity,parentPoint)=>{if(!parentPoint&&entity.isConnected)return;const{hasInverted,canvasHeight,canvasWidth}=getPolyInfo();const point=parentPoint||calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);if(isPointOutside(point,canvasHeight,canvasWidth)){if(entity.img)removeEntityImage(entity);}else if(!entity.img){createEntityImage(entity);}if(entity.img)setImagePoint(entity.img,point);verifyEntityHeight(entity);Object.values(entity.connectedEntities).forEach((e)=>updateEntityPoint(e,point));};const updateEntityOpacity=(entity)=>{if(!entity?.img||entity?.deleted)return;entity.img.style.setProperty("--entity-opacity",`${entity.cell.modifier ||1}`);};const getEntitySize=(ySide)=>Math.round((ySide||getPolyInfo().ySide)*2.5);const setImagePos=(img,pos)=>{img.style.setProperty("--entity-position-i",`${pos.i}`);img.style.setProperty("--entity-position-j",`${pos.j}`);};const setEntityImageSize=(img,ySide)=>{if(!img)return;const size=getEntitySize(ySide);img.style.setProperty("--entity-size",`${size}px`);};const setEntitySize=(entity,ySide)=>{if(!entity?.img)return;setEntityImageSize(entity.img,ySide);setEntityImageInfo(entity);};const setEntityImageInfo=(entity)=>{const imgInfo=getEntityImageInfo(entity);if(!imgInfo.src){entity.img.style.removeProperty("--entity-img");entity.img.classList.remove("dont-use-spritesheet");}if(imgInfo.pos){setImagePos(entity.img,imgInfo.pos);}else if(imgInfo.posFn){const pos=imgInfo.posFn(!!entity.leftFootWalk);entity.leftFootWalk=!entity.leftFootWalk;setImagePos(entity.img,pos);}else if(imgInfo.src){entity.img.style.setProperty("--entity-img",`url(${imgInfo.src})`);entity.img.classList.add("dont-use-spritesheet");setImagePos(entity.img,{i:0,j:0});}};const setImagePoint=(img,point,shouldCenter,ySide)=>{if(!point)return;const entitySize=getEntitySize(ySide);img.style.setProperty("--entity-top",`${point.y -entitySize /(shouldCenter ?2 :1.25)}px`);img.style.setProperty("--entity-left",`${point.x -entitySize /2}px`);};const verifyEntityHeight=(entity)=>{if(!entity?.cell||!entity?.img)return;const{hasInverted}=getPolyInfo();const downI=hasInverted&&entity.cell.isInverted?RENDER_INFO.rotationTurns:RENDER_INFO.rotationTurns+Math.floor(RENDER_INFO.currentPoly/2);const downPos=getPosByIndex(entity.cell,downI);const downCell=getCell(downPos);if(!downCell)return;entity.img.classList.remove("not-inverted-both-walls");entity.img.classList.remove("not-inverted-right-wall");entity.img.classList.remove("not-inverted-left-wall");entity.img.classList.remove("behind-wall");if(hasInverted&&!entity.cell.isInverted){const rightCell=downCell;const leftI=RENDER_INFO.rotationTurns+RENDER_INFO.currentPoly-1;const leftPos=getPosByIndex(entity.cell,leftI);const leftCell=getCell(leftPos);if(rightCell.wall&&leftCell.wall){entity.img.classList.add("not-inverted-both-walls");}else if(rightCell.wall){entity.img.classList.add("not-inverted-right-wall");}else if(leftCell.wall){entity.img.classList.add("not-inverted-left-wall");}}else if(downCell.wall){entity.img.classList.add("behind-wall");}if(Object.values(entity.connectedEntities).length)entity.img.classList.add("behind-wall");};const getEntityImageInfo=(entity)=>{const typeMap=ENTITY_IMAGES_MAP[entity.type];const mapType=typeMap[entity.currentImgType]||typeMap[IMG_MAP_TYPES.DEFAULT];return(mapType[entity.currentDirection||MOVEMENT.DOWN]||mapType[MOVEMENT.DOWN]);};const updateEntityImage=(entity,direction,imgMapType)=>{if(!entity?.img)return;entity.currentImgType=imgMapType;entity.currentDirection=direction;setEntityImageInfo(entity);entity.img.style.marginTop=null;entity.img.style.marginLeft=null;entity.img.style.marginRight=null;};const cutEntityImage=(entity,direction)=>{if(entity.movementsToCut?.length){if(entity.movementsToCut.includes(direction)){const{ySide}=getPolyInfo();entity.img.style[CUT_MOVEMENTS_MAP[direction]]=`${ySide}px`;}}};const playerHealthContainer=document.getElementById("health-container");const updatePlayerHearts=()=>{playerHealthContainer.innerHTML="";let curretnHealth=PLAYER_ENTITY.health;for(let i=0;i<PLAYER_CONFIG.maxHealth;i++){const heartImg=createImageElement();if(curretnHealth){setImagePos(heartImg,{i:2,j:3});heartImg.classList.add("filled");curretnHealth--;}else{setImagePos(heartImg,{i:2,j:2});}playerHealthContainer.appendChild(heartImg);}};updatePlayerHearts();const GENERATION_CONFIG={chunkSize:50,};const getRange=(n,range)=>Math.floor(n/range)*range;const getChunkStart=(pos,height,width)=>({i:getRange(pos.i,height),j:getRange(pos.j,width),});const hexToRgb=(hexColor)=>{let hex=hexColor.trim().slice(1);let r=parseInt(hex.substring(0,2),16);let g=parseInt(hex.substring(2,4),16);let b=parseInt(hex.substring(4,6),16);return{r,g,b};};const TRACK_TYPES={TRACK1:"TRACK1",TRACK2:"TRACK2",TRACK3:"TRACK3",TRACK4:"TRACK4",TRACK5:"TRACK5",TRACK6:"TRACK6",TRACK7:"TRACK7",TRACK8:"TRACK8",TRACK9:"TRACK9",TRACK11:"TRACK11",TRACK10:"TRACK10",TRACK12:"TRACK12",TRACK13:"TRACK13",TRACK14:"TRACK14",TRACK15:"TRACK15",TRACK16:"TRACK16",};const ENEMY_SPAWN={probability:0.00001,entityType:ENTITY_TYPES.ENEMY,spawnOnMove:true,increaseWithTime:true,};const WATER_SPAWNS=[{probability:0.0005,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const FOREST_SPAWNS=[{probability:0.01,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const SNOW_PROPS={biomeType:BIOME_TYPES.SNOW,spawnableEntities:[{probability:0.01,entityType:ENTITY_TYPES.TREE},ENEMY_SPAWN,],};const DESERT_PROPS={biomeType:BIOME_TYPES.DESERT,spawnableEntities:[{probability:0.001,entityType:ENTITY_TYPES.TREE},{...ENEMY_SPAWN,probability:0.00005,},],};const EMPTY_BLOCK=({layer:0,color:{r:-1,g:-1,b:-1},});const BLOCKS=({DEEP_WATER:{name:"DEEP_WATER",color:hexToRgb("#256299"),layer:0,isFluid:true,spawnableEntities:WATER_SPAWNS,trackType:TRACK_TYPES.TRACK5,},WATER:{name:"WATER",color:hexToRgb("#2375b4"),layer:0,isFluid:true,trackType:TRACK_TYPES.TRACK4,},LOW_GRASS:{name:"LOW_GRASS",color:hexToRgb("#457950"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK2,},MID_GRASS:{name:"MID_GRASS",color:hexToRgb("#2d673e"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK1,},HIGH_GRASS:{name:"HIGH_GRASS",color:hexToRgb("#2d673e"),layer:1,trackType:TRACK_TYPES.TRACK1,},DIRT:{name:"DIRT",color:hexToRgb("#3F573A"),layer:1,trackType:TRACK_TYPES.TRACK6,},ROCK:{name:"ROCK",color:hexToRgb("#CBC0BB"),layer:1,},BEACH_SAND:{name:"BEACH_SAND",color:hexToRgb("#ab976a"),layer:0,spawnableEntities:[ENEMY_SPAWN],trackType:TRACK_TYPES.TRACK3,},FROZEN_WATER:{name:"FROZEN_WATER",color:hexToRgb("#94F2F4"),layer:0,trackType:TRACK_TYPES.TRACK11,...SNOW_PROPS,},FROZEN_SEA_SHORE:{name:"FROZEN_SEA_SHORE",color:hexToRgb("#A0E6EC"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},SLUSH:{name:"SLUSH",color:hexToRgb("#D0ECEB"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},ICE:{name:"ICE",color:hexToRgb("#ECFFFD"),layer:0,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},HIGH_ICE:{name:"HIGH_ICE",color:hexToRgb("#ECFFFD"),layer:1,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},DUST:{name:"DUST",color:hexToRgb("#DAA98B"),layer:0,trackType:TRACK_TYPES.TRACK16,...DESERT_PROPS,},SAND:{name:"SAND",color:hexToRgb("#EC912E"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},DARK_SAND:{name:"DARK_SAND",color:hexToRgb("#CC7025"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},TERRACOTA:{name:"TERRACOTA",color:hexToRgb("#9F561A"),layer:0,trackType:TRACK_TYPES.TRACK15,...DESERT_PROPS,},HIGH_TERRACOTA:{name:"HIGH_TERRACOTA",color:hexToRgb("#9F561A"),layer:1,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},});const isCellInverted=({i,j})=>(i+j)%2!==0;const getAdjacentPos=({i,j},isInverted)=>{return{[KNOWN_POLYGONS.TRIANGLE]:isInverted?[{i:i+1,j},{i,j:j-1},{i,j:j+1},]:[{i:i-1,j},{i,j:j+1},{i,j:j-1},],[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j},{i,j:j+1},{i:i+1,j},{i,j:j-1},],[KNOWN_POLYGONS.HEXAGON]:j%2?[{i:i-1,j},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},]:[{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j},{i,j:j-1},{i:i-1,j:j-1},],};};const getAdjacentPosWithCorners=({i,j},isInverted)=>{return{...getAdjacentPos({i,j},isInverted),[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j:j-1},{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},],};};const createCellProps=(pos)=>{const isInverted=isCellInverted(pos);return{pos,isInverted,adjacentPos:getAdjacentPos(pos,isInverted),adjacentPosWithCorners:getAdjacentPosWithCorners(pos,isInverted),};};const createCell=(pos,block)=>{let cell=getCell(pos);if(!cell){cell=({});cell.entityType=null;if(block){cell.block=block;cell.layer=block.layer;cell.color=tweakColor(block.color);}}return{...createCellProps(pos),...cell};};const createEntitiesForCell=(cell,onMove=false)=>{if(!cell.block.spawnableEntities?.length)return;for(const sEntity of cell.block.spawnableEntities){const canSpawn=onMove?sEntity.spawnOnMove:!sEntity.spawnOnMove;if(!canSpawn)continue;let probability=sEntity.probability;if(sEntity.increaseWithTime)probability*=ENTITY_INFO.timeOfDay/2;if(Math.random()<probability){spawnEntity(sEntity.entityType,cell);return;}}};const getBiome=(pos)=>{switch(MENU_CONFIG.mapGeneration){case MAP_GENERATION.MIX:const biomeValue=getValue(pos.i,pos.j,PERLIN_VECTORS.BIOME);return BIOMES.find((b)=>biomeValue>=b.minValue);default:case MAP_GENERATION.DISTANCE:const distance=getPosDistance(INITIAL_POS,pos);return BIOMES.filter((b)=>(b.negativeJ===undefined||b.negativeJ===pos.j<0)&&(b.negativeI===undefined||b.negativeI===pos.i<0)).find((b)=>distance>=b.minDistance);}};const loadChunk=(initialPos)=>{const offsetPos=getChunkStart(initialPos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const biomeMap=({});let minesObj=(null);for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){const nI=i+offsetPos.i;for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){const nJ=j+offsetPos.j;const pos={i:nI,j:nJ};const biome=minesObj?MINE_BIOMES.MINES:getBiome(pos);biomeMap[biome.name]=(biomeMap[biome.name]||0)+1;const value=getValue(nI,nJ,PERLIN_VECTORS.BLOCK);const originalBlock=biome.ranges.find((r)=>value<=r.max);const isHighBlock=originalBlock.layer>0;const cellBlock=isHighBlock?biome.higherGroundBlock:originalBlock;const cell=createCell(pos,cellBlock);if(minesObj)cell.hasBomb=minesObj.isBomb({i,j});addCell(pos,cell);if(isHighBlock)cell.wall={block:originalBlock,color:tweakColor(originalBlock.color),};else createEntitiesForCell(cell);}}const biomeName=Object.entries(biomeMap).sort(([_,a],[__,b])=>b-a)[0][0];addBiomeToMap(offsetPos,BIOMES.find((b)=>b.name===biomeName));};const loadAndGetCell=(pos)=>{if(!getCell(pos))loadChunk(pos);return getCell(pos);};const getCenterCell=()=>{const{rows,columns}=getPolyInfo();const{iOffset,jOffset}=RENDER_INFO;const i=Math.floor(rows/2)+iOffset;const j=Math.floor(columns/2)+jOffset;return loadAndGetCell({i,j});};const getBorderCells=(baseCell)=>{const{rows,columns}=getPolyInfo();const halfR=Math.floor(rows/2);const halfC=Math.floor(columns/2);const{i,j}=baseCell.pos;const tI=i-halfR;const bI=i+halfR;const lJ=j-halfC;const rJ=j+halfC;const positions=([]);for(let index=lJ;index<=rJ;index++){positions.push({i:tI,j:index});positions.push({i:bI,j:index});}for(let index=tI;index<=bI;index++){positions.push({i:index,j:lJ});positions.push({i:index,j:rJ});}return positions.map(getCell);};const spawnEntities=(baseCell)=>{getBorderCells(baseCell).forEach((cell)=>{if(!!cell?.block&&!cell.wall&&!cell.entityType)createEntitiesForCell(cell,true);});};const destroyWall=(cell)=>{const onDestroy=cell.wall?.block?.onDestroy;if(cell.wall){cell.wall=null;}if(onDestroy)onDestroy(cell);};const addPropsToBlock=(block,props)=>({...block,...props});const BIOMES_RAW=({FOREST:{name:"FOREST",mapColor:BLOCKS.MID_GRASS.color,minValue:-1,minDistance:0,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.WATER,{max:-0.4}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:-0.2}),addPropsToBlock(BLOCKS.MID_GRASS,{max:0.4}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.5}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},OCEAN:{name:"OCEAN",mapColor:BLOCKS.WATER.color,minValue:-0.2,minDistance:75,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.DEEP_WATER,{max:-0.1}),addPropsToBlock(BLOCKS.WATER,{max:0.3}),addPropsToBlock(BLOCKS.BEACH_SAND,{max:0.5}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:0.7}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.8}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},SNOW:{name:"SNOW",mapColor:BLOCKS.ICE.color,minValue:0.2,minDistance:150,higherGroundBlock:BLOCKS.ICE,negativeJ:false,ranges:[addPropsToBlock(BLOCKS.FROZEN_WATER,{max:-0.2}),addPropsToBlock(BLOCKS.FROZEN_SEA_SHORE,{max:0}),addPropsToBlock(BLOCKS.SLUSH,{max:0.1}),addPropsToBlock(BLOCKS.HIGH_ICE,{max:1}),],},DESERT:{name:"DESERT",mapColor:BLOCKS.SAND.color,minValue:0,minDistance:150,higherGroundBlock:BLOCKS.TERRACOTA,negativeJ:true,ranges:[addPropsToBlock(BLOCKS.DUST,{max:-0.4}),addPropsToBlock(BLOCKS.SAND,{max:-0.2}),addPropsToBlock(BLOCKS.DARK_SAND,{max:0}),addPropsToBlock(BLOCKS.TERRACOTA,{max:0.2}),addPropsToBlock(BLOCKS.HIGH_TERRACOTA,{max:1}),],},});const BIOMES=Object.values(BIOMES_RAW).sort((a,b)=>b.minDistance-a.minDistance);let BIOME_MAPS=([]);const resetBiomes=()=>(BIOME_MAPS=[]);const getPosBiomeOffset=({i,j})=>({i:i/GENERATION_CONFIG.chunkSize,j:j/GENERATION_CONFIG.chunkSize,});const addBiomeToMap=(pos,biome)=>{const{i,j}=getPosBiomeOffset(pos);if(!BIOME_MAPS[i])BIOME_MAPS[i]=[];if(BIOME_MAPS[i][j])return;BIOME_MAPS[i][j]=biome;};const getBiomeFromMap=(pos)=>{pos=getChunkStart(pos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const{i,j}=getPosBiomeOffset(pos);return BIOME_MAPS[i]?.[j];};const getBiomeMap=()=>BIOME_MAPS;const isCellInverted=({i,j})=>(i+j)%2!==0;const getAdjacentPos=({i,j},isInverted)=>{return{[KNOWN_POLYGONS.TRIANGLE]:isInverted?[{i:i+1,j},{i,j:j-1},{i,j:j+1},]:[{i:i-1,j},{i,j:j+1},{i,j:j-1},],[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j},{i,j:j+1},{i:i+1,j},{i,j:j-1},],[KNOWN_POLYGONS.HEXAGON]:j%2?[{i:i-1,j},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},]:[{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j},{i,j:j-1},{i:i-1,j:j-1},],};};const getAdjacentPosWithCorners=({i,j},isInverted)=>{return{...getAdjacentPos({i,j},isInverted),[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j:j-1},{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},],};};const createCellProps=(pos)=>{const isInverted=isCellInverted(pos);return{pos,isInverted,adjacentPos:getAdjacentPos(pos,isInverted),adjacentPosWithCorners:getAdjacentPosWithCorners(pos,isInverted),};};const createCell=(pos,block)=>{let cell=getCell(pos);if(!cell){cell=({});cell.entityType=null;if(block){cell.block=block;cell.layer=block.layer;cell.color=tweakColor(block.color);}}return{...createCellProps(pos),...cell};};const createEntitiesForCell=(cell,onMove=false)=>{if(!cell.block.spawnableEntities?.length)return;for(const sEntity of cell.block.spawnableEntities){const canSpawn=onMove?sEntity.spawnOnMove:!sEntity.spawnOnMove;if(!canSpawn)continue;let probability=sEntity.probability;if(sEntity.increaseWithTime)probability*=ENTITY_INFO.timeOfDay/2;if(Math.random()<probability){spawnEntity(sEntity.entityType,cell);return;}}};const getBiome=(pos)=>{switch(MENU_CONFIG.mapGeneration){case MAP_GENERATION.MIX:const biomeValue=getValue(pos.i,pos.j,PERLIN_VECTORS.BIOME);return BIOMES.find((b)=>biomeValue>=b.minValue);default:case MAP_GENERATION.DISTANCE:const distance=getPosDistance(INITIAL_POS,pos);return BIOMES.filter((b)=>(b.negativeJ===undefined||b.negativeJ===pos.j<0)&&(b.negativeI===undefined||b.negativeI===pos.i<0)).find((b)=>distance>=b.minDistance);}};const loadChunk=(initialPos)=>{const offsetPos=getChunkStart(initialPos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const biomeMap=({});let minesObj=(null);for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){const nI=i+offsetPos.i;for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){const nJ=j+offsetPos.j;const pos={i:nI,j:nJ};const biome=minesObj?MINE_BIOMES.MINES:getBiome(pos);biomeMap[biome.name]=(biomeMap[biome.name]||0)+1;const value=getValue(nI,nJ,PERLIN_VECTORS.BLOCK);const originalBlock=biome.ranges.find((r)=>value<=r.max);const isHighBlock=originalBlock.layer>0;const cellBlock=isHighBlock?biome.higherGroundBlock:originalBlock;const cell=createCell(pos,cellBlock);if(minesObj)cell.hasBomb=minesObj.isBomb({i,j});addCell(pos,cell);if(isHighBlock)cell.wall={block:originalBlock,color:tweakColor(originalBlock.color),};else createEntitiesForCell(cell);}}const biomeName=Object.entries(biomeMap).sort(([_,a],[__,b])=>b-a)[0][0];addBiomeToMap(offsetPos,BIOMES.find((b)=>b.name===biomeName));};const loadAndGetCell=(pos)=>{if(!getCell(pos))loadChunk(pos);return getCell(pos);};const getCenterCell=()=>{const{rows,columns}=getPolyInfo();const{iOffset,jOffset}=RENDER_INFO;const i=Math.floor(rows/2)+iOffset;const j=Math.floor(columns/2)+jOffset;return loadAndGetCell({i,j});};const getBorderCells=(baseCell)=>{const{rows,columns}=getPolyInfo();const halfR=Math.floor(rows/2);const halfC=Math.floor(columns/2);const{i,j}=baseCell.pos;const tI=i-halfR;const bI=i+halfR;const lJ=j-halfC;const rJ=j+halfC;const positions=([]);for(let index=lJ;index<=rJ;index++){positions.push({i:tI,j:index});positions.push({i:bI,j:index});}for(let index=tI;index<=bI;index++){positions.push({i:index,j:lJ});positions.push({i:index,j:rJ});}return positions.map(getCell);};const spawnEntities=(baseCell)=>{getBorderCells(baseCell).forEach((cell)=>{if(!!cell?.block&&!cell.wall&&!cell.entityType)createEntitiesForCell(cell,true);});};const destroyWall=(cell)=>{const onDestroy=cell.wall?.block?.onDestroy;if(cell.wall){cell.wall=null;}if(onDestroy)onDestroy(cell);};const createMinesObj=()=>{const minefield=([]);const MINES_CONFIG={bombsNum:Math.round(GENERATION_CONFIG.chunkSize**2/4),};const createField=()=>{for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){minefield[i]=[];for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){minefield[i][j]=false;}}};const getIndexForBomb=()=>{const limit=GENERATION_CONFIG.chunkSize-2;return Math.floor(Math.random()*limit)+1;};const addBomb=()=>{const row=getIndexForBomb();const column=getIndexForBomb();if(minefield[row][column])return false;minefield[row][column]=true;return true;};const addBombs=()=>{for(let i=0;i<MINES_CONFIG.bombsNum;i++){if(!addBomb())i--;}};createField();addBombs();return{isBomb:(pos)=>minefield[pos.i][pos.j],};};const MINE_BLOCKS=({MINES_LOW:{name:"MINES_LOW",color:hexToRgb("#d3d3d3"),layer:0,indestructible:true,isFluid:false,},MINES_HIGH:{name:"MINES_HIGH",color:hexToRgb("#d3d3d3"),layer:1,isFluid:false,onDestroy:(cell)=>{const aCells=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);const isNextToBomb=!!aCells.find((c)=>c.hasBomb);if(isNextToBomb)return;cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell).filter((c)=>c.wall?.block?.name==="MINES_HIGH"&&!c.hasBomb).forEach((c)=>{const onDestroy=c.wall.block.onDestroy;c.wall=null;onDestroy(c);});},},});const MINE_BIOMES=({MINES:{name:"MINES",mapColor:MINE_BLOCKS.MINES_LOW.color,minValue:-1,minDistance:0,higherGroundBlock:MINE_BLOCKS.MINES_LOW,ranges:[addPropsToBlock(MINE_BLOCKS.MINES_HIGH,{max:1})],},});const createMazeObj=(mazeInfos,mazeCircleInfos)=>{let MAZE_GRID=([]);const MAZE_POLYS_INFO=({});const getMazePolyInfo=()=>MAZE_POLYS_INFO[RENDER_INFO.currentPoly];const CIRCLE_INFO=({cellHeight:0,center:null,rows:0,columns:0,});const MAZE_INFO=({rows:0,columns:0,isCircle:false,currentCell:null,queue:[],});const getMazeCell=({i,j})=>MAZE_GRID[i]?.[j];function*iterateOverMaze(){const rows=getMazeRows();for(let i=0;i<rows;i++){const numCells=getNumCellsPerMazeRow(i);for(let j=0;j<numCells;j++){yield{i,j};}}}const createMazeGrid=()=>{MAZE_GRID=[];for(const{i,j}of iterateOverMaze()){MAZE_GRID[i]=MAZE_GRID[i]||[];MAZE_GRID[i][j]=createCellMaze({i,j});}};const createCellMaze=(pos)=>{const cell=(createCellProps(pos));cell.visited=false;cell.solved=false;cell.path=false;cell.borders=[...new Array(RENDER_INFO.currentPoly)].map(()=>true);if(MAZE_INFO.isCircle)createCircleCellMaze(cell);else cell.point=calculateMazePoint(pos);return cell;};const calculateMazePoint=({i,j})=>{const{calcX,calcY,ySide,shouldIntercalate}=getMazePolyInfo();const x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=ySide;return{x,y};};const getMazeRows=()=>MAZE_INFO.isCircle?CIRCLE_INFO.rows:MAZE_INFO.rows;const getNumCellsPerMazeRow=(rowIndex)=>MAZE_INFO.isCircle?CIRCLE_INFO.columns-Math.floor((rowIndex+1)/2):MAZE_INFO.columns;const createCircleCellMaze=(cell)=>{const{i,j}=cell.pos;const topRadius=(CIRCLE_INFO.rows-i)*CIRCLE_INFO.cellHeight;const bottomRadius=topRadius-CIRCLE_INFO.cellHeight;const topAngle=Math.atan2(-topRadius,0);const bottomAngle=bottomRadius?topAngle:0;const numCells=getNumCellsPerMazeRow(i);const parts=(Math.PI*1.5-topAngle)/numCells;const leftBorder=j*parts;const rightBorder=(j+1)*parts;const topLeftAngle=topAngle+leftBorder;const topRightAngle=topAngle+rightBorder;const bottomLeftAngle=bottomAngle+leftBorder;const bottomRightAngle=bottomAngle+rightBorder;const topLeftPoint=getMazePoint(topRadius,topLeftAngle);const topRightPoint=getMazePoint(topRadius,topRightAngle);const bottomLeftPoint=getMazePoint(bottomRadius,bottomLeftAngle);const bottomRightPoint=getMazePoint(bottomRadius,bottomRightAngle);const points=[getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topLeftAngle),getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topRightAngle),];const x=points.reduce((acc,p)=>acc+p.x,0)/points.length;const y=points.reduce((acc,p)=>acc+p.y,0)/points.length;cell.point={x,y};cell.circleProps={topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topRadius,bottomRadius,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,adjacentPos:cell.adjacentPos[KNOWN_POLYGONS.SQUARE].map((aPos)=>({i:aPos.i,j:aPos.j<0?numCells-1:aPos.j>=numCells?0:aPos.j,})),};};const getMazePoint=(radius,angle)=>({x:CIRCLE_INFO.center.x+Math.cos(angle)*radius,y:CIRCLE_INFO.center.y+Math.sin(angle)*radius,});const buildMaze=()=>{createMazeGrid();MAZE_INFO.queue=[];MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);const lastCell=getLastMazeCell();while(MAZE_INFO.currentCell)MAZE_INFO.currentCell=buildCellMaze(MAZE_INFO.currentCell,lastCell);if(!MAZE_INFO.isCircle&&lastCell){openBorderForCellMaze(lastCell,getMazeCell(getAdjPos(lastCell)[0]));lastCell.visited=true;}if(!MAZE_INFO.isCircle&&getMazePolyInfo().hasInverted){for(const pos of iterateOverMaze()){const cell=getMazeCell(pos);cell.invertedBorders=[...cell.borders].reverse();}}MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const openBorderForCellMaze=(cell,nextCell)=>{const adjacentIndex=getNextCellMazeAdjacentIndex(cell,nextCell);const nextAdjacentIndex=getNextCellMazeAdjacentIndex(nextCell,cell);cell.borders[adjacentIndex]=false;nextCell.borders[nextAdjacentIndex]=false;};const buildCellMaze=(cell,lastCell)=>{cell.visited=true;const nextCell=getNextCellMaze(cell,(c)=>!!c&&!c.visited&&c!==lastCell,true);if(!nextCell)return null;openBorderForCellMaze(cell,nextCell);return nextCell;};const getLastMazeCell=()=>getMazeCell({i:MAZE_INFO.rows-1,j:MAZE_INFO.columns-1});const isMazeSolved=()=>!MAZE_INFO.currentCell||(MAZE_INFO.isCircle?MAZE_INFO.currentCell.pos.i===CIRCLE_INFO.rows-1:MAZE_INFO.currentCell===getLastMazeCell());const solveMaze=()=>{while(!isMazeSolved())MAZE_INFO.currentCell=solveCellMaze(MAZE_INFO.currentCell);solveCellMaze(MAZE_INFO.currentCell);MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const solveCellMaze=(cell)=>{if(!cell)return;cell.solved=true;cell.path=true;const prevLength=MAZE_INFO.queue.length;const nextCell=getNextCellMaze(cell,(c)=>{if(!c||c.solved)return false;const nextIndex=getNextCellMazeAdjacentIndex(cell,c);return!cell.borders[nextIndex];});if(prevLength>MAZE_INFO.queue.length)cell.path=false;return nextCell;};const getAdjPos=(cell)=>cell.circleProps?.adjacentPos||cell.adjacentPos[RENDER_INFO.currentPoly];const getNextCellMaze=(cell,cellFilter,isRandom=false)=>{const adjacentPos=getAdjPos(cell);const aCells=adjacentPos.map(getMazeCell).filter(cellFilter);if(!aCells.length){if(!MAZE_INFO.queue.length)return null;const prevPos=MAZE_INFO.queue.pop();return getMazeCell(prevPos);}MAZE_INFO.queue.push(cell.pos);return aCells[isRandom?getRandomInt(aCells.length):aCells.length-1];};const getNextCellMazeAdjacentIndex=(cell,nextCell)=>{let nextIndex=0;const adjacentPos=getAdjPos(cell);while(nextIndex<adjacentPos.length){const{i,j}=adjacentPos[nextIndex];if(nextCell.pos.i===i&&nextCell.pos.j===j)break;nextIndex++;}return nextIndex;};const mazeMove=(posIndex)=>{if(posIndex===undefined||MAZE_INFO.currentCell.borders[posIndex])return;const nextPos=getAdjPos(MAZE_INFO.currentCell)[posIndex];if(!nextPos)return;const nextCell=getMazeCell(nextPos);if(!nextCell)return;const oldCell=MAZE_INFO.currentCell;MAZE_INFO.currentCell=nextCell;const prevCell=MAZE_INFO.queue[MAZE_INFO.queue.length-1];if(nextCell.pos===prevCell){oldCell.path=false;MAZE_INFO.queue.pop();}else{oldCell.path=true;MAZE_INFO.queue.push(oldCell.pos);}return MAZE_INFO.currentCell;};const initMaze=()=>{for(const p of KNOWN_POLYGONS_VALUES){MAZE_POLYS_INFO[p]=configPoly(p,mazeInfos.cellHeight);}MAZE_INFO.rows=mazeInfos.rows;MAZE_INFO.columns=mazeInfos.columns;CIRCLE_INFO.cellHeight=mazeCircleInfos?.cellHeight||mazeInfos.cellHeight;CIRCLE_INFO.rows=mazeCircleInfos?.rows||MAZE_INFO.rows*2;CIRCLE_INFO.columns=mazeCircleInfos?.columns||MAZE_INFO.columns*2;const center=(CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2)/2;CIRCLE_INFO.center={x:center,y:center};};const getMazeSize=()=>{let{ySide,xSide,shouldIntercalate,hasInverted,polySide}=getMazePolyInfo();let height=MAZE_INFO.rows*mazeInfos.cellHeight;let width=MAZE_INFO.columns*(xSide*2);if(MAZE_INFO.isCircle)height=width=CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2;else{if(hasInverted)width=(MAZE_INFO.columns*polySide)/2+polySide/2+2;if(shouldIntercalate){height+=ySide;width=width*0.8;}}return{height,width};};const setIsCircle=(isCircle)=>{MAZE_INFO.isCircle=isCircle;if(MAZE_INFO.isCircle)RENDER_INFO.currentPoly=KNOWN_POLYGONS.SQUARE;};initMaze();return{getMazeSize,mazeMove,buildMaze,solveMaze,isMazeSolved,setIsCircle,getCirclePoint:()=>CIRCLE_INFO.center,iterateOverMaze,getMazeCell,getCurrentMazeCell:()=>MAZE_INFO.currentCell,getLastMazeCell,getMazePolyInfo,};};const isCellInverted=({i,j})=>(i+j)%2!==0;const getAdjacentPos=({i,j},isInverted)=>{return{[KNOWN_POLYGONS.TRIANGLE]:isInverted?[{i:i+1,j},{i,j:j-1},{i,j:j+1},]:[{i:i-1,j},{i,j:j+1},{i,j:j-1},],[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j},{i,j:j+1},{i:i+1,j},{i,j:j-1},],[KNOWN_POLYGONS.HEXAGON]:j%2?[{i:i-1,j},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},]:[{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j},{i,j:j-1},{i:i-1,j:j-1},],};};const getAdjacentPosWithCorners=({i,j},isInverted)=>{return{...getAdjacentPos({i,j},isInverted),[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j:j-1},{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},],};};const createCellProps=(pos)=>{const isInverted=isCellInverted(pos);return{pos,isInverted,adjacentPos:getAdjacentPos(pos,isInverted),adjacentPosWithCorners:getAdjacentPosWithCorners(pos,isInverted),};};const createCell=(pos,block)=>{let cell=getCell(pos);if(!cell){cell=({});cell.entityType=null;if(block){cell.block=block;cell.layer=block.layer;cell.color=tweakColor(block.color);}}return{...createCellProps(pos),...cell};};const createEntitiesForCell=(cell,onMove=false)=>{if(!cell.block.spawnableEntities?.length)return;for(const sEntity of cell.block.spawnableEntities){const canSpawn=onMove?sEntity.spawnOnMove:!sEntity.spawnOnMove;if(!canSpawn)continue;let probability=sEntity.probability;if(sEntity.increaseWithTime)probability*=ENTITY_INFO.timeOfDay/2;if(Math.random()<probability){spawnEntity(sEntity.entityType,cell);return;}}};const getBiome=(pos)=>{switch(MENU_CONFIG.mapGeneration){case MAP_GENERATION.MIX:const biomeValue=getValue(pos.i,pos.j,PERLIN_VECTORS.BIOME);return BIOMES.find((b)=>biomeValue>=b.minValue);default:case MAP_GENERATION.DISTANCE:const distance=getPosDistance(INITIAL_POS,pos);return BIOMES.filter((b)=>(b.negativeJ===undefined||b.negativeJ===pos.j<0)&&(b.negativeI===undefined||b.negativeI===pos.i<0)).find((b)=>distance>=b.minDistance);}};const loadChunk=(initialPos)=>{const offsetPos=getChunkStart(initialPos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const biomeMap=({});let minesObj=(null);for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){const nI=i+offsetPos.i;for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){const nJ=j+offsetPos.j;const pos={i:nI,j:nJ};const biome=minesObj?MINE_BIOMES.MINES:getBiome(pos);biomeMap[biome.name]=(biomeMap[biome.name]||0)+1;const value=getValue(nI,nJ,PERLIN_VECTORS.BLOCK);const originalBlock=biome.ranges.find((r)=>value<=r.max);const isHighBlock=originalBlock.layer>0;const cellBlock=isHighBlock?biome.higherGroundBlock:originalBlock;const cell=createCell(pos,cellBlock);if(minesObj)cell.hasBomb=minesObj.isBomb({i,j});addCell(pos,cell);if(isHighBlock)cell.wall={block:originalBlock,color:tweakColor(originalBlock.color),};else createEntitiesForCell(cell);}}const biomeName=Object.entries(biomeMap).sort(([_,a],[__,b])=>b-a)[0][0];addBiomeToMap(offsetPos,BIOMES.find((b)=>b.name===biomeName));};const loadAndGetCell=(pos)=>{if(!getCell(pos))loadChunk(pos);return getCell(pos);};const getCenterCell=()=>{const{rows,columns}=getPolyInfo();const{iOffset,jOffset}=RENDER_INFO;const i=Math.floor(rows/2)+iOffset;const j=Math.floor(columns/2)+jOffset;return loadAndGetCell({i,j});};const getBorderCells=(baseCell)=>{const{rows,columns}=getPolyInfo();const halfR=Math.floor(rows/2);const halfC=Math.floor(columns/2);const{i,j}=baseCell.pos;const tI=i-halfR;const bI=i+halfR;const lJ=j-halfC;const rJ=j+halfC;const positions=([]);for(let index=lJ;index<=rJ;index++){positions.push({i:tI,j:index});positions.push({i:bI,j:index});}for(let index=tI;index<=bI;index++){positions.push({i:index,j:lJ});positions.push({i:index,j:rJ});}return positions.map(getCell);};const spawnEntities=(baseCell)=>{getBorderCells(baseCell).forEach((cell)=>{if(!!cell?.block&&!cell.wall&&!cell.entityType)createEntitiesForCell(cell,true);});};const destroyWall=(cell)=>{const onDestroy=cell.wall?.block?.onDestroy;if(cell.wall){cell.wall=null;}if(onDestroy)onDestroy(cell);};const createMazeObj=(mazeInfos,mazeCircleInfos)=>{let MAZE_GRID=([]);const MAZE_POLYS_INFO=({});const getMazePolyInfo=()=>MAZE_POLYS_INFO[RENDER_INFO.currentPoly];const CIRCLE_INFO=({cellHeight:0,center:null,rows:0,columns:0,});const MAZE_INFO=({rows:0,columns:0,isCircle:false,currentCell:null,queue:[],});const getMazeCell=({i,j})=>MAZE_GRID[i]?.[j];function*iterateOverMaze(){const rows=getMazeRows();for(let i=0;i<rows;i++){const numCells=getNumCellsPerMazeRow(i);for(let j=0;j<numCells;j++){yield{i,j};}}}const createMazeGrid=()=>{MAZE_GRID=[];for(const{i,j}of iterateOverMaze()){MAZE_GRID[i]=MAZE_GRID[i]||[];MAZE_GRID[i][j]=createCellMaze({i,j});}};const createCellMaze=(pos)=>{const cell=(createCellProps(pos));cell.visited=false;cell.solved=false;cell.path=false;cell.borders=[...new Array(RENDER_INFO.currentPoly)].map(()=>true);if(MAZE_INFO.isCircle)createCircleCellMaze(cell);else cell.point=calculateMazePoint(pos);return cell;};const calculateMazePoint=({i,j})=>{const{calcX,calcY,ySide,shouldIntercalate}=getMazePolyInfo();const x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=ySide;return{x,y};};const getMazeRows=()=>MAZE_INFO.isCircle?CIRCLE_INFO.rows:MAZE_INFO.rows;const getNumCellsPerMazeRow=(rowIndex)=>MAZE_INFO.isCircle?CIRCLE_INFO.columns-Math.floor((rowIndex+1)/2):MAZE_INFO.columns;const createCircleCellMaze=(cell)=>{const{i,j}=cell.pos;const topRadius=(CIRCLE_INFO.rows-i)*CIRCLE_INFO.cellHeight;const bottomRadius=topRadius-CIRCLE_INFO.cellHeight;const topAngle=Math.atan2(-topRadius,0);const bottomAngle=bottomRadius?topAngle:0;const numCells=getNumCellsPerMazeRow(i);const parts=(Math.PI*1.5-topAngle)/numCells;const leftBorder=j*parts;const rightBorder=(j+1)*parts;const topLeftAngle=topAngle+leftBorder;const topRightAngle=topAngle+rightBorder;const bottomLeftAngle=bottomAngle+leftBorder;const bottomRightAngle=bottomAngle+rightBorder;const topLeftPoint=getMazePoint(topRadius,topLeftAngle);const topRightPoint=getMazePoint(topRadius,topRightAngle);const bottomLeftPoint=getMazePoint(bottomRadius,bottomLeftAngle);const bottomRightPoint=getMazePoint(bottomRadius,bottomRightAngle);const points=[getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topLeftAngle),getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topRightAngle),];const x=points.reduce((acc,p)=>acc+p.x,0)/points.length;const y=points.reduce((acc,p)=>acc+p.y,0)/points.length;cell.point={x,y};cell.circleProps={topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topRadius,bottomRadius,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,adjacentPos:cell.adjacentPos[KNOWN_POLYGONS.SQUARE].map((aPos)=>({i:aPos.i,j:aPos.j<0?numCells-1:aPos.j>=numCells?0:aPos.j,})),};};const getMazePoint=(radius,angle)=>({x:CIRCLE_INFO.center.x+Math.cos(angle)*radius,y:CIRCLE_INFO.center.y+Math.sin(angle)*radius,});const buildMaze=()=>{createMazeGrid();MAZE_INFO.queue=[];MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);const lastCell=getLastMazeCell();while(MAZE_INFO.currentCell)MAZE_INFO.currentCell=buildCellMaze(MAZE_INFO.currentCell,lastCell);if(!MAZE_INFO.isCircle&&lastCell){openBorderForCellMaze(lastCell,getMazeCell(getAdjPos(lastCell)[0]));lastCell.visited=true;}if(!MAZE_INFO.isCircle&&getMazePolyInfo().hasInverted){for(const pos of iterateOverMaze()){const cell=getMazeCell(pos);cell.invertedBorders=[...cell.borders].reverse();}}MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const openBorderForCellMaze=(cell,nextCell)=>{const adjacentIndex=getNextCellMazeAdjacentIndex(cell,nextCell);const nextAdjacentIndex=getNextCellMazeAdjacentIndex(nextCell,cell);cell.borders[adjacentIndex]=false;nextCell.borders[nextAdjacentIndex]=false;};const buildCellMaze=(cell,lastCell)=>{cell.visited=true;const nextCell=getNextCellMaze(cell,(c)=>!!c&&!c.visited&&c!==lastCell,true);if(!nextCell)return null;openBorderForCellMaze(cell,nextCell);return nextCell;};const getLastMazeCell=()=>getMazeCell({i:MAZE_INFO.rows-1,j:MAZE_INFO.columns-1});const isMazeSolved=()=>!MAZE_INFO.currentCell||(MAZE_INFO.isCircle?MAZE_INFO.currentCell.pos.i===CIRCLE_INFO.rows-1:MAZE_INFO.currentCell===getLastMazeCell());const solveMaze=()=>{while(!isMazeSolved())MAZE_INFO.currentCell=solveCellMaze(MAZE_INFO.currentCell);solveCellMaze(MAZE_INFO.currentCell);MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const solveCellMaze=(cell)=>{if(!cell)return;cell.solved=true;cell.path=true;const prevLength=MAZE_INFO.queue.length;const nextCell=getNextCellMaze(cell,(c)=>{if(!c||c.solved)return false;const nextIndex=getNextCellMazeAdjacentIndex(cell,c);return!cell.borders[nextIndex];});if(prevLength>MAZE_INFO.queue.length)cell.path=false;return nextCell;};const getAdjPos=(cell)=>cell.circleProps?.adjacentPos||cell.adjacentPos[RENDER_INFO.currentPoly];const getNextCellMaze=(cell,cellFilter,isRandom=false)=>{const adjacentPos=getAdjPos(cell);const aCells=adjacentPos.map(getMazeCell).filter(cellFilter);if(!aCells.length){if(!MAZE_INFO.queue.length)return null;const prevPos=MAZE_INFO.queue.pop();return getMazeCell(prevPos);}MAZE_INFO.queue.push(cell.pos);return aCells[isRandom?getRandomInt(aCells.length):aCells.length-1];};const getNextCellMazeAdjacentIndex=(cell,nextCell)=>{let nextIndex=0;const adjacentPos=getAdjPos(cell);while(nextIndex<adjacentPos.length){const{i,j}=adjacentPos[nextIndex];if(nextCell.pos.i===i&&nextCell.pos.j===j)break;nextIndex++;}return nextIndex;};const mazeMove=(posIndex)=>{if(posIndex===undefined||MAZE_INFO.currentCell.borders[posIndex])return;const nextPos=getAdjPos(MAZE_INFO.currentCell)[posIndex];if(!nextPos)return;const nextCell=getMazeCell(nextPos);if(!nextCell)return;const oldCell=MAZE_INFO.currentCell;MAZE_INFO.currentCell=nextCell;const prevCell=MAZE_INFO.queue[MAZE_INFO.queue.length-1];if(nextCell.pos===prevCell){oldCell.path=false;MAZE_INFO.queue.pop();}else{oldCell.path=true;MAZE_INFO.queue.push(oldCell.pos);}return MAZE_INFO.currentCell;};const initMaze=()=>{for(const p of KNOWN_POLYGONS_VALUES){MAZE_POLYS_INFO[p]=configPoly(p,mazeInfos.cellHeight);}MAZE_INFO.rows=mazeInfos.rows;MAZE_INFO.columns=mazeInfos.columns;CIRCLE_INFO.cellHeight=mazeCircleInfos?.cellHeight||mazeInfos.cellHeight;CIRCLE_INFO.rows=mazeCircleInfos?.rows||MAZE_INFO.rows*2;CIRCLE_INFO.columns=mazeCircleInfos?.columns||MAZE_INFO.columns*2;const center=(CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2)/2;CIRCLE_INFO.center={x:center,y:center};};const getMazeSize=()=>{let{ySide,xSide,shouldIntercalate,hasInverted,polySide}=getMazePolyInfo();let height=MAZE_INFO.rows*mazeInfos.cellHeight;let width=MAZE_INFO.columns*(xSide*2);if(MAZE_INFO.isCircle)height=width=CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2;else{if(hasInverted)width=(MAZE_INFO.columns*polySide)/2+polySide/2+2;if(shouldIntercalate){height+=ySide;width=width*0.8;}}return{height,width};};const setIsCircle=(isCircle)=>{MAZE_INFO.isCircle=isCircle;if(MAZE_INFO.isCircle)RENDER_INFO.currentPoly=KNOWN_POLYGONS.SQUARE;};initMaze();return{getMazeSize,mazeMove,buildMaze,solveMaze,isMazeSolved,setIsCircle,getCirclePoint:()=>CIRCLE_INFO.center,iterateOverMaze,getMazeCell,getCurrentMazeCell:()=>MAZE_INFO.currentCell,getLastMazeCell,getMazePolyInfo,};};const createMazeObj=(mazeInfos,mazeCircleInfos)=>{let MAZE_GRID=([]);const MAZE_POLYS_INFO=({});const getMazePolyInfo=()=>MAZE_POLYS_INFO[RENDER_INFO.currentPoly];const CIRCLE_INFO=({cellHeight:0,center:null,rows:0,columns:0,});const MAZE_INFO=({rows:0,columns:0,isCircle:false,currentCell:null,queue:[],});const getMazeCell=({i,j})=>MAZE_GRID[i]?.[j];function*iterateOverMaze(){const rows=getMazeRows();for(let i=0;i<rows;i++){const numCells=getNumCellsPerMazeRow(i);for(let j=0;j<numCells;j++){yield{i,j};}}}const createMazeGrid=()=>{MAZE_GRID=[];for(const{i,j}of iterateOverMaze()){MAZE_GRID[i]=MAZE_GRID[i]||[];MAZE_GRID[i][j]=createCellMaze({i,j});}};const createCellMaze=(pos)=>{const cell=(createCellProps(pos));cell.visited=false;cell.solved=false;cell.path=false;cell.borders=[...new Array(RENDER_INFO.currentPoly)].map(()=>true);if(MAZE_INFO.isCircle)createCircleCellMaze(cell);else cell.point=calculateMazePoint(pos);return cell;};const calculateMazePoint=({i,j})=>{const{calcX,calcY,ySide,shouldIntercalate}=getMazePolyInfo();const x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=ySide;return{x,y};};const getMazeRows=()=>MAZE_INFO.isCircle?CIRCLE_INFO.rows:MAZE_INFO.rows;const getNumCellsPerMazeRow=(rowIndex)=>MAZE_INFO.isCircle?CIRCLE_INFO.columns-Math.floor((rowIndex+1)/2):MAZE_INFO.columns;const createCircleCellMaze=(cell)=>{const{i,j}=cell.pos;const topRadius=(CIRCLE_INFO.rows-i)*CIRCLE_INFO.cellHeight;const bottomRadius=topRadius-CIRCLE_INFO.cellHeight;const topAngle=Math.atan2(-topRadius,0);const bottomAngle=bottomRadius?topAngle:0;const numCells=getNumCellsPerMazeRow(i);const parts=(Math.PI*1.5-topAngle)/numCells;const leftBorder=j*parts;const rightBorder=(j+1)*parts;const topLeftAngle=topAngle+leftBorder;const topRightAngle=topAngle+rightBorder;const bottomLeftAngle=bottomAngle+leftBorder;const bottomRightAngle=bottomAngle+rightBorder;const topLeftPoint=getMazePoint(topRadius,topLeftAngle);const topRightPoint=getMazePoint(topRadius,topRightAngle);const bottomLeftPoint=getMazePoint(bottomRadius,bottomLeftAngle);const bottomRightPoint=getMazePoint(bottomRadius,bottomRightAngle);const points=[getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topLeftAngle),getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topRightAngle),];const x=points.reduce((acc,p)=>acc+p.x,0)/points.length;const y=points.reduce((acc,p)=>acc+p.y,0)/points.length;cell.point={x,y};cell.circleProps={topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topRadius,bottomRadius,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,adjacentPos:cell.adjacentPos[KNOWN_POLYGONS.SQUARE].map((aPos)=>({i:aPos.i,j:aPos.j<0?numCells-1:aPos.j>=numCells?0:aPos.j,})),};};const getMazePoint=(radius,angle)=>({x:CIRCLE_INFO.center.x+Math.cos(angle)*radius,y:CIRCLE_INFO.center.y+Math.sin(angle)*radius,});const buildMaze=()=>{createMazeGrid();MAZE_INFO.queue=[];MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);const lastCell=getLastMazeCell();while(MAZE_INFO.currentCell)MAZE_INFO.currentCell=buildCellMaze(MAZE_INFO.currentCell,lastCell);if(!MAZE_INFO.isCircle&&lastCell){openBorderForCellMaze(lastCell,getMazeCell(getAdjPos(lastCell)[0]));lastCell.visited=true;}if(!MAZE_INFO.isCircle&&getMazePolyInfo().hasInverted){for(const pos of iterateOverMaze()){const cell=getMazeCell(pos);cell.invertedBorders=[...cell.borders].reverse();}}MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const openBorderForCellMaze=(cell,nextCell)=>{const adjacentIndex=getNextCellMazeAdjacentIndex(cell,nextCell);const nextAdjacentIndex=getNextCellMazeAdjacentIndex(nextCell,cell);cell.borders[adjacentIndex]=false;nextCell.borders[nextAdjacentIndex]=false;};const buildCellMaze=(cell,lastCell)=>{cell.visited=true;const nextCell=getNextCellMaze(cell,(c)=>!!c&&!c.visited&&c!==lastCell,true);if(!nextCell)return null;openBorderForCellMaze(cell,nextCell);return nextCell;};const getLastMazeCell=()=>getMazeCell({i:MAZE_INFO.rows-1,j:MAZE_INFO.columns-1});const isMazeSolved=()=>!MAZE_INFO.currentCell||(MAZE_INFO.isCircle?MAZE_INFO.currentCell.pos.i===CIRCLE_INFO.rows-1:MAZE_INFO.currentCell===getLastMazeCell());const solveMaze=()=>{while(!isMazeSolved())MAZE_INFO.currentCell=solveCellMaze(MAZE_INFO.currentCell);solveCellMaze(MAZE_INFO.currentCell);MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const solveCellMaze=(cell)=>{if(!cell)return;cell.solved=true;cell.path=true;const prevLength=MAZE_INFO.queue.length;const nextCell=getNextCellMaze(cell,(c)=>{if(!c||c.solved)return false;const nextIndex=getNextCellMazeAdjacentIndex(cell,c);return!cell.borders[nextIndex];});if(prevLength>MAZE_INFO.queue.length)cell.path=false;return nextCell;};const getAdjPos=(cell)=>cell.circleProps?.adjacentPos||cell.adjacentPos[RENDER_INFO.currentPoly];const getNextCellMaze=(cell,cellFilter,isRandom=false)=>{const adjacentPos=getAdjPos(cell);const aCells=adjacentPos.map(getMazeCell).filter(cellFilter);if(!aCells.length){if(!MAZE_INFO.queue.length)return null;const prevPos=MAZE_INFO.queue.pop();return getMazeCell(prevPos);}MAZE_INFO.queue.push(cell.pos);return aCells[isRandom?getRandomInt(aCells.length):aCells.length-1];};const getNextCellMazeAdjacentIndex=(cell,nextCell)=>{let nextIndex=0;const adjacentPos=getAdjPos(cell);while(nextIndex<adjacentPos.length){const{i,j}=adjacentPos[nextIndex];if(nextCell.pos.i===i&&nextCell.pos.j===j)break;nextIndex++;}return nextIndex;};const mazeMove=(posIndex)=>{if(posIndex===undefined||MAZE_INFO.currentCell.borders[posIndex])return;const nextPos=getAdjPos(MAZE_INFO.currentCell)[posIndex];if(!nextPos)return;const nextCell=getMazeCell(nextPos);if(!nextCell)return;const oldCell=MAZE_INFO.currentCell;MAZE_INFO.currentCell=nextCell;const prevCell=MAZE_INFO.queue[MAZE_INFO.queue.length-1];if(nextCell.pos===prevCell){oldCell.path=false;MAZE_INFO.queue.pop();}else{oldCell.path=true;MAZE_INFO.queue.push(oldCell.pos);}return MAZE_INFO.currentCell;};const initMaze=()=>{for(const p of KNOWN_POLYGONS_VALUES){MAZE_POLYS_INFO[p]=configPoly(p,mazeInfos.cellHeight);}MAZE_INFO.rows=mazeInfos.rows;MAZE_INFO.columns=mazeInfos.columns;CIRCLE_INFO.cellHeight=mazeCircleInfos?.cellHeight||mazeInfos.cellHeight;CIRCLE_INFO.rows=mazeCircleInfos?.rows||MAZE_INFO.rows*2;CIRCLE_INFO.columns=mazeCircleInfos?.columns||MAZE_INFO.columns*2;const center=(CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2)/2;CIRCLE_INFO.center={x:center,y:center};};const getMazeSize=()=>{let{ySide,xSide,shouldIntercalate,hasInverted,polySide}=getMazePolyInfo();let height=MAZE_INFO.rows*mazeInfos.cellHeight;let width=MAZE_INFO.columns*(xSide*2);if(MAZE_INFO.isCircle)height=width=CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2;else{if(hasInverted)width=(MAZE_INFO.columns*polySide)/2+polySide/2+2;if(shouldIntercalate){height+=ySide;width=width*0.8;}}return{height,width};};const setIsCircle=(isCircle)=>{MAZE_INFO.isCircle=isCircle;if(MAZE_INFO.isCircle)RENDER_INFO.currentPoly=KNOWN_POLYGONS.SQUARE;};initMaze();return{getMazeSize,mazeMove,buildMaze,solveMaze,isMazeSolved,setIsCircle,getCirclePoint:()=>CIRCLE_INFO.center,iterateOverMaze,getMazeCell,getCurrentMazeCell:()=>MAZE_INFO.currentCell,getLastMazeCell,getMazePolyInfo,};};const PERLIN_VECTORS={BIOME:Symbol("BIOME"),BLOCK:Symbol("BLOCK"),};const getValue=(()=>{const PERLIN_CONFIG={noiseResolutionBiome:75,noiseResolution:10,};const getSizeFromNoise=(size,resolution)=>{const numVectorsX=Math.floor(size/resolution)+1;const extraVectorX=size%resolution==0?0:1;return numVectorsX+extraVectorX;};const initializeVector=(vector)=>{return{width:getSizeFromNoise(vector.width,vector.resolution),height:getSizeFromNoise(vector.height,vector.resolution),vectors:[],resolution:vector.resolution,};};const vectors=({[PERLIN_VECTORS.BIOME]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolutionBiome,}),[PERLIN_VECTORS.BLOCK]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolution,}),});const updateVector=(i,j,vector)=>{const offsetPos=getChunkStart({i,j},vector.height,vector.width);for(let i=0;i<=vector.height-1;i++){const nI=i+offsetPos.i;vector.vectors[nI]=vector.vectors[nI]||[];for(let j=0;j<=vector.width-1;j++){const nJ=j+offsetPos.j;vector.vectors[nI][nJ]=getRandUnitVect();}}};const getRandUnitVect=()=>{const theta=Math.random()*2*Math.PI;return{x:Math.cos(theta),y:Math.sin(theta)};};const dotProduct=(vector,x,y,vx,vy)=>{if(!vector.vectors[vy]?.[vx])updateVector(vy,vx,vector);return dot({x:x-vx,y:y-vy},vector.vectors[vy][vx]);};const dot=(v1,v2)=>v1.x*v2.x+v1.y*v2.y;const lerp=(a,b,c)=>a+smootherstep(c)*(b-a);const smootherstep=(x)=>6*x**5-15*x**4+10*x**3;return(i,j,vectorType)=>{const vector=vectors[vectorType];const offset=0.5/vector.resolution;const x=i/vector.resolution+offset;const y=j/vector.resolution+offset;const xF=Math.floor(x);const yF=Math.floor(y);const tlv=dotProduct(vector,x,y,xF,yF);const trv=dotProduct(vector,x,y,xF+1,yF);const blv=dotProduct(vector,x,y,xF,yF+1);const brv=dotProduct(vector,x,y,xF+1,yF+1);const lerpTop=lerp(tlv,trv,x-xF);const lerpBottom=lerp(blv,brv,x-xF);const value=lerp(lerpTop,lerpBottom,y-yF);return value;};})();const DRAW_CONFIG={lightDepth:2,maxLayer:2,fluidSpeed:500,};const RENDER_CONFIG={selectedBorderColor:"white",borderColor:"black",emptyColor:"black",lineWidth:1,wallDarkness:0.5,};const PERLIN_VECTORS={BIOME:Symbol("BIOME"),BLOCK:Symbol("BLOCK"),};const getValue=(()=>{const PERLIN_CONFIG={noiseResolutionBiome:75,noiseResolution:10,};const getSizeFromNoise=(size,resolution)=>{const numVectorsX=Math.floor(size/resolution)+1;const extraVectorX=size%resolution==0?0:1;return numVectorsX+extraVectorX;};const initializeVector=(vector)=>{return{width:getSizeFromNoise(vector.width,vector.resolution),height:getSizeFromNoise(vector.height,vector.resolution),vectors:[],resolution:vector.resolution,};};const vectors=({[PERLIN_VECTORS.BIOME]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolutionBiome,}),[PERLIN_VECTORS.BLOCK]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolution,}),});const updateVector=(i,j,vector)=>{const offsetPos=getChunkStart({i,j},vector.height,vector.width);for(let i=0;i<=vector.height-1;i++){const nI=i+offsetPos.i;vector.vectors[nI]=vector.vectors[nI]||[];for(let j=0;j<=vector.width-1;j++){const nJ=j+offsetPos.j;vector.vectors[nI][nJ]=getRandUnitVect();}}};const getRandUnitVect=()=>{const theta=Math.random()*2*Math.PI;return{x:Math.cos(theta),y:Math.sin(theta)};};const dotProduct=(vector,x,y,vx,vy)=>{if(!vector.vectors[vy]?.[vx])updateVector(vy,vx,vector);return dot({x:x-vx,y:y-vy},vector.vectors[vy][vx]);};const dot=(v1,v2)=>v1.x*v2.x+v1.y*v2.y;const lerp=(a,b,c)=>a+smootherstep(c)*(b-a);const smootherstep=(x)=>6*x**5-15*x**4+10*x**3;return(i,j,vectorType)=>{const vector=vectors[vectorType];const offset=0.5/vector.resolution;const x=i/vector.resolution+offset;const y=j/vector.resolution+offset;const xF=Math.floor(x);const yF=Math.floor(y);const tlv=dotProduct(vector,x,y,xF,yF);const trv=dotProduct(vector,x,y,xF+1,yF);const blv=dotProduct(vector,x,y,xF,yF+1);const brv=dotProduct(vector,x,y,xF+1,yF+1);const lerpTop=lerp(tlv,trv,x-xF);const lerpBottom=lerp(blv,brv,x-xF);const value=lerp(lerpTop,lerpBottom,y-yF);return value;};})();const blockToWall=(block,point,wallParams={},polyInfo)=>{polyInfo=polyInfo||getPolyInfo();const points=wallParams.isInverted?polyInfo.invertedPoints:polyInfo.points;const layer=wallParams.layer||0;const wallLayer=layer+1;const wallPoints=wallParams.isInverted?polyInfo.wallInvertedPoints:polyInfo.wallPoints;const commonInfos={color:block.color,pos:wallParams.pos,isInverted:wallParams.isInverted,isSelectedCell:wallParams.isSelectedCell,};return{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*layer},points:wallPoints,topInfo:{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*wallLayer},points,modifier:wallParams.modifier,},borderMap:wallParams.borderMap,modifier:wallParams.modifier*RENDER_CONFIG.wallDarkness,};};const DRAW_CONFIG={lightDepth:2,maxLayer:2,fluidSpeed:500,};const RENDER_CONFIG={selectedBorderColor:"white",borderColor:"black",emptyColor:"black",lineWidth:1,wallDarkness:0.5,};const PERLIN_VECTORS={BIOME:Symbol("BIOME"),BLOCK:Symbol("BLOCK"),};const getValue=(()=>{const PERLIN_CONFIG={noiseResolutionBiome:75,noiseResolution:10,};const getSizeFromNoise=(size,resolution)=>{const numVectorsX=Math.floor(size/resolution)+1;const extraVectorX=size%resolution==0?0:1;return numVectorsX+extraVectorX;};const initializeVector=(vector)=>{return{width:getSizeFromNoise(vector.width,vector.resolution),height:getSizeFromNoise(vector.height,vector.resolution),vectors:[],resolution:vector.resolution,};};const vectors=({[PERLIN_VECTORS.BIOME]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolutionBiome,}),[PERLIN_VECTORS.BLOCK]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolution,}),});const updateVector=(i,j,vector)=>{const offsetPos=getChunkStart({i,j},vector.height,vector.width);for(let i=0;i<=vector.height-1;i++){const nI=i+offsetPos.i;vector.vectors[nI]=vector.vectors[nI]||[];for(let j=0;j<=vector.width-1;j++){const nJ=j+offsetPos.j;vector.vectors[nI][nJ]=getRandUnitVect();}}};const getRandUnitVect=()=>{const theta=Math.random()*2*Math.PI;return{x:Math.cos(theta),y:Math.sin(theta)};};const dotProduct=(vector,x,y,vx,vy)=>{if(!vector.vectors[vy]?.[vx])updateVector(vy,vx,vector);return dot({x:x-vx,y:y-vy},vector.vectors[vy][vx]);};const dot=(v1,v2)=>v1.x*v2.x+v1.y*v2.y;const lerp=(a,b,c)=>a+smootherstep(c)*(b-a);const smootherstep=(x)=>6*x**5-15*x**4+10*x**3;return(i,j,vectorType)=>{const vector=vectors[vectorType];const offset=0.5/vector.resolution;const x=i/vector.resolution+offset;const y=j/vector.resolution+offset;const xF=Math.floor(x);const yF=Math.floor(y);const tlv=dotProduct(vector,x,y,xF,yF);const trv=dotProduct(vector,x,y,xF+1,yF);const blv=dotProduct(vector,x,y,xF,yF+1);const brv=dotProduct(vector,x,y,xF+1,yF+1);const lerpTop=lerp(tlv,trv,x-xF);const lerpBottom=lerp(blv,brv,x-xF);const value=lerp(lerpTop,lerpBottom,y-yF);return value;};})();const drawContainer=document.getElementById("draw-container");const canvasContainer=document.getElementById("canvas-container");const blockToWall=(block,point,wallParams={},polyInfo)=>{polyInfo=polyInfo||getPolyInfo();const points=wallParams.isInverted?polyInfo.invertedPoints:polyInfo.points;const layer=wallParams.layer||0;const wallLayer=layer+1;const wallPoints=wallParams.isInverted?polyInfo.wallInvertedPoints:polyInfo.wallPoints;const commonInfos={color:block.color,pos:wallParams.pos,isInverted:wallParams.isInverted,isSelectedCell:wallParams.isSelectedCell,};return{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*layer},points:wallPoints,topInfo:{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*wallLayer},points,modifier:wallParams.modifier,},borderMap:wallParams.borderMap,modifier:wallParams.modifier*RENDER_CONFIG.wallDarkness,};};const DRAW_CONFIG={lightDepth:2,maxLayer:2,fluidSpeed:500,};const RENDER_CONFIG={selectedBorderColor:"white",borderColor:"black",emptyColor:"black",lineWidth:1,wallDarkness:0.5,};const drawContainer=document.getElementById("draw-container");const canvasContainer=document.getElementById("canvas-container");const blockToWall=(block,point,wallParams={},polyInfo)=>{polyInfo=polyInfo||getPolyInfo();const points=wallParams.isInverted?polyInfo.invertedPoints:polyInfo.points;const layer=wallParams.layer||0;const wallLayer=layer+1;const wallPoints=wallParams.isInverted?polyInfo.wallInvertedPoints:polyInfo.wallPoints;const commonInfos={color:block.color,pos:wallParams.pos,isInverted:wallParams.isInverted,isSelectedCell:wallParams.isSelectedCell,};return{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*layer},points:wallPoints,topInfo:{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*wallLayer},points,modifier:wallParams.modifier,},borderMap:wallParams.borderMap,modifier:wallParams.modifier*RENDER_CONFIG.wallDarkness,};};const drawContainer=document.getElementById("draw-container");const canvasContainer=document.getElementById("canvas-container");const resetCanvas=()=>{const polyInfo=getPolyInfo();setCanvasSize(polyInfo.canvasHeight,polyInfo.canvasWidth);setFavicon();};const updateCanvasCss=()=>{updateConfigs();updateWeather();updateWidgets();};let filledThisRound=(new Set());let tracksCount=({});const addToTrackCount=(block)=>{if(block?.trackType)tracksCount[block.trackType]=(tracksCount[block.trackType]||0)+1;};const getAjacentCells=(cell,depth=1)=>{const result=[[cell]];for(let index=0;index<depth;index++){const cells=([]);const current=result[index];for(const element of current){if(!element)continue;const aCells=element.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);cells.push(...aCells.filter((c)=>!current.includes(c)&&!cells.includes(c)&&c!==cell));}result.push(cells);}return result;};const drawEveryCell=(baseEntity)=>{wallLayers=[];fluids=[];filledThisRound=new Set();tracksCount={};const offsetCell=baseEntity.cell.pos.j%2;const{rows,columns,shouldIntercalate}=getPolyInfo();const size=rows+columns;const adjacentCells=getAjacentCells(baseEntity.cell,DRAW_CONFIG.lightDepth);const selectedCell=getSelectedCell(baseEntity);for(let i=-columns;i<size;i++){const baseI=i+RENDER_INFO.iOffset;for(let j=-rows;j<size;j++){let nI=baseI;const nJ=j+RENDER_INFO.jOffset;const pos={i:nI,j:nJ};if(shouldIntercalate&&offsetCell&&nJ%2===0)nI=nI+1;drawCell(loadAndGetCell(pos),contextsLayers[0],baseEntity,adjacentCells,selectedCell);}}drawWalls();updateEntities();tweakFluids();updateBiomeMap();updateTracks(tracksCount);};let wallLayers=([]);const drawWalls=()=>{for(let i=1;i<DRAW_CONFIG.maxLayer;i++){const walls=wallLayers[i];clearCanvas(canvasLayers[i]);if(!walls)continue;walls.forEach((w)=>drawWall(w,contextsLayers[i]));walls.forEach((w)=>drawWallTop(w,contextsLayers[i]));}wallLayers=[];};let fluidInterval=null;let fluids=([]);const tweakFluids=debounce(()=>{clearInterval(fluidInterval);if(!fluids.length)return;const context=contextsLayers[0];fluidInterval=setInterval(()=>{fluids.forEach((fluid)=>{drawItem(context,{...fluid,color:tweakColor(fluid.color),});});},DRAW_CONFIG.fluidSpeed);},DRAW_CONFIG.fluidSpeed);const drawCell=(cell,context,baseEntity,adjacentCells,selectedCell)=>{const polyInfo=getPolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const point=calculatePointBasedOnPos(cell.pos,isInverted,baseEntity.cell);if(isPointOutside(point,polyInfo.canvasHeight,polyInfo.canvasWidth))return;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const aCells=cell.adjacentPos[RENDER_INFO.currentPoly].map(getCell);const isSelectedCell=MENU_CONFIG.showSelectedCell&&cell===selectedCell;cell.modifier=getStyleModifier(adjacentCells.findIndex((c)=>c.includes(cell)));addToTrackCount(cell.wall?.block||cell.block);if(cell.wall){const wallLayer=cell.layer+1;const shouldOffset=polyInfo.hasInverted&&!cell.isInverted;if(!wallLayers[wallLayer])wallLayers[wallLayer]=[];wallLayers[wallLayer].push(blockToWall(cell.wall,point,{layer:cell.layer,isInverted,modifier:cell.modifier,isSelectedCell,pos:cell.pos,borderMap:aCells.reduce((acc,c,i)=>{let index=i-RENDER_INFO.rotationTurns;if(shouldOffset)index=RENDER_INFO.currentPoly-1-index;acc[getMod(index,RENDER_INFO.currentPoly)]=!c?.wall;return acc;},[]),}));return;}if(!cell.block){const aFluid=aCells.find((c)=>c?.block?.isFluid);if(aFluid&&!filledThisRound.has(aFluid.pos)){filledThisRound.add(cell.pos);cell.block=aFluid.block;cell.color=aFluid.color;}}const drawable=({point,points,isInverted,pos:cell.pos,color:cell.color,modifier:cell.modifier,isSelectedCell,});if(cell.block?.isFluid)fluids.push(drawable);drawItem(context,drawable);if(cell.block===MINE_BLOCKS.MINES_LOW){const aCellsCorner=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);showMineValue(context,aCellsCorner.reduce((acc,c)=>(c.hasBomb?acc+1:acc),0),point,isInverted,polyInfo.ySide);}};const drawCircleOnCell=(cell,baseEntity)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(cell.pos,hasInverted&&cell.isInverted,baseEntity.cell);drawCircle(contextsLayers[0],point,ySide/4);};const resetCanvas=()=>{const polyInfo=getPolyInfo();setCanvasSize(polyInfo.canvasHeight,polyInfo.canvasWidth);setFavicon();};const updateCanvasCss=()=>{updateConfigs();updateWeather();updateWidgets();};let filledThisRound=(new Set());let tracksCount=({});const addToTrackCount=(block)=>{if(block?.trackType)tracksCount[block.trackType]=(tracksCount[block.trackType]||0)+1;};const getAjacentCells=(cell,depth=1)=>{const result=[[cell]];for(let index=0;index<depth;index++){const cells=([]);const current=result[index];for(const element of current){if(!element)continue;const aCells=element.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);cells.push(...aCells.filter((c)=>!current.includes(c)&&!cells.includes(c)&&c!==cell));}result.push(cells);}return result;};const drawEveryCell=(baseEntity)=>{wallLayers=[];fluids=[];filledThisRound=new Set();tracksCount={};const offsetCell=baseEntity.cell.pos.j%2;const{rows,columns,shouldIntercalate}=getPolyInfo();const size=rows+columns;const adjacentCells=getAjacentCells(baseEntity.cell,DRAW_CONFIG.lightDepth);const selectedCell=getSelectedCell(baseEntity);for(let i=-columns;i<size;i++){const baseI=i+RENDER_INFO.iOffset;for(let j=-rows;j<size;j++){let nI=baseI;const nJ=j+RENDER_INFO.jOffset;const pos={i:nI,j:nJ};if(shouldIntercalate&&offsetCell&&nJ%2===0)nI=nI+1;drawCell(loadAndGetCell(pos),contextsLayers[0],baseEntity,adjacentCells,selectedCell);}}drawWalls();updateEntities();tweakFluids();updateBiomeMap();updateTracks(tracksCount);};let wallLayers=([]);const drawWalls=()=>{for(let i=1;i<DRAW_CONFIG.maxLayer;i++){const walls=wallLayers[i];clearCanvas(canvasLayers[i]);if(!walls)continue;walls.forEach((w)=>drawWall(w,contextsLayers[i]));walls.forEach((w)=>drawWallTop(w,contextsLayers[i]));}wallLayers=[];};let fluidInterval=null;let fluids=([]);const tweakFluids=debounce(()=>{clearInterval(fluidInterval);if(!fluids.length)return;const context=contextsLayers[0];fluidInterval=setInterval(()=>{fluids.forEach((fluid)=>{drawItem(context,{...fluid,color:tweakColor(fluid.color),});});},DRAW_CONFIG.fluidSpeed);},DRAW_CONFIG.fluidSpeed);const drawCell=(cell,context,baseEntity,adjacentCells,selectedCell)=>{const polyInfo=getPolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const point=calculatePointBasedOnPos(cell.pos,isInverted,baseEntity.cell);if(isPointOutside(point,polyInfo.canvasHeight,polyInfo.canvasWidth))return;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const aCells=cell.adjacentPos[RENDER_INFO.currentPoly].map(getCell);const isSelectedCell=MENU_CONFIG.showSelectedCell&&cell===selectedCell;cell.modifier=getStyleModifier(adjacentCells.findIndex((c)=>c.includes(cell)));addToTrackCount(cell.wall?.block||cell.block);if(cell.wall){const wallLayer=cell.layer+1;const shouldOffset=polyInfo.hasInverted&&!cell.isInverted;if(!wallLayers[wallLayer])wallLayers[wallLayer]=[];wallLayers[wallLayer].push(blockToWall(cell.wall,point,{layer:cell.layer,isInverted,modifier:cell.modifier,isSelectedCell,pos:cell.pos,borderMap:aCells.reduce((acc,c,i)=>{let index=i-RENDER_INFO.rotationTurns;if(shouldOffset)index=RENDER_INFO.currentPoly-1-index;acc[getMod(index,RENDER_INFO.currentPoly)]=!c?.wall;return acc;},[]),}));return;}if(!cell.block){const aFluid=aCells.find((c)=>c?.block?.isFluid);if(aFluid&&!filledThisRound.has(aFluid.pos)){filledThisRound.add(cell.pos);cell.block=aFluid.block;cell.color=aFluid.color;}}const drawable=({point,points,isInverted,pos:cell.pos,color:cell.color,modifier:cell.modifier,isSelectedCell,});if(cell.block?.isFluid)fluids.push(drawable);drawItem(context,drawable);if(cell.block===MINE_BLOCKS.MINES_LOW){const aCellsCorner=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);showMineValue(context,aCellsCorner.reduce((acc,c)=>(c.hasBomb?acc+1:acc),0),point,isInverted,polyInfo.ySide);}};const drawCircleOnCell=(cell,baseEntity)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(cell.pos,hasInverted&&cell.isInverted,baseEntity.cell);drawCircle(contextsLayers[0],point,ySide/4);};const MAZE_CANVAS_CONFIG={defaultColor:"#cdcdcd",};const drawMaze=(context,mazeObj)=>{for(const pos of mazeObj.iterateOverMaze()){drawCellMaze(context,mazeObj,mazeObj.getMazeCell(pos));}};const drawCellMaze=(context,mazeObj,cell,color)=>{context.fillStyle=color?getFillStyle(color):MAZE_CANVAS_CONFIG.defaultColor;if(cell.circleProps)drawCellMazeCircle(context,cell,mazeObj.getCirclePoint());else drawCellMazePolygon(context,mazeObj,cell);};const drawCellMazePolygon=(context,mazeObj,cell)=>{const polyInfo=mazeObj.getMazePolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const borders=polyInfo.hasInverted&&!cell.isInverted?cell.invertedBorders:cell.borders;fillPolygon(context,cell.point,points);applyBorders(context,cell.point,points,borders);if(MENU_CONFIG.showPos&&cell.pos)showPos(context,cell.pos,cell.point,isInverted,polyInfo.ySide);};const drawCellMazeCircle=(context,cell,circlePoint)=>{const{topRadius,bottomRadius,topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,}=cell.circleProps;context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.closePath();context.fill();if(cell.borders[0]){context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.stroke();}if(cell.borders[1]){context.beginPath();context.moveTo(topRightPoint.x,topRightPoint.y);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.stroke();}if(cell.borders[2]){context.beginPath();context.moveTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.stroke();}if(cell.borders[3]){context.beginPath();context.moveTo(bottomLeftPoint.x,bottomLeftPoint.y);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.stroke();}};const resetCanvas=()=>{const polyInfo=getPolyInfo();setCanvasSize(polyInfo.canvasHeight,polyInfo.canvasWidth);setFavicon();};const updateCanvasCss=()=>{updateConfigs();updateWeather();updateWidgets();};let filledThisRound=(new Set());let tracksCount=({});const addToTrackCount=(block)=>{if(block?.trackType)tracksCount[block.trackType]=(tracksCount[block.trackType]||0)+1;};const getAjacentCells=(cell,depth=1)=>{const result=[[cell]];for(let index=0;index<depth;index++){const cells=([]);const current=result[index];for(const element of current){if(!element)continue;const aCells=element.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);cells.push(...aCells.filter((c)=>!current.includes(c)&&!cells.includes(c)&&c!==cell));}result.push(cells);}return result;};const drawEveryCell=(baseEntity)=>{wallLayers=[];fluids=[];filledThisRound=new Set();tracksCount={};const offsetCell=baseEntity.cell.pos.j%2;const{rows,columns,shouldIntercalate}=getPolyInfo();const size=rows+columns;const adjacentCells=getAjacentCells(baseEntity.cell,DRAW_CONFIG.lightDepth);const selectedCell=getSelectedCell(baseEntity);for(let i=-columns;i<size;i++){const baseI=i+RENDER_INFO.iOffset;for(let j=-rows;j<size;j++){let nI=baseI;const nJ=j+RENDER_INFO.jOffset;const pos={i:nI,j:nJ};if(shouldIntercalate&&offsetCell&&nJ%2===0)nI=nI+1;drawCell(loadAndGetCell(pos),contextsLayers[0],baseEntity,adjacentCells,selectedCell);}}drawWalls();updateEntities();tweakFluids();updateBiomeMap();updateTracks(tracksCount);};let wallLayers=([]);const drawWalls=()=>{for(let i=1;i<DRAW_CONFIG.maxLayer;i++){const walls=wallLayers[i];clearCanvas(canvasLayers[i]);if(!walls)continue;walls.forEach((w)=>drawWall(w,contextsLayers[i]));walls.forEach((w)=>drawWallTop(w,contextsLayers[i]));}wallLayers=[];};let fluidInterval=null;let fluids=([]);const tweakFluids=debounce(()=>{clearInterval(fluidInterval);if(!fluids.length)return;const context=contextsLayers[0];fluidInterval=setInterval(()=>{fluids.forEach((fluid)=>{drawItem(context,{...fluid,color:tweakColor(fluid.color),});});},DRAW_CONFIG.fluidSpeed);},DRAW_CONFIG.fluidSpeed);const drawCell=(cell,context,baseEntity,adjacentCells,selectedCell)=>{const polyInfo=getPolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const point=calculatePointBasedOnPos(cell.pos,isInverted,baseEntity.cell);if(isPointOutside(point,polyInfo.canvasHeight,polyInfo.canvasWidth))return;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const aCells=cell.adjacentPos[RENDER_INFO.currentPoly].map(getCell);const isSelectedCell=MENU_CONFIG.showSelectedCell&&cell===selectedCell;cell.modifier=getStyleModifier(adjacentCells.findIndex((c)=>c.includes(cell)));addToTrackCount(cell.wall?.block||cell.block);if(cell.wall){const wallLayer=cell.layer+1;const shouldOffset=polyInfo.hasInverted&&!cell.isInverted;if(!wallLayers[wallLayer])wallLayers[wallLayer]=[];wallLayers[wallLayer].push(blockToWall(cell.wall,point,{layer:cell.layer,isInverted,modifier:cell.modifier,isSelectedCell,pos:cell.pos,borderMap:aCells.reduce((acc,c,i)=>{let index=i-RENDER_INFO.rotationTurns;if(shouldOffset)index=RENDER_INFO.currentPoly-1-index;acc[getMod(index,RENDER_INFO.currentPoly)]=!c?.wall;return acc;},[]),}));return;}if(!cell.block){const aFluid=aCells.find((c)=>c?.block?.isFluid);if(aFluid&&!filledThisRound.has(aFluid.pos)){filledThisRound.add(cell.pos);cell.block=aFluid.block;cell.color=aFluid.color;}}const drawable=({point,points,isInverted,pos:cell.pos,color:cell.color,modifier:cell.modifier,isSelectedCell,});if(cell.block?.isFluid)fluids.push(drawable);drawItem(context,drawable);if(cell.block===MINE_BLOCKS.MINES_LOW){const aCellsCorner=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);showMineValue(context,aCellsCorner.reduce((acc,c)=>(c.hasBomb?acc+1:acc),0),point,isInverted,polyInfo.ySide);}};const drawCircleOnCell=(cell,baseEntity)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(cell.pos,hasInverted&&cell.isInverted,baseEntity.cell);drawCircle(contextsLayers[0],point,ySide/4);};const canvasLayers =([]);const contextsLayers =([]);for (let i =0;i <DRAW_CONFIG.maxLayer;i++){const canvas =document.createElement("canvas");canvasContainer.appendChild(canvas);canvasLayers.push(canvas);contextsLayers.push(canvas.getContext("2d"));}const setCanvasSize =(height,width)=>{drawContainer.style.setProperty("--canvas-height",`${height}px`);canvasLayers.forEach((canvas)=>(canvas.height =height));drawContainer.style.setProperty("--canvas-width",`${width}px`);canvasLayers.forEach((canvas)=>(canvas.width =width));};const setFavicon =()=>{const link =(document.querySelector("link[rel~='icon']"));link.href=POLYGONS_IMAGES[RENDER_INFO.currentPoly];};const updateConfigs=()=>{canvasContainer.classList[MENU_CONFIG.usePerspective?"add":"remove"]("perspective");};const clearCanvas=(canvas)=>{canvas.width=canvas.width;};const drawWall=(wall,context)=>{if(!wall.borderMap||wall.borderMap.find((b)=>!!b))drawItem(context,wall);};const drawWallTop=(wall,context)=>{drawItem(context,wall.topInfo);context.strokeStyle=wall.isSelectedCell?RENDER_CONFIG.selectedBorderColor:RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,wall.topInfo.point,wall.topInfo.points,wall.borderMap);};const drawItem=(context,{point,points,pos,isInverted,color,modifier,isSelectedCell})=>{context.fillStyle=color?getFillStyle(color,modifier):RENDER_CONFIG.emptyColor;fillPolygon(context,point,points);if(MENU_CONFIG.showPos&&pos)showPos(context,pos,point,isInverted,getPolyInfo().ySide);if(isSelectedCell){context.strokeStyle=RENDER_CONFIG.selectedBorderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}else if(MENU_CONFIG.showChunks&&pos)showChunks(context,pos,point,points);};const getFillStyle=(color,modifier=1)=>color===EMPTY_BLOCK.color?"transparent":`rgb(`+`${color.r *modifier},`+`${color.g *modifier},`+`${color.b *modifier})`;const getStyleModifier=(intensity)=>{if(!ENTITY_INFO.timeOfDay)return 1;let modifier=1-ENTITY_INFO.timeOfDay/100;if(intensity>=0)modifier=(1-modifier)/(intensity||1)+modifier;return modifier;};const fillPolygon=(context,{x,y},points)=>{context.beginPath();for(const point of points){context.lineTo(x+point.x,y+point.y);}context.closePath();context.fill();};const applyBorders=(context,{x,y},points,map,ignoreLast)=>{for(let i=0;i<points.length;i++){if(!map?.length||map[i]){const point=points[i];let nextPoint=points[i+1];if(!nextPoint){if(ignoreLast)return;nextPoint=points[0];}const pointA={x:x+point.x,y:y+point.y};const pointB={x:x+nextPoint.x,y:y+nextPoint.y};drawLine(context,pointA,pointB);}}};const drawLine=(context,pointA,pointB)=>{context.beginPath();context.moveTo(pointA.x,pointA.y);context.lineTo(pointB.x,pointB.y);context.stroke();};const showPos=(context,pos,point,isInverted,ySide)=>{context.fillStyle="black";context.font=`bold ${ySide /2}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${pos.i},${pos.j}`,point.x,isInverted?point.y+ySide/2:point.y);};const showChunks=(context,pos,point,points)=>{if(pos.i%GENERATION_CONFIG.chunkSize===0||pos.j%GENERATION_CONFIG.chunkSize===0){context.strokeStyle=RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}};const mineValueColors=["blue","green","red","darkblue","brown","darkred","black","grey",];const showMineValue=(context,value,point,isInverted,ySide)=>{if(value){context.fillStyle=mineValueColors[value-1];context.font=`bold ${ySide}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${value}`,point.x,isInverted?point.y+ySide/2:point.y);}};const drawCircle=(context,point,radius)=>{context.beginPath();context.arc(point.x,point.y,radius,0,2*Math.PI);context.fillStyle="black";context.fill();};const MAZE_CANVAS_CONFIG={defaultColor:"#cdcdcd",};const drawMaze=(context,mazeObj)=>{for(const pos of mazeObj.iterateOverMaze()){drawCellMaze(context,mazeObj,mazeObj.getMazeCell(pos));}};const drawCellMaze=(context,mazeObj,cell,color)=>{context.fillStyle=color?getFillStyle(color):MAZE_CANVAS_CONFIG.defaultColor;if(cell.circleProps)drawCellMazeCircle(context,cell,mazeObj.getCirclePoint());else drawCellMazePolygon(context,mazeObj,cell);};const drawCellMazePolygon=(context,mazeObj,cell)=>{const polyInfo=mazeObj.getMazePolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const borders=polyInfo.hasInverted&&!cell.isInverted?cell.invertedBorders:cell.borders;fillPolygon(context,cell.point,points);applyBorders(context,cell.point,points,borders);if(MENU_CONFIG.showPos&&cell.pos)showPos(context,cell.pos,cell.point,isInverted,polyInfo.ySide);};const drawCellMazeCircle=(context,cell,circlePoint)=>{const{topRadius,bottomRadius,topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,}=cell.circleProps;context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.closePath();context.fill();if(cell.borders[0]){context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.stroke();}if(cell.borders[1]){context.beginPath();context.moveTo(topRightPoint.x,topRightPoint.y);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.stroke();}if(cell.borders[2]){context.beginPath();context.moveTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.stroke();}if(cell.borders[3]){context.beginPath();context.moveTo(bottomLeftPoint.x,bottomLeftPoint.y);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.stroke();}};const audios=({});let MUSIC_VOLUME=1;const TRACK_FILES={[TRACK_TYPES.TRACK1]:"sounds/blocks/track1.wav",[TRACK_TYPES.TRACK2]:"sounds/blocks/track2.wav",[TRACK_TYPES.TRACK3]:"sounds/blocks/track3.wav",[TRACK_TYPES.TRACK4]:"sounds/blocks/track4.wav",[TRACK_TYPES.TRACK5]:"sounds/blocks/track5.wav",[TRACK_TYPES.TRACK6]:"sounds/blocks/track6.wav",[TRACK_TYPES.TRACK7]:"sounds/blocks/track7.wav",[TRACK_TYPES.TRACK8]:"sounds/blocks/track8.wav",[TRACK_TYPES.TRACK11]:"sounds/blocks/track11.wav",[TRACK_TYPES.TRACK14]:"sounds/blocks/track14.wav",[TRACK_TYPES.TRACK15]:"sounds/blocks/track15.wav",[TRACK_TYPES.TRACK16]:"sounds/blocks/track16.wav",};Object.entries(TRACK_FILES).forEach(([track,path])=>{const pan=+track.replace("TRACK","")%2?-1:1;const ctx=new AudioContext();const srcNode=ctx.createBufferSource();const gainNode=ctx.createGain();gainNode.gain.value=0;gainNode.connect(ctx.destination);const ambientPan=ctx.createStereoPanner();ambientPan.pan.value=pan;ambientPan.connect(gainNode);audios[track]={srcNode,gainNode,volume:0};fetch(path,{mode:"cors"}).then((resp)=>resp.arrayBuffer()).then((buffer)=>ctx.decodeAudioData(buffer,(abuffer)=>{srcNode.buffer=abuffer;srcNode.connect(ambientPan);srcNode.loop=true;srcNode.loopEnd=35.99;}));});const audiosList=Object.values(audios);const TRACK_LIST=Object.keys(TRACK_FILES);let audioStarted=false;const updateTracks=(tracksCount)=>{if(MENU_CONFIG.music){const polyInfo=getPolyInfo();const max=polyInfo.rows*polyInfo.columns*1.2;TRACK_LIST.forEach((track)=>{const audio=audios[track];audio.volume=(tracksCount[track]||0)/max;updateTrackVolume(audio);if(!audioStarted)audio.srcNode.start();});audioStarted=true;}else{audiosList.forEach((a)=>(a.gainNode.gain.value=0));}};const setMusicVolume=(volume)=>{MUSIC_VOLUME=volume;TRACK_LIST.forEach((track)=>updateTrackVolume(audios[track]));};const updateTrackVolume=(audio)=>{const{gainNode,volume}=audio;gainNode.gain.value=(MUSIC_VOLUME*volume)/100;};const canvasLayers =([]);const contextsLayers =([]);for (let i =0;i <DRAW_CONFIG.maxLayer;i++){const canvas =document.createElement("canvas");canvasContainer.appendChild(canvas);canvasLayers.push(canvas);contextsLayers.push(canvas.getContext("2d"));}const setCanvasSize =(height,width)=>{drawContainer.style.setProperty("--canvas-height",`${height}px`);canvasLayers.forEach((canvas)=>(canvas.height =height));drawContainer.style.setProperty("--canvas-width",`${width}px`);canvasLayers.forEach((canvas)=>(canvas.width =width));};const setFavicon =()=>{const link =(document.querySelector("link[rel~='icon']"));link.href=POLYGONS_IMAGES[RENDER_INFO.currentPoly];};const updateConfigs=()=>{canvasContainer.classList[MENU_CONFIG.usePerspective?"add":"remove"]("perspective");};const clearCanvas=(canvas)=>{canvas.width=canvas.width;};const drawWall=(wall,context)=>{if(!wall.borderMap||wall.borderMap.find((b)=>!!b))drawItem(context,wall);};const drawWallTop=(wall,context)=>{drawItem(context,wall.topInfo);context.strokeStyle=wall.isSelectedCell?RENDER_CONFIG.selectedBorderColor:RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,wall.topInfo.point,wall.topInfo.points,wall.borderMap);};const drawItem=(context,{point,points,pos,isInverted,color,modifier,isSelectedCell})=>{context.fillStyle=color?getFillStyle(color,modifier):RENDER_CONFIG.emptyColor;fillPolygon(context,point,points);if(MENU_CONFIG.showPos&&pos)showPos(context,pos,point,isInverted,getPolyInfo().ySide);if(isSelectedCell){context.strokeStyle=RENDER_CONFIG.selectedBorderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}else if(MENU_CONFIG.showChunks&&pos)showChunks(context,pos,point,points);};const getFillStyle=(color,modifier=1)=>color===EMPTY_BLOCK.color?"transparent":`rgb(`+`${color.r *modifier},`+`${color.g *modifier},`+`${color.b *modifier})`;const getStyleModifier=(intensity)=>{if(!ENTITY_INFO.timeOfDay)return 1;let modifier=1-ENTITY_INFO.timeOfDay/100;if(intensity>=0)modifier=(1-modifier)/(intensity||1)+modifier;return modifier;};const fillPolygon=(context,{x,y},points)=>{context.beginPath();for(const point of points){context.lineTo(x+point.x,y+point.y);}context.closePath();context.fill();};const applyBorders=(context,{x,y},points,map,ignoreLast)=>{for(let i=0;i<points.length;i++){if(!map?.length||map[i]){const point=points[i];let nextPoint=points[i+1];if(!nextPoint){if(ignoreLast)return;nextPoint=points[0];}const pointA={x:x+point.x,y:y+point.y};const pointB={x:x+nextPoint.x,y:y+nextPoint.y};drawLine(context,pointA,pointB);}}};const drawLine=(context,pointA,pointB)=>{context.beginPath();context.moveTo(pointA.x,pointA.y);context.lineTo(pointB.x,pointB.y);context.stroke();};const showPos=(context,pos,point,isInverted,ySide)=>{context.fillStyle="black";context.font=`bold ${ySide /2}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${pos.i},${pos.j}`,point.x,isInverted?point.y+ySide/2:point.y);};const showChunks=(context,pos,point,points)=>{if(pos.i%GENERATION_CONFIG.chunkSize===0||pos.j%GENERATION_CONFIG.chunkSize===0){context.strokeStyle=RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}};const mineValueColors=["blue","green","red","darkblue","brown","darkred","black","grey",];const showMineValue=(context,value,point,isInverted,ySide)=>{if(value){context.fillStyle=mineValueColors[value-1];context.font=`bold ${ySide}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${value}`,point.x,isInverted?point.y+ySide/2:point.y);}};const drawCircle=(context,point,radius)=>{context.beginPath();context.arc(point.x,point.y,radius,0,2*Math.PI);context.fillStyle="black";context.fill();};const MAZE_CANVAS_CONFIG={defaultColor:"#cdcdcd",};const drawMaze=(context,mazeObj)=>{for(const pos of mazeObj.iterateOverMaze()){drawCellMaze(context,mazeObj,mazeObj.getMazeCell(pos));}};const drawCellMaze=(context,mazeObj,cell,color)=>{context.fillStyle=color?getFillStyle(color):MAZE_CANVAS_CONFIG.defaultColor;if(cell.circleProps)drawCellMazeCircle(context,cell,mazeObj.getCirclePoint());else drawCellMazePolygon(context,mazeObj,cell);};const drawCellMazePolygon=(context,mazeObj,cell)=>{const polyInfo=mazeObj.getMazePolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const borders=polyInfo.hasInverted&&!cell.isInverted?cell.invertedBorders:cell.borders;fillPolygon(context,cell.point,points);applyBorders(context,cell.point,points,borders);if(MENU_CONFIG.showPos&&cell.pos)showPos(context,cell.pos,cell.point,isInverted,polyInfo.ySide);};const drawCellMazeCircle=(context,cell,circlePoint)=>{const{topRadius,bottomRadius,topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,}=cell.circleProps;context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.closePath();context.fill();if(cell.borders[0]){context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.stroke();}if(cell.borders[1]){context.beginPath();context.moveTo(topRightPoint.x,topRightPoint.y);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.stroke();}if(cell.borders[2]){context.beginPath();context.moveTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.stroke();}if(cell.borders[3]){context.beginPath();context.moveTo(bottomLeftPoint.x,bottomLeftPoint.y);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.stroke();}};const audios=({});let MUSIC_VOLUME=1;const TRACK_FILES={[TRACK_TYPES.TRACK1]:"sounds/blocks/track1.wav",[TRACK_TYPES.TRACK2]:"sounds/blocks/track2.wav",[TRACK_TYPES.TRACK3]:"sounds/blocks/track3.wav",[TRACK_TYPES.TRACK4]:"sounds/blocks/track4.wav",[TRACK_TYPES.TRACK5]:"sounds/blocks/track5.wav",[TRACK_TYPES.TRACK6]:"sounds/blocks/track6.wav",[TRACK_TYPES.TRACK7]:"sounds/blocks/track7.wav",[TRACK_TYPES.TRACK8]:"sounds/blocks/track8.wav",[TRACK_TYPES.TRACK11]:"sounds/blocks/track11.wav",[TRACK_TYPES.TRACK14]:"sounds/blocks/track14.wav",[TRACK_TYPES.TRACK15]:"sounds/blocks/track15.wav",[TRACK_TYPES.TRACK16]:"sounds/blocks/track16.wav",};Object.entries(TRACK_FILES).forEach(([track,path])=>{const pan=+track.replace("TRACK","")%2?-1:1;const ctx=new AudioContext();const srcNode=ctx.createBufferSource();const gainNode=ctx.createGain();gainNode.gain.value=0;gainNode.connect(ctx.destination);const ambientPan=ctx.createStereoPanner();ambientPan.pan.value=pan;ambientPan.connect(gainNode);audios[track]={srcNode,gainNode,volume:0};fetch(path,{mode:"cors"}).then((resp)=>resp.arrayBuffer()).then((buffer)=>ctx.decodeAudioData(buffer,(abuffer)=>{srcNode.buffer=abuffer;srcNode.connect(ambientPan);srcNode.loop=true;srcNode.loopEnd=35.99;}));});const audiosList=Object.values(audios);const TRACK_LIST=Object.keys(TRACK_FILES);let audioStarted=false;const updateTracks=(tracksCount)=>{if(MENU_CONFIG.music){const polyInfo=getPolyInfo();const max=polyInfo.rows*polyInfo.columns*1.2;TRACK_LIST.forEach((track)=>{const audio=audios[track];audio.volume=(tracksCount[track]||0)/max;updateTrackVolume(audio);if(!audioStarted)audio.srcNode.start();});audioStarted=true;}else{audiosList.forEach((a)=>(a.gainNode.gain.value=0));}};const setMusicVolume=(volume)=>{MUSIC_VOLUME=volume;TRACK_LIST.forEach((track)=>updateTrackVolume(audios[track]));};const updateTrackVolume=(audio)=>{const{gainNode,volume}=audio;gainNode.gain.value=(MUSIC_VOLUME*volume)/100;};const canvasLayers =([]);const contextsLayers =([]);for (let i =0;i <DRAW_CONFIG.maxLayer;i++){const canvas =document.createElement("canvas");canvasContainer.appendChild(canvas);canvasLayers.push(canvas);contextsLayers.push(canvas.getContext("2d"));}const setCanvasSize =(height,width)=>{drawContainer.style.setProperty("--canvas-height",`${height}px`);canvasLayers.forEach((canvas)=>(canvas.height =height));drawContainer.style.setProperty("--canvas-width",`${width}px`);canvasLayers.forEach((canvas)=>(canvas.width =width));};const setFavicon =()=>{const link =(document.querySelector("link[rel~='icon']"));link.href=POLYGONS_IMAGES[RENDER_INFO.currentPoly];};const updateConfigs=()=>{canvasContainer.classList[MENU_CONFIG.usePerspective?"add":"remove"]("perspective");};const clearCanvas=(canvas)=>{canvas.width=canvas.width;};const drawWall=(wall,context)=>{if(!wall.borderMap||wall.borderMap.find((b)=>!!b))drawItem(context,wall);};const drawWallTop=(wall,context)=>{drawItem(context,wall.topInfo);context.strokeStyle=wall.isSelectedCell?RENDER_CONFIG.selectedBorderColor:RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,wall.topInfo.point,wall.topInfo.points,wall.borderMap);};const drawItem=(context,{point,points,pos,isInverted,color,modifier,isSelectedCell})=>{context.fillStyle=color?getFillStyle(color,modifier):RENDER_CONFIG.emptyColor;fillPolygon(context,point,points);if(MENU_CONFIG.showPos&&pos)showPos(context,pos,point,isInverted,getPolyInfo().ySide);if(isSelectedCell){context.strokeStyle=RENDER_CONFIG.selectedBorderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}else if(MENU_CONFIG.showChunks&&pos)showChunks(context,pos,point,points);};const getFillStyle=(color,modifier=1)=>color===EMPTY_BLOCK.color?"transparent":`rgb(`+`${color.r *modifier},`+`${color.g *modifier},`+`${color.b *modifier})`;const getStyleModifier=(intensity)=>{if(!ENTITY_INFO.timeOfDay)return 1;let modifier=1-ENTITY_INFO.timeOfDay/100;if(intensity>=0)modifier=(1-modifier)/(intensity||1)+modifier;return modifier;};const fillPolygon=(context,{x,y},points)=>{context.beginPath();for(const point of points){context.lineTo(x+point.x,y+point.y);}context.closePath();context.fill();};const applyBorders=(context,{x,y},points,map,ignoreLast)=>{for(let i=0;i<points.length;i++){if(!map?.length||map[i]){const point=points[i];let nextPoint=points[i+1];if(!nextPoint){if(ignoreLast)return;nextPoint=points[0];}const pointA={x:x+point.x,y:y+point.y};const pointB={x:x+nextPoint.x,y:y+nextPoint.y};drawLine(context,pointA,pointB);}}};const drawLine=(context,pointA,pointB)=>{context.beginPath();context.moveTo(pointA.x,pointA.y);context.lineTo(pointB.x,pointB.y);context.stroke();};const showPos=(context,pos,point,isInverted,ySide)=>{context.fillStyle="black";context.font=`bold ${ySide /2}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${pos.i},${pos.j}`,point.x,isInverted?point.y+ySide/2:point.y);};const showChunks=(context,pos,point,points)=>{if(pos.i%GENERATION_CONFIG.chunkSize===0||pos.j%GENERATION_CONFIG.chunkSize===0){context.strokeStyle=RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}};const mineValueColors=["blue","green","red","darkblue","brown","darkred","black","grey",];const showMineValue=(context,value,point,isInverted,ySide)=>{if(value){context.fillStyle=mineValueColors[value-1];context.font=`bold ${ySide}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${value}`,point.x,isInverted?point.y+ySide/2:point.y);}};const drawCircle=(context,point,radius)=>{context.beginPath();context.arc(point.x,point.y,radius,0,2*Math.PI);context.fillStyle="black";context.fill();};const fishingCanvas=(document.getElementById("fishing-canvas"));const fishingContext=fishingCanvas.getContext("2d");const fishingLineCanvas=(document.getElementById("fishing-line-canvas"));const fishingLineContext=fishingLineCanvas.getContext("2d");fishingLineContext.strokeStyle="black";const fishingContainer=document.getElementById("fishing-container");const fishingRodImg=(document.getElementById("fishing-rod"));const fishingRodPos=({i:8,j:0});const fishingFishImg=(document.getElementById("fishing-fish"));const fishingFishPos=({i:2,j:1});const FISHING_CONFIG={mazeSize:7,cellHeight:45,circleMazeSize:5,circleCellHeight:30,isCircleProbability:0.05,secondsToFish:20,timerDelay:100,timer:null,};let fishingMazeObj=(null);let IS_FISHING_ACTIVE=false;let FISHING_IS_CIRCLE=false;const setFishingCanvasSize=({height,width})=>{fishingLineCanvas.height=fishingCanvas.height=height;fishingLineCanvas.width=fishingCanvas.width=width;};const getFishingRodPoint=()=>FISHING_IS_CIRCLE?fishingMazeObj.getCirclePoint():fishingMazeObj.getLastMazeCell().point;const drawFishingLine=()=>{fishingLineCanvas.height=fishingLineCanvas.height;const fishPoint=fishingMazeObj.getCurrentMazeCell().point;const rodPoint=getFishingRodPoint();fishingLineContext.moveTo(fishPoint.x,fishPoint.y);fishingLineContext.lineTo(rodPoint.x,rodPoint.y);fishingLineContext.stroke();};const initFishingImages=()=>{const{ySide}=fishingMazeObj.getMazePolyInfo();setImagePos(fishingRodImg,fishingRodPos);setEntityImageSize(fishingRodImg,ySide);setImagePoint(fishingRodImg,getFishingRodPoint(),true,ySide);setImagePos(fishingFishImg,fishingFishPos);setEntityImageSize(fishingFishImg,ySide);setImagePoint(fishingFishImg,fishingMazeObj.getCurrentMazeCell().point,true,ySide);drawFishingLine();};const stopFishing=()=>{clearInterval(FISHING_CONFIG.timer);fishingContainer.classList.add("hide");IS_FISHING_ACTIVE=false;};const initFishingMazeObj=()=>{if(!fishingMazeObj)fishingMazeObj=createMazeObj({cellHeight:FISHING_CONFIG.cellHeight,rows:FISHING_CONFIG.mazeSize,columns:FISHING_CONFIG.mazeSize,},{cellHeight:FISHING_CONFIG.circleCellHeight,rows:FISHING_CONFIG.circleMazeSize,columns:FISHING_CONFIG.circleMazeSize,});fishingMazeObj.setIsCircle(FISHING_IS_CIRCLE);fishingMazeObj.buildMaze();};const initFishingTimer=(height)=>{fishingContainer.style.setProperty("--fishing-progress-bar-init-height",`${height}px`);fishingContainer.style.setProperty("--fishing-progress-bar-height",`${height}px`);let currentHeight=height;const timerSteps=height/((FISHING_CONFIG.secondsToFish*1000)/FISHING_CONFIG.timerDelay);FISHING_CONFIG.timer=setInterval(()=>{currentHeight-=timerSteps;fishingContainer.style.setProperty("--fishing-progress-bar-height",`${currentHeight}px`);if(currentHeight<=0){stopFishing();hurtEntity(PLAYER_ENTITY,1);}},FISHING_CONFIG.timerDelay);};let fishingFluidInterval=null;const initFishingDraw=(mazeObj)=>{clearInterval(fishingFluidInterval);const cells=([]);for(const pos of mazeObj.iterateOverMaze()){const cell=mazeObj.getMazeCell(pos);cells.push(cell);drawCellMaze(fishingContext,mazeObj,cell,tweakColor(BLOCKS.WATER.color));}if(!cells.length)return;fishingFluidInterval=setInterval(()=>{cells.forEach((c)=>drawCellMaze(fishingContext,mazeObj,c,tweakColor(BLOCKS.WATER.color)));},DRAW_CONFIG.fluidSpeed);};const startFishing=()=>{if(IS_FISHING_ACTIVE)return stopFishing();IS_FISHING_ACTIVE=true;FISHING_IS_CIRCLE=Math.random()<FISHING_CONFIG.isCircleProbability;initFishingMazeObj();const size=fishingMazeObj.getMazeSize();size.height+=FISHING_CONFIG.cellHeight/9;setFishingCanvasSize(size);initFishingImages();fishingContainer.classList.remove("hide");initFishingTimer(size.height);initFishingDraw(fishingMazeObj);};let canMoveFishing=true;const moveFishing=(code,useDiagonal)=>{if(canMoveFishing){const{ySide,hasInverted,polySides}=fishingMazeObj.getMazePolyInfo();const currentCell=fishingMazeObj.getCurrentMazeCell();const aIndex=getMovementMap(currentCell,useDiagonal,0,polySides,!FISHING_IS_CIRCLE&&hasInverted)[code];const nextCell=fishingMazeObj.mazeMove(aIndex);if(!nextCell)return;if(fishingMazeObj.isMazeSolved()){stopFishing();giveItemToEntity(PLAYER_ENTITY,{imgPos:fishingFishPos,health:1});return;}setImagePoint(fishingFishImg,nextCell.point,true,ySide);drawFishingLine();canMoveFishing=false;setTimeout(()=>{canMoveFishing=true;},100);}};const fishingCanvas=(document.getElementById("fishing-canvas"));const fishingContext=fishingCanvas.getContext("2d");const fishingLineCanvas=(document.getElementById("fishing-line-canvas"));const fishingLineContext=fishingLineCanvas.getContext("2d");fishingLineContext.strokeStyle="black";const fishingContainer=document.getElementById("fishing-container");const fishingRodImg=(document.getElementById("fishing-rod"));const fishingRodPos=({i:8,j:0});const fishingFishImg=(document.getElementById("fishing-fish"));const fishingFishPos=({i:2,j:1});const FISHING_CONFIG={mazeSize:7,cellHeight:45,circleMazeSize:5,circleCellHeight:30,isCircleProbability:0.05,secondsToFish:20,timerDelay:100,timer:null,};let fishingMazeObj=(null);let IS_FISHING_ACTIVE=false;let FISHING_IS_CIRCLE=false;const setFishingCanvasSize=({height,width})=>{fishingLineCanvas.height=fishingCanvas.height=height;fishingLineCanvas.width=fishingCanvas.width=width;};const getFishingRodPoint=()=>FISHING_IS_CIRCLE?fishingMazeObj.getCirclePoint():fishingMazeObj.getLastMazeCell().point;const drawFishingLine=()=>{fishingLineCanvas.height=fishingLineCanvas.height;const fishPoint=fishingMazeObj.getCurrentMazeCell().point;const rodPoint=getFishingRodPoint();fishingLineContext.moveTo(fishPoint.x,fishPoint.y);fishingLineContext.lineTo(rodPoint.x,rodPoint.y);fishingLineContext.stroke();};const initFishingImages=()=>{const{ySide}=fishingMazeObj.getMazePolyInfo();setImagePos(fishingRodImg,fishingRodPos);setEntityImageSize(fishingRodImg,ySide);setImagePoint(fishingRodImg,getFishingRodPoint(),true,ySide);setImagePos(fishingFishImg,fishingFishPos);setEntityImageSize(fishingFishImg,ySide);setImagePoint(fishingFishImg,fishingMazeObj.getCurrentMazeCell().point,true,ySide);drawFishingLine();};const stopFishing=()=>{clearInterval(FISHING_CONFIG.timer);fishingContainer.classList.add("hide");IS_FISHING_ACTIVE=false;};const initFishingMazeObj=()=>{if(!fishingMazeObj)fishingMazeObj=createMazeObj({cellHeight:FISHING_CONFIG.cellHeight,rows:FISHING_CONFIG.mazeSize,columns:FISHING_CONFIG.mazeSize,},{cellHeight:FISHING_CONFIG.circleCellHeight,rows:FISHING_CONFIG.circleMazeSize,columns:FISHING_CONFIG.circleMazeSize,});fishingMazeObj.setIsCircle(FISHING_IS_CIRCLE);fishingMazeObj.buildMaze();};const initFishingTimer=(height)=>{fishingContainer.style.setProperty("--fishing-progress-bar-init-height",`${height}px`);fishingContainer.style.setProperty("--fishing-progress-bar-height",`${height}px`);let currentHeight=height;const timerSteps=height/((FISHING_CONFIG.secondsToFish*1000)/FISHING_CONFIG.timerDelay);FISHING_CONFIG.timer=setInterval(()=>{currentHeight-=timerSteps;fishingContainer.style.setProperty("--fishing-progress-bar-height",`${currentHeight}px`);if(currentHeight<=0){stopFishing();hurtEntity(PLAYER_ENTITY,1);}},FISHING_CONFIG.timerDelay);};let fishingFluidInterval=null;const initFishingDraw=(mazeObj)=>{clearInterval(fishingFluidInterval);const cells=([]);for(const pos of mazeObj.iterateOverMaze()){const cell=mazeObj.getMazeCell(pos);cells.push(cell);drawCellMaze(fishingContext,mazeObj,cell,tweakColor(BLOCKS.WATER.color));}if(!cells.length)return;fishingFluidInterval=setInterval(()=>{cells.forEach((c)=>drawCellMaze(fishingContext,mazeObj,c,tweakColor(BLOCKS.WATER.color)));},DRAW_CONFIG.fluidSpeed);};const startFishing=()=>{if(IS_FISHING_ACTIVE)return stopFishing();IS_FISHING_ACTIVE=true;FISHING_IS_CIRCLE=Math.random()<FISHING_CONFIG.isCircleProbability;initFishingMazeObj();const size=fishingMazeObj.getMazeSize();size.height+=FISHING_CONFIG.cellHeight/9;setFishingCanvasSize(size);initFishingImages();fishingContainer.classList.remove("hide");initFishingTimer(size.height);initFishingDraw(fishingMazeObj);};let canMoveFishing=true;const moveFishing=(code,useDiagonal)=>{if(canMoveFishing){const{ySide,hasInverted,polySides}=fishingMazeObj.getMazePolyInfo();const currentCell=fishingMazeObj.getCurrentMazeCell();const aIndex=getMovementMap(currentCell,useDiagonal,0,polySides,!FISHING_IS_CIRCLE&&hasInverted)[code];const nextCell=fishingMazeObj.mazeMove(aIndex);if(!nextCell)return;if(fishingMazeObj.isMazeSolved()){stopFishing();giveItemToEntity(PLAYER_ENTITY,{imgPos:fishingFishPos,health:1});return;}setImagePoint(fishingFishImg,nextCell.point,true,ySide);drawFishingLine();canMoveFishing=false;setTimeout(()=>{canMoveFishing=true;},100);}};const audios=({});let MUSIC_VOLUME=1;const TRACK_FILES={[TRACK_TYPES.TRACK1]:"sounds/blocks/track1.wav",[TRACK_TYPES.TRACK2]:"sounds/blocks/track2.wav",[TRACK_TYPES.TRACK3]:"sounds/blocks/track3.wav",[TRACK_TYPES.TRACK4]:"sounds/blocks/track4.wav",[TRACK_TYPES.TRACK5]:"sounds/blocks/track5.wav",[TRACK_TYPES.TRACK6]:"sounds/blocks/track6.wav",[TRACK_TYPES.TRACK7]:"sounds/blocks/track7.wav",[TRACK_TYPES.TRACK8]:"sounds/blocks/track8.wav",[TRACK_TYPES.TRACK11]:"sounds/blocks/track11.wav",[TRACK_TYPES.TRACK14]:"sounds/blocks/track14.wav",[TRACK_TYPES.TRACK15]:"sounds/blocks/track15.wav",[TRACK_TYPES.TRACK16]:"sounds/blocks/track16.wav",};Object.entries(TRACK_FILES).forEach(([track,path])=>{const pan=+track.replace("TRACK","")%2?-1:1;const ctx=new AudioContext();const srcNode=ctx.createBufferSource();const gainNode=ctx.createGain();gainNode.gain.value=0;gainNode.connect(ctx.destination);const ambientPan=ctx.createStereoPanner();ambientPan.pan.value=pan;ambientPan.connect(gainNode);audios[track]={srcNode,gainNode,volume:0};fetch(path,{mode:"cors"}).then((resp)=>resp.arrayBuffer()).then((buffer)=>ctx.decodeAudioData(buffer,(abuffer)=>{srcNode.buffer=abuffer;srcNode.connect(ambientPan);srcNode.loop=true;srcNode.loopEnd=35.99;}));});const audiosList=Object.values(audios);const TRACK_LIST=Object.keys(TRACK_FILES);let audioStarted=false;const updateTracks=(tracksCount)=>{if(MENU_CONFIG.music){const polyInfo=getPolyInfo();const max=polyInfo.rows*polyInfo.columns*1.2;TRACK_LIST.forEach((track)=>{const audio=audios[track];audio.volume=(tracksCount[track]||0)/max;updateTrackVolume(audio);if(!audioStarted)audio.srcNode.start();});audioStarted=true;}else{audiosList.forEach((a)=>(a.gainNode.gain.value=0));}};const setMusicVolume=(volume)=>{MUSIC_VOLUME=volume;TRACK_LIST.forEach((track)=>updateTrackVolume(audios[track]));};const updateTrackVolume=(audio)=>{const{gainNode,volume}=audio;gainNode.gain.value=(MUSIC_VOLUME*volume)/100;};const MAP_CONFIG={currentPosRatio:5,posRatio:5,fullScreenPosRatio:50,playerColor:({r:212,g:172,b:156,}),xRatio:0,yRatio:0,};const mapCanvas=(document.getElementById("map-canvas"));const mapContext=mapCanvas.getContext("2d");const resetBiomeMap=()=>{let size=0;if(fullMap){size=Math.min(window.innerWidth,window.innerHeight)*0.96;MAP_CONFIG.currentPosRatio=MAP_CONFIG.fullScreenPosRatio;}else{size=mapCanvas.parentElement.offsetWidth;MAP_CONFIG.currentPosRatio=MAP_CONFIG.posRatio;}mapCanvas.width=size;mapCanvas.height=size;MAP_CONFIG.xRatio=mapCanvas.width/(MAP_CONFIG.currentPosRatio*2+1);MAP_CONFIG.yRatio=mapCanvas.height/(MAP_CONFIG.currentPosRatio*2+1);};const updateBiomeMap=()=>{clearCanvas(mapCanvas);const biomes=getBiomeMap();const iOffset=Math.round(RENDER_INFO.iOffset/GENERATION_CONFIG.chunkSize);const jOffset=Math.round(RENDER_INFO.jOffset/GENERATION_CONFIG.chunkSize);const iNegLimit=iOffset-MAP_CONFIG.currentPosRatio;const iPosLimit=iOffset+MAP_CONFIG.currentPosRatio+1;const jNegLimit=jOffset-MAP_CONFIG.currentPosRatio;const jPosLimit=jOffset+MAP_CONFIG.currentPosRatio+1;for(let i=iNegLimit;i<=iPosLimit;i++){const nI=i-iOffset;for(let j=jNegLimit;j<=jPosLimit;j++){const nJ=j-jOffset;const biome=biomes[i]?.[j];if(!biome)continue;createRect({i:nI,j:nJ},biome.mapColor);}}createRect({i:0,j:0},MAP_CONFIG.playerColor);};let fullMap=false;const toggleFullMap=(toggle=!fullMap)=>{fullMap=toggle;if(toggle){mapCanvas.classList.add("full-screen");resetBiomeMap();updateBiomeMap();}else{mapCanvas.classList.remove("full-screen");resetBiomeMap();updateBiomeMap();}};const createRect=(pos,color)=>{mapContext.fillStyle=getFillStyle(color);mapContext.fillRect((MAP_CONFIG.currentPosRatio+pos.j)*MAP_CONFIG.xRatio,(MAP_CONFIG.currentPosRatio+pos.i)*MAP_CONFIG.yRatio,MAP_CONFIG.xRatio,MAP_CONFIG.yRatio);};const areColorsEqual=(color1,color2)=>color1.r===color2.r&&color1.g===color2.g&&color1.b===color2.b;const PLACE_CONFIG={cellHeight:24,canvasNum:7,};const BLOCKS_LISTS=Object.values(BLOCKS).filter((b)=>!b.isFluid).filter((b,i,a)=>!a.find((b2,i2)=>areColorsEqual(b.color,b2.color)&&i<i2));PLACE_CONFIG.steps=360/PLACE_CONFIG.canvasNum;let PLACE_POLYS_INFO=(null);const placeContainer=document.getElementById("place-canvas-container");const placeCanvas=([]);const placeContexts=([]);for(let i=0;i<PLACE_CONFIG.canvasNum;i++){const canvas=document.createElement("canvas");canvas.style.setProperty("--place-rotate-canvas",`${PLACE_CONFIG.steps *i}deg`);placeContainer.appendChild(canvas);placeCanvas.push(canvas);placeContexts.push(canvas.getContext("2d"));}placeContainer.ontouchend=()=>{};const getSelectedBlockToPlace=()=>{const block=BLOCKS_LISTS[getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length)];return{block,color:block.color};};const resetPlace=()=>{placeCanvas.forEach((p)=>{p.width=placeContainer.parentElement.offsetWidth;p.height=placeContainer.parentElement.offsetHeight;});showSelectedPlaceBlocks();};const drawPlaceBlock=(context,block)=>{if(!PLACE_POLYS_INFO){PLACE_POLYS_INFO={};for(const p of KNOWN_POLYGONS_VALUES){PLACE_POLYS_INFO[p]=configPoly(p,PLACE_CONFIG.cellHeight);}}const polyInfo=PLACE_POLYS_INFO[RENDER_INFO.currentPoly];const wall=blockToWall({block,color:block.color},{x:placeContainer.parentElement.offsetWidth/2,y:placeContainer.parentElement.offsetHeight/1.75,},{isInverted:polyInfo.hasInverted},polyInfo);drawWall(wall,context);applyBorders(context,wall.point,wall.points,[],true);drawWallTop(wall,context);};let SELECTED_PLACE_BLOCKS=0;let PLACE_BLOCKS_DEG=0;const movePlaceBlocks=(orientation)=>{SELECTED_PLACE_BLOCKS=SELECTED_PLACE_BLOCKS+orientation;PLACE_BLOCKS_DEG+=orientation>0?PLACE_CONFIG.steps:-PLACE_CONFIG.steps;placeContainer.style.setProperty("--place-rotate-container",`${-PLACE_BLOCKS_DEG}deg`);showSelectedPlaceBlocks();};const showSelectedPlaceBlocks=()=>{const showIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS+1,PLACE_CONFIG.canvasNum),];const drawIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS+1,BLOCKS_LISTS.length),];placeCanvas.forEach((p,i)=>{p.classList[showIndexes.includes(i)?"add":"remove"]("active");});showIndexes.forEach((index,i)=>{clearCanvas(placeCanvas[index]);drawPlaceBlock(placeContexts[index],BLOCKS_LISTS[drawIndexes[i]]);});};const resetToolbar=()=>{resetBiomeMap();resetPlace();};const fishingCanvas=(document.getElementById("fishing-canvas"));const fishingContext=fishingCanvas.getContext("2d");const fishingLineCanvas=(document.getElementById("fishing-line-canvas"));const fishingLineContext=fishingLineCanvas.getContext("2d");fishingLineContext.strokeStyle="black";const fishingContainer=document.getElementById("fishing-container");const fishingRodImg=(document.getElementById("fishing-rod"));const fishingRodPos=({i:8,j:0});const fishingFishImg=(document.getElementById("fishing-fish"));const fishingFishPos=({i:2,j:1});const FISHING_CONFIG={mazeSize:7,cellHeight:45,circleMazeSize:5,circleCellHeight:30,isCircleProbability:0.05,secondsToFish:20,timerDelay:100,timer:null,};let fishingMazeObj=(null);let IS_FISHING_ACTIVE=false;let FISHING_IS_CIRCLE=false;const setFishingCanvasSize=({height,width})=>{fishingLineCanvas.height=fishingCanvas.height=height;fishingLineCanvas.width=fishingCanvas.width=width;};const getFishingRodPoint=()=>FISHING_IS_CIRCLE?fishingMazeObj.getCirclePoint():fishingMazeObj.getLastMazeCell().point;const drawFishingLine=()=>{fishingLineCanvas.height=fishingLineCanvas.height;const fishPoint=fishingMazeObj.getCurrentMazeCell().point;const rodPoint=getFishingRodPoint();fishingLineContext.moveTo(fishPoint.x,fishPoint.y);fishingLineContext.lineTo(rodPoint.x,rodPoint.y);fishingLineContext.stroke();};const initFishingImages=()=>{const{ySide}=fishingMazeObj.getMazePolyInfo();setImagePos(fishingRodImg,fishingRodPos);setEntityImageSize(fishingRodImg,ySide);setImagePoint(fishingRodImg,getFishingRodPoint(),true,ySide);setImagePos(fishingFishImg,fishingFishPos);setEntityImageSize(fishingFishImg,ySide);setImagePoint(fishingFishImg,fishingMazeObj.getCurrentMazeCell().point,true,ySide);drawFishingLine();};const stopFishing=()=>{clearInterval(FISHING_CONFIG.timer);fishingContainer.classList.add("hide");IS_FISHING_ACTIVE=false;};const initFishingMazeObj=()=>{if(!fishingMazeObj)fishingMazeObj=createMazeObj({cellHeight:FISHING_CONFIG.cellHeight,rows:FISHING_CONFIG.mazeSize,columns:FISHING_CONFIG.mazeSize,},{cellHeight:FISHING_CONFIG.circleCellHeight,rows:FISHING_CONFIG.circleMazeSize,columns:FISHING_CONFIG.circleMazeSize,});fishingMazeObj.setIsCircle(FISHING_IS_CIRCLE);fishingMazeObj.buildMaze();};const initFishingTimer=(height)=>{fishingContainer.style.setProperty("--fishing-progress-bar-init-height",`${height}px`);fishingContainer.style.setProperty("--fishing-progress-bar-height",`${height}px`);let currentHeight=height;const timerSteps=height/((FISHING_CONFIG.secondsToFish*1000)/FISHING_CONFIG.timerDelay);FISHING_CONFIG.timer=setInterval(()=>{currentHeight-=timerSteps;fishingContainer.style.setProperty("--fishing-progress-bar-height",`${currentHeight}px`);if(currentHeight<=0){stopFishing();hurtEntity(PLAYER_ENTITY,1);}},FISHING_CONFIG.timerDelay);};let fishingFluidInterval=null;const initFishingDraw=(mazeObj)=>{clearInterval(fishingFluidInterval);const cells=([]);for(const pos of mazeObj.iterateOverMaze()){const cell=mazeObj.getMazeCell(pos);cells.push(cell);drawCellMaze(fishingContext,mazeObj,cell,tweakColor(BLOCKS.WATER.color));}if(!cells.length)return;fishingFluidInterval=setInterval(()=>{cells.forEach((c)=>drawCellMaze(fishingContext,mazeObj,c,tweakColor(BLOCKS.WATER.color)));},DRAW_CONFIG.fluidSpeed);};const startFishing=()=>{if(IS_FISHING_ACTIVE)return stopFishing();IS_FISHING_ACTIVE=true;FISHING_IS_CIRCLE=Math.random()<FISHING_CONFIG.isCircleProbability;initFishingMazeObj();const size=fishingMazeObj.getMazeSize();size.height+=FISHING_CONFIG.cellHeight/9;setFishingCanvasSize(size);initFishingImages();fishingContainer.classList.remove("hide");initFishingTimer(size.height);initFishingDraw(fishingMazeObj);};let canMoveFishing=true;const moveFishing=(code,useDiagonal)=>{if(canMoveFishing){const{ySide,hasInverted,polySides}=fishingMazeObj.getMazePolyInfo();const currentCell=fishingMazeObj.getCurrentMazeCell();const aIndex=getMovementMap(currentCell,useDiagonal,0,polySides,!FISHING_IS_CIRCLE&&hasInverted)[code];const nextCell=fishingMazeObj.mazeMove(aIndex);if(!nextCell)return;if(fishingMazeObj.isMazeSolved()){stopFishing();giveItemToEntity(PLAYER_ENTITY,{imgPos:fishingFishPos,health:1});return;}setImagePoint(fishingFishImg,nextCell.point,true,ySide);drawFishingLine();canMoveFishing=false;setTimeout(()=>{canMoveFishing=true;},100);}};const MAP_CONFIG={currentPosRatio:5,posRatio:5,fullScreenPosRatio:50,playerColor:({r:212,g:172,b:156,}),xRatio:0,yRatio:0,};const mapCanvas=(document.getElementById("map-canvas"));const mapContext=mapCanvas.getContext("2d");const resetBiomeMap=()=>{let size=0;if(fullMap){size=Math.min(window.innerWidth,window.innerHeight)*0.96;MAP_CONFIG.currentPosRatio=MAP_CONFIG.fullScreenPosRatio;}else{size=mapCanvas.parentElement.offsetWidth;MAP_CONFIG.currentPosRatio=MAP_CONFIG.posRatio;}mapCanvas.width=size;mapCanvas.height=size;MAP_CONFIG.xRatio=mapCanvas.width/(MAP_CONFIG.currentPosRatio*2+1);MAP_CONFIG.yRatio=mapCanvas.height/(MAP_CONFIG.currentPosRatio*2+1);};const updateBiomeMap=()=>{clearCanvas(mapCanvas);const biomes=getBiomeMap();const iOffset=Math.round(RENDER_INFO.iOffset/GENERATION_CONFIG.chunkSize);const jOffset=Math.round(RENDER_INFO.jOffset/GENERATION_CONFIG.chunkSize);const iNegLimit=iOffset-MAP_CONFIG.currentPosRatio;const iPosLimit=iOffset+MAP_CONFIG.currentPosRatio+1;const jNegLimit=jOffset-MAP_CONFIG.currentPosRatio;const jPosLimit=jOffset+MAP_CONFIG.currentPosRatio+1;for(let i=iNegLimit;i<=iPosLimit;i++){const nI=i-iOffset;for(let j=jNegLimit;j<=jPosLimit;j++){const nJ=j-jOffset;const biome=biomes[i]?.[j];if(!biome)continue;createRect({i:nI,j:nJ},biome.mapColor);}}createRect({i:0,j:0},MAP_CONFIG.playerColor);};let fullMap=false;const toggleFullMap=(toggle=!fullMap)=>{fullMap=toggle;if(toggle){mapCanvas.classList.add("full-screen");resetBiomeMap();updateBiomeMap();}else{mapCanvas.classList.remove("full-screen");resetBiomeMap();updateBiomeMap();}};const createRect=(pos,color)=>{mapContext.fillStyle=getFillStyle(color);mapContext.fillRect((MAP_CONFIG.currentPosRatio+pos.j)*MAP_CONFIG.xRatio,(MAP_CONFIG.currentPosRatio+pos.i)*MAP_CONFIG.yRatio,MAP_CONFIG.xRatio,MAP_CONFIG.yRatio);};const MAP_CONFIG={currentPosRatio:5,posRatio:5,fullScreenPosRatio:50,playerColor:({r:212,g:172,b:156,}),xRatio:0,yRatio:0,};const mapCanvas=(document.getElementById("map-canvas"));const mapContext=mapCanvas.getContext("2d");const resetBiomeMap=()=>{let size=0;if(fullMap){size=Math.min(window.innerWidth,window.innerHeight)*0.96;MAP_CONFIG.currentPosRatio=MAP_CONFIG.fullScreenPosRatio;}else{size=mapCanvas.parentElement.offsetWidth;MAP_CONFIG.currentPosRatio=MAP_CONFIG.posRatio;}mapCanvas.width=size;mapCanvas.height=size;MAP_CONFIG.xRatio=mapCanvas.width/(MAP_CONFIG.currentPosRatio*2+1);MAP_CONFIG.yRatio=mapCanvas.height/(MAP_CONFIG.currentPosRatio*2+1);};const updateBiomeMap=()=>{clearCanvas(mapCanvas);const biomes=getBiomeMap();const iOffset=Math.round(RENDER_INFO.iOffset/GENERATION_CONFIG.chunkSize);const jOffset=Math.round(RENDER_INFO.jOffset/GENERATION_CONFIG.chunkSize);const iNegLimit=iOffset-MAP_CONFIG.currentPosRatio;const iPosLimit=iOffset+MAP_CONFIG.currentPosRatio+1;const jNegLimit=jOffset-MAP_CONFIG.currentPosRatio;const jPosLimit=jOffset+MAP_CONFIG.currentPosRatio+1;for(let i=iNegLimit;i<=iPosLimit;i++){const nI=i-iOffset;for(let j=jNegLimit;j<=jPosLimit;j++){const nJ=j-jOffset;const biome=biomes[i]?.[j];if(!biome)continue;createRect({i:nI,j:nJ},biome.mapColor);}}createRect({i:0,j:0},MAP_CONFIG.playerColor);};let fullMap=false;const toggleFullMap=(toggle=!fullMap)=>{fullMap=toggle;if(toggle){mapCanvas.classList.add("full-screen");resetBiomeMap();updateBiomeMap();}else{mapCanvas.classList.remove("full-screen");resetBiomeMap();updateBiomeMap();}};const createRect=(pos,color)=>{mapContext.fillStyle=getFillStyle(color);mapContext.fillRect((MAP_CONFIG.currentPosRatio+pos.j)*MAP_CONFIG.xRatio,(MAP_CONFIG.currentPosRatio+pos.i)*MAP_CONFIG.yRatio,MAP_CONFIG.xRatio,MAP_CONFIG.yRatio);};const areColorsEqual=(color1,color2)=>color1.r===color2.r&&color1.g===color2.g&&color1.b===color2.b;const PLACE_CONFIG={cellHeight:24,canvasNum:7,};const BLOCKS_LISTS=Object.values(BLOCKS).filter((b)=>!b.isFluid).filter((b,i,a)=>!a.find((b2,i2)=>areColorsEqual(b.color,b2.color)&&i<i2));PLACE_CONFIG.steps=360/PLACE_CONFIG.canvasNum;let PLACE_POLYS_INFO=(null);const placeContainer=document.getElementById("place-canvas-container");const placeCanvas=([]);const placeContexts=([]);for(let i=0;i<PLACE_CONFIG.canvasNum;i++){const canvas=document.createElement("canvas");canvas.style.setProperty("--place-rotate-canvas",`${PLACE_CONFIG.steps *i}deg`);placeContainer.appendChild(canvas);placeCanvas.push(canvas);placeContexts.push(canvas.getContext("2d"));}placeContainer.ontouchend=()=>{};const getSelectedBlockToPlace=()=>{const block=BLOCKS_LISTS[getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length)];return{block,color:block.color};};const resetPlace=()=>{placeCanvas.forEach((p)=>{p.width=placeContainer.parentElement.offsetWidth;p.height=placeContainer.parentElement.offsetHeight;});showSelectedPlaceBlocks();};const drawPlaceBlock=(context,block)=>{if(!PLACE_POLYS_INFO){PLACE_POLYS_INFO={};for(const p of KNOWN_POLYGONS_VALUES){PLACE_POLYS_INFO[p]=configPoly(p,PLACE_CONFIG.cellHeight);}}const polyInfo=PLACE_POLYS_INFO[RENDER_INFO.currentPoly];const wall=blockToWall({block,color:block.color},{x:placeContainer.parentElement.offsetWidth/2,y:placeContainer.parentElement.offsetHeight/1.75,},{isInverted:polyInfo.hasInverted},polyInfo);drawWall(wall,context);applyBorders(context,wall.point,wall.points,[],true);drawWallTop(wall,context);};let SELECTED_PLACE_BLOCKS=0;let PLACE_BLOCKS_DEG=0;const movePlaceBlocks=(orientation)=>{SELECTED_PLACE_BLOCKS=SELECTED_PLACE_BLOCKS+orientation;PLACE_BLOCKS_DEG+=orientation>0?PLACE_CONFIG.steps:-PLACE_CONFIG.steps;placeContainer.style.setProperty("--place-rotate-container",`${-PLACE_BLOCKS_DEG}deg`);showSelectedPlaceBlocks();};const showSelectedPlaceBlocks=()=>{const showIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS+1,PLACE_CONFIG.canvasNum),];const drawIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS+1,BLOCKS_LISTS.length),];placeCanvas.forEach((p,i)=>{p.classList[showIndexes.includes(i)?"add":"remove"]("active");});showIndexes.forEach((index,i)=>{clearCanvas(placeCanvas[index]);drawPlaceBlock(placeContexts[index],BLOCKS_LISTS[drawIndexes[i]]);});};const CLOUDS_CONFIG={num:4,rows:3,columns:3,durationMult:30,offsetSize:6,offset:0,};const CLOUDS_DIRECTION_MAP={[MOVEMENT.RIGHT]:-CLOUDS_CONFIG.offsetSize,[MOVEMENT.LEFT]:CLOUDS_CONFIG.offsetSize,};const cloudsContainer=document.getElementById("clouds-container");let clouds=([]);const updateClouds=(direction)=>{if(MENU_CONFIG.clouds){if(!clouds.length){createClouds();offsetClouds(MOVEMENT.RIGHT);}setCloudShape();offsetClouds(direction);}else{cloudsContainer.classList.add("off");}};const setCloudShape=()=>{const{currentPoly,cellHeight}=RENDER_INFO;const size=Math.min(cellHeight*4,cloudsContainer.offsetWidth/(CLOUDS_CONFIG.num*CLOUDS_CONFIG.columns*1.5));cloudsContainer.className=`p${currentPoly}`;cloudsContainer.style.setProperty("--clouds-default-size",`${size}px`);};const offsetClouds=(direction)=>{const offsetSize=CLOUDS_DIRECTION_MAP[direction];if(!offsetSize)return;CLOUDS_CONFIG.offset+=offsetSize;const offsetLeft=getMod(CLOUDS_CONFIG.offset,cloudsContainer.offsetWidth);const width=cloudsContainer.offsetWidth/CLOUDS_CONFIG.num;const defaultOffsetLeft=cloudsContainer.offsetWidth/4;cloudsContainer.style.setProperty("--clouds-offset-left",`${getMod(CLOUDS_CONFIG.offset,width)-defaultOffsetLeft}px`);const offset=Math.floor(offsetLeft/width);for(let index=0;index<clouds.length;index++){clouds[index].style.setProperty("--clouds-order",`${getMod(index +offset,CLOUDS_CONFIG.num)+1}`);}};const createClouds=()=>{const min=1-CLOUDS_CONFIG.num/10;const max=Math.min(min+0.5,1);for(let i=0;i<CLOUDS_CONFIG.num;i++){const cloud=document.createElement("div");cloud.className="cloud";const scale=correctRoundError(getRandomFloat(min,max),2);const duration=Math.round(scale*CLOUDS_CONFIG.durationMult);cloud.style.setProperty("--clouds-scale",`${scale}`);cloud.style.setProperty("--clouds-animation-duration",`${duration}s`);cloudsContainer.appendChild(cloud);clouds.push(cloud);for(let j=0;j<CLOUDS_CONFIG.rows;j++){const cloudRow=document.createElement("div");cloudRow.className="cloud-row";cloud.appendChild(cloudRow);for(let z=0;z<CLOUDS_CONFIG.columns;z++){const cloudShape=document.createElement("div");cloudShape.className="cloud-shape";cloudRow.appendChild(cloudShape);}}}};const areColorsEqual=(color1,color2)=>color1.r===color2.r&&color1.g===color2.g&&color1.b===color2.b;const PLACE_CONFIG={cellHeight:24,canvasNum:7,};const BLOCKS_LISTS=Object.values(BLOCKS).filter((b)=>!b.isFluid).filter((b,i,a)=>!a.find((b2,i2)=>areColorsEqual(b.color,b2.color)&&i<i2));PLACE_CONFIG.steps=360/PLACE_CONFIG.canvasNum;let PLACE_POLYS_INFO=(null);const placeContainer=document.getElementById("place-canvas-container");const placeCanvas=([]);const placeContexts=([]);for(let i=0;i<PLACE_CONFIG.canvasNum;i++){const canvas=document.createElement("canvas");canvas.style.setProperty("--place-rotate-canvas",`${PLACE_CONFIG.steps *i}deg`);placeContainer.appendChild(canvas);placeCanvas.push(canvas);placeContexts.push(canvas.getContext("2d"));}placeContainer.ontouchend=()=>{};const getSelectedBlockToPlace=()=>{const block=BLOCKS_LISTS[getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length)];return{block,color:block.color};};const resetPlace=()=>{placeCanvas.forEach((p)=>{p.width=placeContainer.parentElement.offsetWidth;p.height=placeContainer.parentElement.offsetHeight;});showSelectedPlaceBlocks();};const drawPlaceBlock=(context,block)=>{if(!PLACE_POLYS_INFO){PLACE_POLYS_INFO={};for(const p of KNOWN_POLYGONS_VALUES){PLACE_POLYS_INFO[p]=configPoly(p,PLACE_CONFIG.cellHeight);}}const polyInfo=PLACE_POLYS_INFO[RENDER_INFO.currentPoly];const wall=blockToWall({block,color:block.color},{x:placeContainer.parentElement.offsetWidth/2,y:placeContainer.parentElement.offsetHeight/1.75,},{isInverted:polyInfo.hasInverted},polyInfo);drawWall(wall,context);applyBorders(context,wall.point,wall.points,[],true);drawWallTop(wall,context);};let SELECTED_PLACE_BLOCKS=0;let PLACE_BLOCKS_DEG=0;const movePlaceBlocks=(orientation)=>{SELECTED_PLACE_BLOCKS=SELECTED_PLACE_BLOCKS+orientation;PLACE_BLOCKS_DEG+=orientation>0?PLACE_CONFIG.steps:-PLACE_CONFIG.steps;placeContainer.style.setProperty("--place-rotate-container",`${-PLACE_BLOCKS_DEG}deg`);showSelectedPlaceBlocks();};const showSelectedPlaceBlocks=()=>{const showIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS+1,PLACE_CONFIG.canvasNum),];const drawIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS+1,BLOCKS_LISTS.length),];placeCanvas.forEach((p,i)=>{p.classList[showIndexes.includes(i)?"add":"remove"]("active");});showIndexes.forEach((index,i)=>{clearCanvas(placeCanvas[index]);drawPlaceBlock(placeContexts[index],BLOCKS_LISTS[drawIndexes[i]]);});};const resetToolbar=()=>{resetBiomeMap();resetPlace();};const resetToolbar=()=>{resetBiomeMap();resetPlace();};const rainContainer =document.getElementById("rain-container");const BIOME_RAIN_MAP ={DEFAULT:"../images/weather/rain.gif",[BIOME_TYPES.SNOW]:"../images/weather/snow.gif",};const rainAudio =new Audio("sounds/weather/rain.mp3");rainAudio.volume =0.25;rainAudio.loop =true;const lightningAudio =new Audio("sounds/weather/lightning.mp3");lightningAudio.volume =0.25;let isRainOn =false;const updateRain =()=>{if (MENU_CONFIG.rain){if (!isRainOn){clearLightning();isRainOn =true;rainAudio.play();rainContainer.classList.remove("hide");const size =RENDER_INFO.cellHeight *10;rainContainer.style.setProperty("--rain-size",`${size}px`);createLightining();}updateRainImg();}else {if (isRainOn){clearLightning();isRainOn =false;rainAudio.pause();rainContainer.classList.add("hide");}}};let lightningInterval =null;const createLightining =()=>{clearTimeout(lightningInterval);const secs =getRandomFloat(10000,30000);lightningInterval =setTimeout(()=>{rainContainer.classList.remove("lightning");rainContainer.offsetHeight;rainContainer.classList.add("lightning");lightningAudio.play();createLightining();},secs);};const clearLightning =()=>{clearTimeout(lightningInterval);rainContainer.classList.remove("lightning");};const updateRainImg =()=>{const gif =`url("${BIOME_RAIN_MAP[PLAYER_ENTITY.cell.block.biomeType]||BIOME_RAIN_MAP.DEFAULT }")`;const currentGif=rainContainer.style.getPropertyValue("--rain-img");if(gif!==currentGif)rainContainer.style.setProperty("--rain-img",gif);};const CLOUDS_CONFIG={num:4,rows:3,columns:3,durationMult:30,offsetSize:6,offset:0,};const CLOUDS_DIRECTION_MAP={[MOVEMENT.RIGHT]:-CLOUDS_CONFIG.offsetSize,[MOVEMENT.LEFT]:CLOUDS_CONFIG.offsetSize,};const cloudsContainer=document.getElementById("clouds-container");let clouds=([]);const updateClouds=(direction)=>{if(MENU_CONFIG.clouds){if(!clouds.length){createClouds();offsetClouds(MOVEMENT.RIGHT);}setCloudShape();offsetClouds(direction);}else{cloudsContainer.classList.add("off");}};const setCloudShape=()=>{const{currentPoly,cellHeight}=RENDER_INFO;const size=Math.min(cellHeight*4,cloudsContainer.offsetWidth/(CLOUDS_CONFIG.num*CLOUDS_CONFIG.columns*1.5));cloudsContainer.className=`p${currentPoly}`;cloudsContainer.style.setProperty("--clouds-default-size",`${size}px`);};const offsetClouds=(direction)=>{const offsetSize=CLOUDS_DIRECTION_MAP[direction];if(!offsetSize)return;CLOUDS_CONFIG.offset+=offsetSize;const offsetLeft=getMod(CLOUDS_CONFIG.offset,cloudsContainer.offsetWidth);const width=cloudsContainer.offsetWidth/CLOUDS_CONFIG.num;const defaultOffsetLeft=cloudsContainer.offsetWidth/4;cloudsContainer.style.setProperty("--clouds-offset-left",`${getMod(CLOUDS_CONFIG.offset,width)-defaultOffsetLeft}px`);const offset=Math.floor(offsetLeft/width);for(let index=0;index<clouds.length;index++){clouds[index].style.setProperty("--clouds-order",`${getMod(index +offset,CLOUDS_CONFIG.num)+1}`);}};const createClouds=()=>{const min=1-CLOUDS_CONFIG.num/10;const max=Math.min(min+0.5,1);for(let i=0;i<CLOUDS_CONFIG.num;i++){const cloud=document.createElement("div");cloud.className="cloud";const scale=correctRoundError(getRandomFloat(min,max),2);const duration=Math.round(scale*CLOUDS_CONFIG.durationMult);cloud.style.setProperty("--clouds-scale",`${scale}`);cloud.style.setProperty("--clouds-animation-duration",`${duration}s`);cloudsContainer.appendChild(cloud);clouds.push(cloud);for(let j=0;j<CLOUDS_CONFIG.rows;j++){const cloudRow=document.createElement("div");cloudRow.className="cloud-row";cloud.appendChild(cloudRow);for(let z=0;z<CLOUDS_CONFIG.columns;z++){const cloudShape=document.createElement("div");cloudShape.className="cloud-shape";cloudRow.appendChild(cloudShape);}}}};const updateWeather=(direction)=>{updateRain();updateClouds(direction);};const rainContainer =document.getElementById("rain-container");const BIOME_RAIN_MAP ={DEFAULT:"../images/weather/rain.gif",[BIOME_TYPES.SNOW]:"../images/weather/snow.gif",};const rainAudio =new Audio("sounds/weather/rain.mp3");rainAudio.volume =0.25;rainAudio.loop =true;const lightningAudio =new Audio("sounds/weather/lightning.mp3");lightningAudio.volume =0.25;let isRainOn =false;const updateRain =()=>{if (MENU_CONFIG.rain){if (!isRainOn){clearLightning();isRainOn =true;rainAudio.play();rainContainer.classList.remove("hide");const size =RENDER_INFO.cellHeight *10;rainContainer.style.setProperty("--rain-size",`${size}px`);createLightining();}updateRainImg();}else {if (isRainOn){clearLightning();isRainOn =false;rainAudio.pause();rainContainer.classList.add("hide");}}};let lightningInterval =null;const createLightining =()=>{clearTimeout(lightningInterval);const secs =getRandomFloat(10000,30000);lightningInterval =setTimeout(()=>{rainContainer.classList.remove("lightning");rainContainer.offsetHeight;rainContainer.classList.add("lightning");lightningAudio.play();createLightining();},secs);};const clearLightning =()=>{clearTimeout(lightningInterval);rainContainer.classList.remove("lightning");};const updateRainImg =()=>{const gif =`url("${BIOME_RAIN_MAP[PLAYER_ENTITY.cell.block.biomeType]||BIOME_RAIN_MAP.DEFAULT }")`;const currentGif=rainContainer.style.getPropertyValue("--rain-img");if(gif!==currentGif)rainContainer.style.setProperty("--rain-img",gif);};const updateWeather=(direction)=>{updateRain();updateClouds(direction);};const CLOCK_CONFIG={passHour:0.25,midNightHour:60,};const analogClock=document.getElementById("analog-clock");const digitalClock=document.getElementById("digital-clock");const hourTensSegments=document.querySelectorAll("#digital-clock-hours .digit-tens .segment");const hourUnitsSegments=document.querySelectorAll("#digital-clock-hours .digit-units .segment");const minuteTensSegments=document.querySelectorAll("#digital-clock-minutes .digit-tens .segment");const minuteUnitsSegments=document.querySelectorAll("#digital-clock-minutes .digit-units .segment");const updateClock=()=>{const{hour,hour24,minute}=getTime();if(MENU_CONFIG.digitalClock){digitalClock.classList.remove("hide");analogClock.classList.add("hide");setNumber(hourTensSegments,Math.floor(hour24/10));setNumber(hourUnitsSegments,Math.floor(hour24%10));setNumber(minuteTensSegments,Math.floor(minute/10));setNumber(minuteUnitsSegments,Math.floor(minute%10));}else{analogClock.classList.remove("hide");digitalClock.classList.add("hide");analogClock.style.setProperty("--clock-hour-rotate",`${hour *30 +minute *0.5}deg`);analogClock.style.setProperty("--clock-minute-rotate",`${minute *6}deg`);}};const passTime=()=>{ENTITY_INFO.timeOfDay+=CLOCK_CONFIG.passHour;if(ENTITY_INFO.timeOfDay>=CLOCK_CONFIG.midNightHour||ENTITY_INFO.timeOfDay<=0){CLOCK_CONFIG.passHour=-CLOCK_CONFIG.passHour;}updateClock();};const getTime=()=>{const hourRaw=(12*ENTITY_INFO.timeOfDay)/CLOCK_CONFIG.midNightHour;let hour=Math.floor(hourRaw);let minute=Math.round((hourRaw-hour)*100);minute=Math.floor(minute*0.6);minute=CLOCK_CONFIG.passHour>0?minute:60-minute;minute=getMod(minute,60);if(CLOCK_CONFIG.passHour<0)hour=Math.max((minute?11:12)-hour,0);const hour24=CLOCK_CONFIG.passHour>0?hour+12:hour;return{hour,hour24,minute};};const setNumber=(segments,value)=>{segments.forEach((el)=>{el.classList[el.classList.contains(`n${value}`)?"add":"remove"]("active");});};const CLOUDS_CONFIG={num:4,rows:3,columns:3,durationMult:30,offsetSize:6,offset:0,};const CLOUDS_DIRECTION_MAP={[MOVEMENT.RIGHT]:-CLOUDS_CONFIG.offsetSize,[MOVEMENT.LEFT]:CLOUDS_CONFIG.offsetSize,};const cloudsContainer=document.getElementById("clouds-container");let clouds=([]);const updateClouds=(direction)=>{if(MENU_CONFIG.clouds){if(!clouds.length){createClouds();offsetClouds(MOVEMENT.RIGHT);}setCloudShape();offsetClouds(direction);}else{cloudsContainer.classList.add("off");}};const setCloudShape=()=>{const{currentPoly,cellHeight}=RENDER_INFO;const size=Math.min(cellHeight*4,cloudsContainer.offsetWidth/(CLOUDS_CONFIG.num*CLOUDS_CONFIG.columns*1.5));cloudsContainer.className=`p${currentPoly}`;cloudsContainer.style.setProperty("--clouds-default-size",`${size}px`);};const offsetClouds=(direction)=>{const offsetSize=CLOUDS_DIRECTION_MAP[direction];if(!offsetSize)return;CLOUDS_CONFIG.offset+=offsetSize;const offsetLeft=getMod(CLOUDS_CONFIG.offset,cloudsContainer.offsetWidth);const width=cloudsContainer.offsetWidth/CLOUDS_CONFIG.num;const defaultOffsetLeft=cloudsContainer.offsetWidth/4;cloudsContainer.style.setProperty("--clouds-offset-left",`${getMod(CLOUDS_CONFIG.offset,width)-defaultOffsetLeft}px`);const offset=Math.floor(offsetLeft/width);for(let index=0;index<clouds.length;index++){clouds[index].style.setProperty("--clouds-order",`${getMod(index +offset,CLOUDS_CONFIG.num)+1}`);}};const createClouds=()=>{const min=1-CLOUDS_CONFIG.num/10;const max=Math.min(min+0.5,1);for(let i=0;i<CLOUDS_CONFIG.num;i++){const cloud=document.createElement("div");cloud.className="cloud";const scale=correctRoundError(getRandomFloat(min,max),2);const duration=Math.round(scale*CLOUDS_CONFIG.durationMult);cloud.style.setProperty("--clouds-scale",`${scale}`);cloud.style.setProperty("--clouds-animation-duration",`${duration}s`);cloudsContainer.appendChild(cloud);clouds.push(cloud);for(let j=0;j<CLOUDS_CONFIG.rows;j++){const cloudRow=document.createElement("div");cloudRow.className="cloud-row";cloud.appendChild(cloudRow);for(let z=0;z<CLOUDS_CONFIG.columns;z++){const cloudShape=document.createElement("div");cloudShape.className="cloud-shape";cloudRow.appendChild(cloudShape);}}}};const compass=document.getElementById("compass");const COMPASS_CONFIG={rotateDelay:750,};const updateCompass=()=>{const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;compass.style.setProperty("--compass-rotate",`${-angle}deg`);};const entitiesContainer=document.getElementById("entities");const rotateCanvas=(deg,rotateDelay)=>{rotateElement(entitiesContainer,-deg,rotateDelay);rotateElement(drawContainer,deg,rotateDelay);};const resetRotateCanvas=()=>{rotateElement(entitiesContainer);rotateElement(drawContainer);};const rotateElement=(element,deg,rotateDelay)=>{if(rotateDelay)element.style.setProperty("--transition-duration",`${rotateDelay}ms`);if(deg)element.style.setProperty("--rotate-deg",`${deg}deg`);element.classList[deg?"add":"remove"]("rotate");element.classList[deg?"add":"remove"]("zoom-in");};const CLOCK_CONFIG={passHour:0.25,midNightHour:60,};const analogClock=document.getElementById("analog-clock");const digitalClock=document.getElementById("digital-clock");const hourTensSegments=document.querySelectorAll("#digital-clock-hours .digit-tens .segment");const hourUnitsSegments=document.querySelectorAll("#digital-clock-hours .digit-units .segment");const minuteTensSegments=document.querySelectorAll("#digital-clock-minutes .digit-tens .segment");const minuteUnitsSegments=document.querySelectorAll("#digital-clock-minutes .digit-units .segment");const updateClock=()=>{const{hour,hour24,minute}=getTime();if(MENU_CONFIG.digitalClock){digitalClock.classList.remove("hide");analogClock.classList.add("hide");setNumber(hourTensSegments,Math.floor(hour24/10));setNumber(hourUnitsSegments,Math.floor(hour24%10));setNumber(minuteTensSegments,Math.floor(minute/10));setNumber(minuteUnitsSegments,Math.floor(minute%10));}else{analogClock.classList.remove("hide");digitalClock.classList.add("hide");analogClock.style.setProperty("--clock-hour-rotate",`${hour *30 +minute *0.5}deg`);analogClock.style.setProperty("--clock-minute-rotate",`${minute *6}deg`);}};const passTime=()=>{ENTITY_INFO.timeOfDay+=CLOCK_CONFIG.passHour;if(ENTITY_INFO.timeOfDay>=CLOCK_CONFIG.midNightHour||ENTITY_INFO.timeOfDay<=0){CLOCK_CONFIG.passHour=-CLOCK_CONFIG.passHour;}updateClock();};const getTime=()=>{const hourRaw=(12*ENTITY_INFO.timeOfDay)/CLOCK_CONFIG.midNightHour;let hour=Math.floor(hourRaw);let minute=Math.round((hourRaw-hour)*100);minute=Math.floor(minute*0.6);minute=CLOCK_CONFIG.passHour>0?minute:60-minute;minute=getMod(minute,60);if(CLOCK_CONFIG.passHour<0)hour=Math.max((minute?11:12)-hour,0);const hour24=CLOCK_CONFIG.passHour>0?hour+12:hour;return{hour,hour24,minute};};const setNumber=(segments,value)=>{segments.forEach((el)=>{el.classList[el.classList.contains(`n${value}`)?"add":"remove"]("active");});};const updateWidgets=()=>{updateClock();updateCompass();};const rainContainer =document.getElementById("rain-container");const BIOME_RAIN_MAP ={DEFAULT:"../images/weather/rain.gif",[BIOME_TYPES.SNOW]:"../images/weather/snow.gif",};const rainAudio =new Audio("sounds/weather/rain.mp3");rainAudio.volume =0.25;rainAudio.loop =true;const lightningAudio =new Audio("sounds/weather/lightning.mp3");lightningAudio.volume =0.25;let isRainOn =false;const updateRain =()=>{if (MENU_CONFIG.rain){if (!isRainOn){clearLightning();isRainOn =true;rainAudio.play();rainContainer.classList.remove("hide");const size =RENDER_INFO.cellHeight *10;rainContainer.style.setProperty("--rain-size",`${size}px`);createLightining();}updateRainImg();}else {if (isRainOn){clearLightning();isRainOn =false;rainAudio.pause();rainContainer.classList.add("hide");}}};let lightningInterval =null;const createLightining =()=>{clearTimeout(lightningInterval);const secs =getRandomFloat(10000,30000);lightningInterval =setTimeout(()=>{rainContainer.classList.remove("lightning");rainContainer.offsetHeight;rainContainer.classList.add("lightning");lightningAudio.play();createLightining();},secs);};const clearLightning =()=>{clearTimeout(lightningInterval);rainContainer.classList.remove("lightning");};const updateRainImg =()=>{const gif =`url("${BIOME_RAIN_MAP[PLAYER_ENTITY.cell.block.biomeType]||BIOME_RAIN_MAP.DEFAULT }")`;const currentGif=rainContainer.style.getPropertyValue("--rain-img");if(gif!==currentGif)rainContainer.style.setProperty("--rain-img",gif);};const compass=document.getElementById("compass");const COMPASS_CONFIG={rotateDelay:750,};const updateCompass=()=>{const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;compass.style.setProperty("--compass-rotate",`${-angle}deg`);};const entitiesContainer=document.getElementById("entities");const rotateCanvas=(deg,rotateDelay)=>{rotateElement(entitiesContainer,-deg,rotateDelay);rotateElement(drawContainer,deg,rotateDelay);};const resetRotateCanvas=()=>{rotateElement(entitiesContainer);rotateElement(drawContainer);};const rotateElement=(element,deg,rotateDelay)=>{if(rotateDelay)element.style.setProperty("--transition-duration",`${rotateDelay}ms`);if(deg)element.style.setProperty("--rotate-deg",`${deg}deg`);element.classList[deg?"add":"remove"]("rotate");element.classList[deg?"add":"remove"]("zoom-in");};const updateWeather=(direction)=>{updateRain();updateClouds(direction);};const updateWidgets=()=>{updateClock();updateCompass();};const CLOCK_CONFIG={passHour:0.25,midNightHour:60,};const analogClock=document.getElementById("analog-clock");const digitalClock=document.getElementById("digital-clock");const hourTensSegments=document.querySelectorAll("#digital-clock-hours .digit-tens .segment");const hourUnitsSegments=document.querySelectorAll("#digital-clock-hours .digit-units .segment");const minuteTensSegments=document.querySelectorAll("#digital-clock-minutes .digit-tens .segment");const minuteUnitsSegments=document.querySelectorAll("#digital-clock-minutes .digit-units .segment");const updateClock=()=>{const{hour,hour24,minute}=getTime();if(MENU_CONFIG.digitalClock){digitalClock.classList.remove("hide");analogClock.classList.add("hide");setNumber(hourTensSegments,Math.floor(hour24/10));setNumber(hourUnitsSegments,Math.floor(hour24%10));setNumber(minuteTensSegments,Math.floor(minute/10));setNumber(minuteUnitsSegments,Math.floor(minute%10));}else{analogClock.classList.remove("hide");digitalClock.classList.add("hide");analogClock.style.setProperty("--clock-hour-rotate",`${hour *30 +minute *0.5}deg`);analogClock.style.setProperty("--clock-minute-rotate",`${minute *6}deg`);}};const passTime=()=>{ENTITY_INFO.timeOfDay+=CLOCK_CONFIG.passHour;if(ENTITY_INFO.timeOfDay>=CLOCK_CONFIG.midNightHour||ENTITY_INFO.timeOfDay<=0){CLOCK_CONFIG.passHour=-CLOCK_CONFIG.passHour;}updateClock();};const getTime=()=>{const hourRaw=(12*ENTITY_INFO.timeOfDay)/CLOCK_CONFIG.midNightHour;let hour=Math.floor(hourRaw);let minute=Math.round((hourRaw-hour)*100);minute=Math.floor(minute*0.6);minute=CLOCK_CONFIG.passHour>0?minute:60-minute;minute=getMod(minute,60);if(CLOCK_CONFIG.passHour<0)hour=Math.max((minute?11:12)-hour,0);const hour24=CLOCK_CONFIG.passHour>0?hour+12:hour;return{hour,hour24,minute};};const setNumber=(segments,value)=>{segments.forEach((el)=>{el.classList[el.classList.contains(`n${value}`)?"add":"remove"]("active");});};const compass=document.getElementById("compass");const COMPASS_CONFIG={rotateDelay:750,};const updateCompass=()=>{const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;compass.style.setProperty("--compass-rotate",`${-angle}deg`);};const entitiesContainer=document.getElementById("entities");const rotateCanvas=(deg,rotateDelay)=>{rotateElement(entitiesContainer,-deg,rotateDelay);rotateElement(drawContainer,deg,rotateDelay);};const resetRotateCanvas=()=>{rotateElement(entitiesContainer);rotateElement(drawContainer);};const rotateElement=(element,deg,rotateDelay)=>{if(rotateDelay)element.style.setProperty("--transition-duration",`${rotateDelay}ms`);if(deg)element.style.setProperty("--rotate-deg",`${deg}deg`);element.classList[deg?"add":"remove"]("rotate");element.classList[deg?"add":"remove"]("zoom-in");};const updateWidgets=()=>{updateClock();updateCompass();};const digAudio=new Audio("sounds/actions/dig.mp3");digAudio.volume=0.25;const punchAudio=new Audio("sounds/actions/punch.mp3");punchAudio.volume=0.25;const gunShotAudio=new Audio("sounds/actions/gun-shot.mp3");gunShotAudio.volume=1;const rotateAudio=new Audio("sounds/actions/rotate.mp3");rotateAudio.volume=0.25;let canRotate=true;const canDoActions=()=>PLAYER_ENTITY.health>0;const rotate=(orientation)=>{if(canRotate){canRotate=false;RENDER_INFO.rotationTurns=PLAYER_ENTITY.selectedCellIndex=getMod(RENDER_INFO.rotationTurns+orientation,RENDER_INFO.currentPoly);if(MENU_CONFIG.rotationAnimation){rotateCanvas((360/RENDER_INFO.currentPoly)*-orientation,COMPASS_CONFIG.rotateDelay);rotateAudio.play();}updateCompass();resetDirection();setTimeout(()=>{if(MENU_CONFIG.rotationAnimation)resetRotateCanvas();drawEveryCell(PLAYER_ENTITY);canRotate=true;},COMPASS_CONFIG.rotateDelay);}};const getNextCellIndexBasedOnCode=(code,useDiagonal)=>{const aIndex=getMovementMap(PLAYER_ENTITY.cell,useDiagonal)[code];if(aIndex===undefined)return;return getMod(aIndex,RENDER_INFO.currentPoly);};let isMoving=false;const moveBaseOnCode=(direction,useDiagonal)=>{if(!direction||!canDoActions())return;if(IS_FISHING_ACTIVE){moveFishing(direction,useDiagonal);return;}isMoving=true;makeEntityRun(PLAYER_ENTITY,direction);const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined)return;const nextPos=getPosByIndex(PLAYER_ENTITY.cell,aModI);if(!nextPos)return;const nextCell=getCell(nextPos);if(cellIsBlocked(nextCell,PLAYER_ENTITY))return;move(nextCell);updateWeather(direction);};const MOVEMENT_VALUES=Object.values(MOVEMENT);const stopMoving=()=>{if(!isMoving)return;let lastSelection=PLAYER_ENTITY.currentDirection;const movementMap=getMovementMap(PLAYER_ENTITY.cell);for(const movement of MOVEMENT_VALUES){if(movementMap[movement]===PLAYER_ENTITY.selectedCellIndex){lastSelection=movement;break;}}isMoving=false;updateEntityDirection(PLAYER_ENTITY,lastSelection);};const changeSelectedOnCode=(direction,useDiagonal)=>{if(!direction)return;const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined||aModI===PLAYER_ENTITY.selectedCellIndex)return;PLAYER_ENTITY.selectedCellIndex=aModI;if(MENU_CONFIG.showSelectedCell)drawEveryCell(PLAYER_ENTITY);updateEntityDirection(PLAYER_ENTITY,direction);};const getNextPolygon=()=>KNOWN_POLYGONS_VALUES[(KNOWN_POLYGONS_VALUES.indexOf(RENDER_INFO.currentPoly)+1)%KNOWN_POLYGONS_VALUES.length];const changePolySides=()=>{RENDER_INFO.currentPoly=getNextPolygon();RENDER_INFO.rotationTurns=0;PLAYER_ENTITY.selectedCellIndex=0;updateCompass();resetDirection();resetMap();};const resetDirection=()=>updateEntityDirection(PLAYER_ENTITY,MOVEMENT.UP);const updateAndGetSelectedCell=()=>{updateEntityDirection(PLAYER_ENTITY,PLAYER_ENTITY.currentDirection);return getSelectedCell(PLAYER_ENTITY);};const dig=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(!selectedCell?.block)return;if(selectedCell.entityType){makeEntityUse(PLAYER_ENTITY);const entities=getEntitiesFromCell(selectedCell);entities.forEach((e)=>hurtEntity(e,1));punchAudio.play();move();return;}if(selectedCell.block.isFluid)return;if(selectedCell.wall){if(selectedCell.wall.block.indestructible)return;}else if(selectedCell.block.indestructible)return;makeEntityUse(PLAYER_ENTITY);digAudio.play();if(selectedCell.wall){destroyWall(selectedCell);}else{selectedCell.block=null;selectedCell.color=null;}move();};const place=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.wall||selectedCell.entityType)return;makeEntityUse(PLAYER_ENTITY);placeBlock(selectedCell);move();};const placeBlock=(cell,block,color)=>{if(!cell||!!cell.entityType)return;if(!block){const cellBlock=getSelectedBlockToPlace();if(!cellBlock)return;block=cellBlock.block;color=cellBlock.color;}digAudio.play();if(cell.block&&!cell.block.isFluid){cell.wall={block:block,color:color};}else{cell.block=block;cell.color=color;}};const useBoat=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();const canMove=!selectedCell.wall&&selectedCell.block;if(PLAYER_ENTITY.connectedEntities[ENTITY_TYPES.BOAT]){if(!selectedCell?.block?.isFluid&&canMove){getOutBoat(PLAYER_ENTITY);move(selectedCell);}return;}if(selectedCell.entityType===ENTITY_TYPES.BOAT){getInBoat(PLAYER_ENTITY);move(selectedCell);}else if(canMove){makeEntityUse(PLAYER_ENTITY);addBoat(selectedCell,PLAYER_ENTITY);}};const useGun=()=>{const range=getPolyInfo().hasInverted?1:10;updateAndGetSelectedCell();gunShotAudio.currentTime=0;let{cell,selectedCellIndex}=PLAYER_ENTITY;for(let i=0;i<range;i++){const nextCell=getCell(getPosByIndex(cell,selectedCellIndex));if(nextCell.wall)break;cell=nextCell;drawCircleOnCell(cell,PLAYER_ENTITY);if(cell.entityType){const entities=getEntitiesFromCell(cell);entities.forEach((e)=>hurtEntity(e,1));break;}}gunShotAudio.play();move();};const useMap=(toggle)=>{if(IS_FISHING_ACTIVE||!canDoActions())return;toggleFullMap(toggle);};const useFishingRod=()=>{if(!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.block?.isFluid){makeEntityUse(PLAYER_ENTITY);startFishing();}};const resetMap=()=>{resetPlace();setEntitiesSize();resetCanvas();moveCurrentCell(getCenterCell(),PLAYER_ENTITY.cell);drawEveryCell(PLAYER_ENTITY);updateWeather();};const MOVEMENT_CONFIG={velocity:10,};const getCleanPos=(pos)=>({i:pos?.i||0,j:pos?.j||0});const moveCurrentCell=(oldCell,nextCell)=>{const oldPos=getCleanPos(oldCell?.pos);const nextPos=getCleanPos(nextCell?.pos);RENDER_INFO.iOffset+=nextPos.i-oldPos.i;RENDER_INFO.jOffset+=nextPos.j-oldPos.j;moveEntityToCell(PLAYER_ENTITY,nextCell);};let canMove=true;const move=(nextCell)=>{if(canMove&&PLAYER_ENTITY.health>0){canMove=false;if(nextCell)moveCurrentCell(PLAYER_ENTITY.cell,nextCell);if(MENU_CONFIG.passTime)passTime();setTimeout(()=>{drawEveryCell(PLAYER_ENTITY);killEntitiesByTimeOfDay();moveEntities(PLAYER_ENTITY.cell);spawnEntities(PLAYER_ENTITY.cell);canMove=true;},1000/MOVEMENT_CONFIG.velocity);}};const findAccessibleCell=(cell,entity)=>{let accessibleCell=cell;while(cellIsBlocked(accessibleCell,entity)){accessibleCell=loadAndGetCell({i:accessibleCell.pos.i+1,j:accessibleCell.pos.j,});}return accessibleCell;};const digAudio=new Audio("sounds/actions/dig.mp3");digAudio.volume=0.25;const punchAudio=new Audio("sounds/actions/punch.mp3");punchAudio.volume=0.25;const gunShotAudio=new Audio("sounds/actions/gun-shot.mp3");gunShotAudio.volume=1;const rotateAudio=new Audio("sounds/actions/rotate.mp3");rotateAudio.volume=0.25;let canRotate=true;const canDoActions=()=>PLAYER_ENTITY.health>0;const rotate=(orientation)=>{if(canRotate){canRotate=false;RENDER_INFO.rotationTurns=PLAYER_ENTITY.selectedCellIndex=getMod(RENDER_INFO.rotationTurns+orientation,RENDER_INFO.currentPoly);if(MENU_CONFIG.rotationAnimation){rotateCanvas((360/RENDER_INFO.currentPoly)*-orientation,COMPASS_CONFIG.rotateDelay);rotateAudio.play();}updateCompass();resetDirection();setTimeout(()=>{if(MENU_CONFIG.rotationAnimation)resetRotateCanvas();drawEveryCell(PLAYER_ENTITY);canRotate=true;},COMPASS_CONFIG.rotateDelay);}};const getNextCellIndexBasedOnCode=(code,useDiagonal)=>{const aIndex=getMovementMap(PLAYER_ENTITY.cell,useDiagonal)[code];if(aIndex===undefined)return;return getMod(aIndex,RENDER_INFO.currentPoly);};let isMoving=false;const moveBaseOnCode=(direction,useDiagonal)=>{if(!direction||!canDoActions())return;if(IS_FISHING_ACTIVE){moveFishing(direction,useDiagonal);return;}isMoving=true;makeEntityRun(PLAYER_ENTITY,direction);const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined)return;const nextPos=getPosByIndex(PLAYER_ENTITY.cell,aModI);if(!nextPos)return;const nextCell=getCell(nextPos);if(cellIsBlocked(nextCell,PLAYER_ENTITY))return;move(nextCell);updateWeather(direction);};const MOVEMENT_VALUES=Object.values(MOVEMENT);const stopMoving=()=>{if(!isMoving)return;let lastSelection=PLAYER_ENTITY.currentDirection;const movementMap=getMovementMap(PLAYER_ENTITY.cell);for(const movement of MOVEMENT_VALUES){if(movementMap[movement]===PLAYER_ENTITY.selectedCellIndex){lastSelection=movement;break;}}isMoving=false;updateEntityDirection(PLAYER_ENTITY,lastSelection);};const changeSelectedOnCode=(direction,useDiagonal)=>{if(!direction)return;const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined||aModI===PLAYER_ENTITY.selectedCellIndex)return;PLAYER_ENTITY.selectedCellIndex=aModI;if(MENU_CONFIG.showSelectedCell)drawEveryCell(PLAYER_ENTITY);updateEntityDirection(PLAYER_ENTITY,direction);};const getNextPolygon=()=>KNOWN_POLYGONS_VALUES[(KNOWN_POLYGONS_VALUES.indexOf(RENDER_INFO.currentPoly)+1)%KNOWN_POLYGONS_VALUES.length];const changePolySides=()=>{RENDER_INFO.currentPoly=getNextPolygon();RENDER_INFO.rotationTurns=0;PLAYER_ENTITY.selectedCellIndex=0;updateCompass();resetDirection();resetMap();};const resetDirection=()=>updateEntityDirection(PLAYER_ENTITY,MOVEMENT.UP);const updateAndGetSelectedCell=()=>{updateEntityDirection(PLAYER_ENTITY,PLAYER_ENTITY.currentDirection);return getSelectedCell(PLAYER_ENTITY);};const dig=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(!selectedCell?.block)return;if(selectedCell.entityType){makeEntityUse(PLAYER_ENTITY);const entities=getEntitiesFromCell(selectedCell);entities.forEach((e)=>hurtEntity(e,1));punchAudio.play();move();return;}if(selectedCell.block.isFluid)return;if(selectedCell.wall){if(selectedCell.wall.block.indestructible)return;}else if(selectedCell.block.indestructible)return;makeEntityUse(PLAYER_ENTITY);digAudio.play();if(selectedCell.wall){destroyWall(selectedCell);}else{selectedCell.block=null;selectedCell.color=null;}move();};const place=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.wall||selectedCell.entityType)return;makeEntityUse(PLAYER_ENTITY);placeBlock(selectedCell);move();};const placeBlock=(cell,block,color)=>{if(!cell||!!cell.entityType)return;if(!block){const cellBlock=getSelectedBlockToPlace();if(!cellBlock)return;block=cellBlock.block;color=cellBlock.color;}digAudio.play();if(cell.block&&!cell.block.isFluid){cell.wall={block:block,color:color};}else{cell.block=block;cell.color=color;}};const useBoat=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();const canMove=!selectedCell.wall&&selectedCell.block;if(PLAYER_ENTITY.connectedEntities[ENTITY_TYPES.BOAT]){if(!selectedCell?.block?.isFluid&&canMove){getOutBoat(PLAYER_ENTITY);move(selectedCell);}return;}if(selectedCell.entityType===ENTITY_TYPES.BOAT){getInBoat(PLAYER_ENTITY);move(selectedCell);}else if(canMove){makeEntityUse(PLAYER_ENTITY);addBoat(selectedCell,PLAYER_ENTITY);}};const useGun=()=>{const range=getPolyInfo().hasInverted?1:10;updateAndGetSelectedCell();gunShotAudio.currentTime=0;let{cell,selectedCellIndex}=PLAYER_ENTITY;for(let i=0;i<range;i++){const nextCell=getCell(getPosByIndex(cell,selectedCellIndex));if(nextCell.wall)break;cell=nextCell;drawCircleOnCell(cell,PLAYER_ENTITY);if(cell.entityType){const entities=getEntitiesFromCell(cell);entities.forEach((e)=>hurtEntity(e,1));break;}}gunShotAudio.play();move();};const useMap=(toggle)=>{if(IS_FISHING_ACTIVE||!canDoActions())return;toggleFullMap(toggle);};const useFishingRod=()=>{if(!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.block?.isFluid){makeEntityUse(PLAYER_ENTITY);startFishing();}};const resetMap=()=>{resetPlace();setEntitiesSize();resetCanvas();moveCurrentCell(getCenterCell(),PLAYER_ENTITY.cell);drawEveryCell(PLAYER_ENTITY);updateWeather();};const start=()=>{addEntity(PLAYER_ENTITY);configPolys();resetGrid();resetBiomes();removeGeneratedEntities();updateCanvasCss();resetDirection();PLAYER_ENTITY.cell=findAccessibleCell(loadAndGetCell(INITIAL_POS),PLAYER_ENTITY);resetToolbar();resetMap();};const resetSize=debounce((newSize)=>{RENDER_INFO.cellHeight=newSize||RENDER_INFO.cellHeight;configPolys();resetToolbar();resetMap();});const CONTROLS_CONFIG={minZoom:12,maxZoom:120,};const MOVEMENT_CONFIG={velocity:10,};const getCleanPos=(pos)=>({i:pos?.i||0,j:pos?.j||0});const moveCurrentCell=(oldCell,nextCell)=>{const oldPos=getCleanPos(oldCell?.pos);const nextPos=getCleanPos(nextCell?.pos);RENDER_INFO.iOffset+=nextPos.i-oldPos.i;RENDER_INFO.jOffset+=nextPos.j-oldPos.j;moveEntityToCell(PLAYER_ENTITY,nextCell);};let canMove=true;const move=(nextCell)=>{if(canMove&&PLAYER_ENTITY.health>0){canMove=false;if(nextCell)moveCurrentCell(PLAYER_ENTITY.cell,nextCell);if(MENU_CONFIG.passTime)passTime();setTimeout(()=>{drawEveryCell(PLAYER_ENTITY);killEntitiesByTimeOfDay();moveEntities(PLAYER_ENTITY.cell);spawnEntities(PLAYER_ENTITY.cell);canMove=true;},1000/MOVEMENT_CONFIG.velocity);}};const findAccessibleCell=(cell,entity)=>{let accessibleCell=cell;while(cellIsBlocked(accessibleCell,entity)){accessibleCell=loadAndGetCell({i:accessibleCell.pos.i+1,j:accessibleCell.pos.j,});}return accessibleCell;};const start=()=>{addEntity(PLAYER_ENTITY);configPolys();resetGrid();resetBiomes();removeGeneratedEntities();updateCanvasCss();resetDirection();PLAYER_ENTITY.cell=findAccessibleCell(loadAndGetCell(INITIAL_POS),PLAYER_ENTITY);resetToolbar();resetMap();};const resetSize=debounce((newSize)=>{RENDER_INFO.cellHeight=newSize||RENDER_INFO.cellHeight;configPolys();resetToolbar();resetMap();});const addDebugBlockToPoint=({x,y})=>{if(!MENU_CONFIG.debugMode||RENDER_INFO.rotationTurns)return;if(MENU_CONFIG.usePerspective){x-=175;y+=60;}const cell=getCell(calculatePosBasedOnPoint({x,y}));const block=BLOCKS.ROCK;if(cell.wall)cell.wall=null;else placeBlock(cell,block,block.color);drawEveryCell(PLAYER_ENTITY);};const getJFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(x)=>(x-xSide)/(polySide/2);case KNOWN_POLYGONS.HEXAGON:return(x)=>(x-xSide)/(xSide+polySide/2);case KNOWN_POLYGONS.SQUARE:default:return(x)=>(x-xSide)/(xSide*2);}};const calcI=(y,ySide,shouldIntercalate,evenJ)=>{let dividend=y-ySide;if(shouldIntercalate){if(PLAYER_ENTITY.cell.pos.j%2&&!evenJ){dividend+=ySide;}else if(!(PLAYER_ENTITY.cell.pos.j%2)&&evenJ){dividend-=ySide;}}return dividend/(ySide*2);};const calculatePosBasedOnPoint=({x,y})=>{const{xSide,ySide,shouldIntercalate,polySide}=getPolyInfo();let j=getJFn(RENDER_INFO.currentPoly,polySide,xSide)(x);j=Math.round(j+(RENDER_INFO.jOffset||0));let i=calcI(y,ySide,shouldIntercalate,!!(j%2));i+=RENDER_INFO.iOffset||0;return{i:Math.round(i),j:j};};const CONTROLS_CONFIG={minZoom:12,maxZoom:120,};const digAudio=new Audio("sounds/actions/dig.mp3");digAudio.volume=0.25;const punchAudio=new Audio("sounds/actions/punch.mp3");punchAudio.volume=0.25;const gunShotAudio=new Audio("sounds/actions/gun-shot.mp3");gunShotAudio.volume=1;const rotateAudio=new Audio("sounds/actions/rotate.mp3");rotateAudio.volume=0.25;let canRotate=true;const canDoActions=()=>PLAYER_ENTITY.health>0;const rotate=(orientation)=>{if(canRotate){canRotate=false;RENDER_INFO.rotationTurns=PLAYER_ENTITY.selectedCellIndex=getMod(RENDER_INFO.rotationTurns+orientation,RENDER_INFO.currentPoly);if(MENU_CONFIG.rotationAnimation){rotateCanvas((360/RENDER_INFO.currentPoly)*-orientation,COMPASS_CONFIG.rotateDelay);rotateAudio.play();}updateCompass();resetDirection();setTimeout(()=>{if(MENU_CONFIG.rotationAnimation)resetRotateCanvas();drawEveryCell(PLAYER_ENTITY);canRotate=true;},COMPASS_CONFIG.rotateDelay);}};const getNextCellIndexBasedOnCode=(code,useDiagonal)=>{const aIndex=getMovementMap(PLAYER_ENTITY.cell,useDiagonal)[code];if(aIndex===undefined)return;return getMod(aIndex,RENDER_INFO.currentPoly);};let isMoving=false;const moveBaseOnCode=(direction,useDiagonal)=>{if(!direction||!canDoActions())return;if(IS_FISHING_ACTIVE){moveFishing(direction,useDiagonal);return;}isMoving=true;makeEntityRun(PLAYER_ENTITY,direction);const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined)return;const nextPos=getPosByIndex(PLAYER_ENTITY.cell,aModI);if(!nextPos)return;const nextCell=getCell(nextPos);if(cellIsBlocked(nextCell,PLAYER_ENTITY))return;move(nextCell);updateWeather(direction);};const MOVEMENT_VALUES=Object.values(MOVEMENT);const stopMoving=()=>{if(!isMoving)return;let lastSelection=PLAYER_ENTITY.currentDirection;const movementMap=getMovementMap(PLAYER_ENTITY.cell);for(const movement of MOVEMENT_VALUES){if(movementMap[movement]===PLAYER_ENTITY.selectedCellIndex){lastSelection=movement;break;}}isMoving=false;updateEntityDirection(PLAYER_ENTITY,lastSelection);};const changeSelectedOnCode=(direction,useDiagonal)=>{if(!direction)return;const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined||aModI===PLAYER_ENTITY.selectedCellIndex)return;PLAYER_ENTITY.selectedCellIndex=aModI;if(MENU_CONFIG.showSelectedCell)drawEveryCell(PLAYER_ENTITY);updateEntityDirection(PLAYER_ENTITY,direction);};const getNextPolygon=()=>KNOWN_POLYGONS_VALUES[(KNOWN_POLYGONS_VALUES.indexOf(RENDER_INFO.currentPoly)+1)%KNOWN_POLYGONS_VALUES.length];const changePolySides=()=>{RENDER_INFO.currentPoly=getNextPolygon();RENDER_INFO.rotationTurns=0;PLAYER_ENTITY.selectedCellIndex=0;updateCompass();resetDirection();resetMap();};const resetDirection=()=>updateEntityDirection(PLAYER_ENTITY,MOVEMENT.UP);const updateAndGetSelectedCell=()=>{updateEntityDirection(PLAYER_ENTITY,PLAYER_ENTITY.currentDirection);return getSelectedCell(PLAYER_ENTITY);};const dig=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(!selectedCell?.block)return;if(selectedCell.entityType){makeEntityUse(PLAYER_ENTITY);const entities=getEntitiesFromCell(selectedCell);entities.forEach((e)=>hurtEntity(e,1));punchAudio.play();move();return;}if(selectedCell.block.isFluid)return;if(selectedCell.wall){if(selectedCell.wall.block.indestructible)return;}else if(selectedCell.block.indestructible)return;makeEntityUse(PLAYER_ENTITY);digAudio.play();if(selectedCell.wall){destroyWall(selectedCell);}else{selectedCell.block=null;selectedCell.color=null;}move();};const place=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.wall||selectedCell.entityType)return;makeEntityUse(PLAYER_ENTITY);placeBlock(selectedCell);move();};const placeBlock=(cell,block,color)=>{if(!cell||!!cell.entityType)return;if(!block){const cellBlock=getSelectedBlockToPlace();if(!cellBlock)return;block=cellBlock.block;color=cellBlock.color;}digAudio.play();if(cell.block&&!cell.block.isFluid){cell.wall={block:block,color:color};}else{cell.block=block;cell.color=color;}};const useBoat=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();const canMove=!selectedCell.wall&&selectedCell.block;if(PLAYER_ENTITY.connectedEntities[ENTITY_TYPES.BOAT]){if(!selectedCell?.block?.isFluid&&canMove){getOutBoat(PLAYER_ENTITY);move(selectedCell);}return;}if(selectedCell.entityType===ENTITY_TYPES.BOAT){getInBoat(PLAYER_ENTITY);move(selectedCell);}else if(canMove){makeEntityUse(PLAYER_ENTITY);addBoat(selectedCell,PLAYER_ENTITY);}};const useGun=()=>{const range=getPolyInfo().hasInverted?1:10;updateAndGetSelectedCell();gunShotAudio.currentTime=0;let{cell,selectedCellIndex}=PLAYER_ENTITY;for(let i=0;i<range;i++){const nextCell=getCell(getPosByIndex(cell,selectedCellIndex));if(nextCell.wall)break;cell=nextCell;drawCircleOnCell(cell,PLAYER_ENTITY);if(cell.entityType){const entities=getEntitiesFromCell(cell);entities.forEach((e)=>hurtEntity(e,1));break;}}gunShotAudio.play();move();};const useMap=(toggle)=>{if(IS_FISHING_ACTIVE||!canDoActions())return;toggleFullMap(toggle);};const useFishingRod=()=>{if(!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.block?.isFluid){makeEntityUse(PLAYER_ENTITY);startFishing();}};const resetMap=()=>{resetPlace();setEntitiesSize();resetCanvas();moveCurrentCell(getCenterCell(),PLAYER_ENTITY.cell);drawEveryCell(PLAYER_ENTITY);updateWeather();};(()=>{const SELECT_OPTIONS={mapGeneration:Object.entries(MAP_GENERATION),};document.querySelectorAll("#menu label").forEach((l)=>{const config=(l).htmlFor;const element=(document.getElementById(config));if(!element)return;if(element.type==="checkbox"){const check=(element);check.checked=MENU_CONFIG[config];check.onchange=()=>{MENU_CONFIG[config]=check.checked;updateCanvasCss();drawEveryCell(PLAYER_ENTITY);check.blur();};}else if(element.tagName==="SELECT"){const select=(element);SELECT_OPTIONS[config].forEach(([key,value])=>{const option=document.createElement("option");option.value=value;option.innerHTML=key;select.appendChild(option);});select.value=MENU_CONFIG[config];select.onchange=()=>{MENU_CONFIG[config]=select.value;start();select.blur();};}});const teleportationIElement=(document.getElementById("teleportation-i"));const teleportationJElement=(document.getElementById("teleportation-j"));const teleportationBtn=(document.getElementById("teleport"));teleportationBtn.onclick=()=>{const i=+teleportationIElement.value;const j=+teleportationJElement.value;move(loadAndGetCell({i,j}));teleportationBtn.blur();};const zoomSlider=(document.getElementById("zoom"));zoomSlider.value=`${RENDER_INFO.cellHeight}`;zoomSlider.min=`${CONTROLS_CONFIG.minZoom}`;zoomSlider.max=`${CONTROLS_CONFIG.maxZoom}`;zoomSlider.oninput=()=>{resetSize(+zoomSlider.value);zoomSlider.blur();};const musicVolumeSlider=(document.getElementById("musicVolume"));musicVolumeSlider.value=`50`;musicVolumeSlider.min=`0`;musicVolumeSlider.max=`100`;musicVolumeSlider.oninput=()=>{setMusicVolume(+musicVolumeSlider.value);musicVolumeSlider.blur();};setMusicVolume(+musicVolumeSlider.value);})();const addDebugBlockToPoint=({x,y})=>{if(!MENU_CONFIG.debugMode||RENDER_INFO.rotationTurns)return;if(MENU_CONFIG.usePerspective){x-=175;y+=60;}const cell=getCell(calculatePosBasedOnPoint({x,y}));const block=BLOCKS.ROCK;if(cell.wall)cell.wall=null;else placeBlock(cell,block,block.color);drawEveryCell(PLAYER_ENTITY);};const getJFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(x)=>(x-xSide)/(polySide/2);case KNOWN_POLYGONS.HEXAGON:return(x)=>(x-xSide)/(xSide+polySide/2);case KNOWN_POLYGONS.SQUARE:default:return(x)=>(x-xSide)/(xSide*2);}};const calcI=(y,ySide,shouldIntercalate,evenJ)=>{let dividend=y-ySide;if(shouldIntercalate){if(PLAYER_ENTITY.cell.pos.j%2&&!evenJ){dividend+=ySide;}else if(!(PLAYER_ENTITY.cell.pos.j%2)&&evenJ){dividend-=ySide;}}return dividend/(ySide*2);};const calculatePosBasedOnPoint=({x,y})=>{const{xSide,ySide,shouldIntercalate,polySide}=getPolyInfo();let j=getJFn(RENDER_INFO.currentPoly,polySide,xSide)(x);j=Math.round(j+(RENDER_INFO.jOffset||0));let i=calcI(y,ySide,shouldIntercalate,!!(j%2));i+=RENDER_INFO.iOffset||0;return{i:Math.round(i),j:j};};const MOVEMENT_CONFIG={velocity:10,};const getCleanPos=(pos)=>({i:pos?.i||0,j:pos?.j||0});const moveCurrentCell=(oldCell,nextCell)=>{const oldPos=getCleanPos(oldCell?.pos);const nextPos=getCleanPos(nextCell?.pos);RENDER_INFO.iOffset+=nextPos.i-oldPos.i;RENDER_INFO.jOffset+=nextPos.j-oldPos.j;moveEntityToCell(PLAYER_ENTITY,nextCell);};let canMove=true;const move=(nextCell)=>{if(canMove&&PLAYER_ENTITY.health>0){canMove=false;if(nextCell)moveCurrentCell(PLAYER_ENTITY.cell,nextCell);if(MENU_CONFIG.passTime)passTime();setTimeout(()=>{drawEveryCell(PLAYER_ENTITY);killEntitiesByTimeOfDay();moveEntities(PLAYER_ENTITY.cell);spawnEntities(PLAYER_ENTITY.cell);canMove=true;},1000/MOVEMENT_CONFIG.velocity);}};const findAccessibleCell=(cell,entity)=>{let accessibleCell=cell;while(cellIsBlocked(accessibleCell,entity)){accessibleCell=loadAndGetCell({i:accessibleCell.pos.i+1,j:accessibleCell.pos.j,});}return accessibleCell;};(()=>{let mobileZoom=0;canvasContainer.ontouchstart=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];mobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);return;}};canvasContainer.ontouchmove=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];const nMobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);if(nMobileZoom>mobileZoom&&RENDER_INFO.cellHeight<CONTROLS_CONFIG.maxZoom){resetSize(RENDER_INFO.cellHeight+1);}else if(nMobileZoom<mobileZoom&&RENDER_INFO.cellHeight>CONTROLS_CONFIG.minZoom){resetSize(RENDER_INFO.cellHeight-1);}mobileZoom=nMobileZoom;}};canvasContainer.ontouchend=()=>{mobileZoom=0;};document.getElementById("change-poly").onclick=()=>{changePolySides();updatePolyImages();};document.getElementById("rotate-left").onclick=()=>rotate(-1);document.getElementById("rotate-right").onclick=()=>rotate(1);const currentPoly=(document.getElementById("current-poly"));const nextPoly=(document.getElementById("next-poly"));const updatePolyImages=()=>{setImagePos(currentPoly,POLYGONS_ENTITY_POS[RENDER_INFO.currentPoly]);setImagePos(nextPoly,POLYGONS_ENTITY_POS[getNextPolygon()]);};updatePolyImages();})();(()=>{const SELECT_OPTIONS={mapGeneration:Object.entries(MAP_GENERATION),};document.querySelectorAll("#menu label").forEach((l)=>{const config=(l).htmlFor;const element=(document.getElementById(config));if(!element)return;if(element.type==="checkbox"){const check=(element);check.checked=MENU_CONFIG[config];check.onchange=()=>{MENU_CONFIG[config]=check.checked;updateCanvasCss();drawEveryCell(PLAYER_ENTITY);check.blur();};}else if(element.tagName==="SELECT"){const select=(element);SELECT_OPTIONS[config].forEach(([key,value])=>{const option=document.createElement("option");option.value=value;option.innerHTML=key;select.appendChild(option);});select.value=MENU_CONFIG[config];select.onchange=()=>{MENU_CONFIG[config]=select.value;start();select.blur();};}});const teleportationIElement=(document.getElementById("teleportation-i"));const teleportationJElement=(document.getElementById("teleportation-j"));const teleportationBtn=(document.getElementById("teleport"));teleportationBtn.onclick=()=>{const i=+teleportationIElement.value;const j=+teleportationJElement.value;move(loadAndGetCell({i,j}));teleportationBtn.blur();};const zoomSlider=(document.getElementById("zoom"));zoomSlider.value=`${RENDER_INFO.cellHeight}`;zoomSlider.min=`${CONTROLS_CONFIG.minZoom}`;zoomSlider.max=`${CONTROLS_CONFIG.maxZoom}`;zoomSlider.oninput=()=>{resetSize(+zoomSlider.value);zoomSlider.blur();};const musicVolumeSlider=(document.getElementById("musicVolume"));musicVolumeSlider.value=`50`;musicVolumeSlider.min=`0`;musicVolumeSlider.max=`100`;musicVolumeSlider.oninput=()=>{setMusicVolume(+musicVolumeSlider.value);musicVolumeSlider.blur();};setMusicVolume(+musicVolumeSlider.value);})();const start=()=>{addEntity(PLAYER_ENTITY);configPolys();resetGrid();resetBiomes();removeGeneratedEntities();updateCanvasCss();resetDirection();PLAYER_ENTITY.cell=findAccessibleCell(loadAndGetCell(INITIAL_POS),PLAYER_ENTITY);resetToolbar();resetMap();};const resetSize=debounce((newSize)=>{RENDER_INFO.cellHeight=newSize||RENDER_INFO.cellHeight;configPolys();resetToolbar();resetMap();});const ENTITIES=(new Set());const addEntity=(entity)=>ENTITIES.add(entity);const moveEntityToCell=(entity,cell)=>{if(!cell)return;const previousType=entity.cell?.entityType||cell.entityType;if(entity.cell)entity.cell.entityType=null;entity.cell=cell;entity.cell.entityType=previousType||entity.type;updateEntityPoint(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach((e)=>moveEntityToCell(e,cell));};const removeEntity=(entity)=>{entity.cell.entityType=null;removeEntityImage(entity);ENTITIES.delete(entity);if(entity.connectedEntities)Object.values(entity.connectedEntities).forEach(removeEntity);};const getEntitiesFromCell=(cell)=>{const entities=([]);ENTITIES.forEach((entity)=>{if(entity.cell===cell)entities.push(entity);});return entities;};const createEntity=(cell,id,type,entityParams={})=>{if(entityParams.minTime&&ENTITY_INFO.timeOfDay<entityParams.minTime)return;const entity=({id:`${type}_${id}`,type,connectedEntities:{},currentImgType:cell.block?.biomeType,health:1,...entityParams,});createEntityImage(entity);moveEntityToCell(entity,cell);addEntity(entity);return entity;};const setEntitiesSize=()=>ENTITIES.forEach((e)=>setEntitySize(e));const removeGeneratedEntities=()=>ENTITIES.forEach((e)=>e.isGenerated&&removeEntity(e));const updateEntities=()=>ENTITIES.forEach((e)=>updateEntityPoint(e));const cellIsBlocked=(cell,entity)=>!MENU_CONFIG.debugMode&&(!cell||!cell.block||!!cell.wall||!!cell.entityType||(entity.connectedEntities[ENTITY_TYPES.BOAT]?!cell.block.isFluid:cell.block.isFluid));const getSelectedCell=(entity)=>getCell(getPosByIndex(entity.cell,entity.selectedCellIndex));const updateEntityDirection=(entity,direction)=>{updateEntityImage(entity,direction);Object.values(entity.connectedEntities).forEach((e)=>{updateEntityImage(e,MOVEMENT.RIGHT);});};const makeEntityUse=(entity)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.USING);setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},250);};const updateEntityHealth=(entity)=>{if(entity===PLAYER_ENTITY){if(entity.health>PLAYER_CONFIG.maxHealth)entity.health=PLAYER_CONFIG.maxHealth;updatePlayerHearts();}else if(entity.health<=0)removeEntity(entity);};const giveItemToEntity=(entity,item)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.WINNING);const callback=displayWinAnimation(entity,item.imgPos);if(item.health){entity.health+=item.health;updateEntityHealth(entity);}setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);callback();},1000);};const hurtEntity=(entity,damage)=>{updateEntityImage(entity,entity.currentDirection,IMG_MAP_TYPES.LOSING);entity.health-=damage;updateEntityHealth(entity);if(entity.health>0)setTimeout(()=>{updateEntityImage(entity,entity.currentDirection);},1000);};const makeEntityRun=(entity,direction)=>{const connectedEntities=Object.values(entity.connectedEntities);if(!connectedEntities.length){updateEntityImage(entity,direction,IMG_MAP_TYPES.RUNNING);return;}updateEntityImage(entity,direction);connectedEntities.forEach((e)=>{updateEntityImage(e,direction);cutEntityImage(e,direction);});};const CONTROLS_CONFIG={minZoom:12,maxZoom:120,};(()=>{const SELECTION_STICK_CONFIG={touchThreshold:20,};const selectionStickLeft=document.getElementById("selection-stick-left");const selectionStickRight=document.getElementById("selection-stick-right");const SELECTION_STICK_INFO=(()=>{const maxPoint=selectionStickLeft.offsetWidth/1.25;const minPoint=selectionStickLeft.offsetWidth/5;const midPoint=minPoint+(maxPoint-minPoint)/2;const maxMidPoint=midPoint+SELECTION_STICK_CONFIG.touchThreshold;const minMidPoint=midPoint-SELECTION_STICK_CONFIG.touchThreshold;return{maxPoint,minPoint,midPoint,maxMidPoint,minMidPoint};})();const moveStick=(e,stickElement)=>{e=e||(window.event);e.preventDefault();e.stopPropagation();const{clientX,clientY}=e.touches[0];const stickRect=stickElement.getBoundingClientRect();let finalX=clientX-stickRect.left;let finalY=clientY-stickRect.top;finalX=Math.min(finalX,SELECTION_STICK_INFO.maxPoint);finalX=Math.max(finalX,SELECTION_STICK_INFO.minPoint);finalY=Math.min(finalY,SELECTION_STICK_INFO.maxPoint);finalY=Math.max(finalY,SELECTION_STICK_INFO.minPoint);stickElement.style.setProperty("--selection-stick-left",`${finalX}px`);stickElement.style.setProperty("--selection-stick-top",`${finalY}px`);let code=null;const useDiagonal=finalY>SELECTION_STICK_INFO.maxMidPoint;if(useDiagonal)code=MOVEMENT.DOWN;if(finalY<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.UP;if(finalX>SELECTION_STICK_INFO.maxMidPoint)code=MOVEMENT.RIGHT;if(finalX<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.LEFT;return{code,useDiagonal};};selectionStickLeft.ontouchstart=selectionStickLeft.ontouchmove=(e)=>{const{code,useDiagonal}=moveStick(e,selectionStickLeft);if(code)changeSelectedOnCode(code,useDiagonal);};let rightStickInfo=({});const updateRightStickInfo=(e)=>(rightStickInfo=moveStick(e,selectionStickRight));selectionStickRight.ontouchstart=(e)=>{clearInterval(rightStickInfo.interval);updateRightStickInfo(e);rightStickInfo.interval=setInterval(()=>{if(rightStickInfo.code)moveBaseOnCode(rightStickInfo.code,rightStickInfo.useDiagonal);else stopMoving();},100);};selectionStickRight.ontouchmove=updateRightStickInfo;document.ontouchend=()=>{selectionStickLeft?.style.removeProperty("--selection-stick-left");selectionStickLeft?.style.removeProperty("--selection-stick-top");selectionStickRight?.style.removeProperty("--selection-stick-left");selectionStickRight?.style.removeProperty("--selection-stick-top");stopMoving();clearInterval(rightStickInfo.interval);rightStickInfo={code:null,useDiagonal:null,interval:null};};})();(()=>{let mobileZoom=0;canvasContainer.ontouchstart=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];mobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);return;}};canvasContainer.ontouchmove=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];const nMobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);if(nMobileZoom>mobileZoom&&RENDER_INFO.cellHeight<CONTROLS_CONFIG.maxZoom){resetSize(RENDER_INFO.cellHeight+1);}else if(nMobileZoom<mobileZoom&&RENDER_INFO.cellHeight>CONTROLS_CONFIG.minZoom){resetSize(RENDER_INFO.cellHeight-1);}mobileZoom=nMobileZoom;}};canvasContainer.ontouchend=()=>{mobileZoom=0;};document.getElementById("change-poly").onclick=()=>{changePolySides();updatePolyImages();};document.getElementById("rotate-left").onclick=()=>rotate(-1);document.getElementById("rotate-right").onclick=()=>rotate(1);const currentPoly=(document.getElementById("current-poly"));const nextPoly=(document.getElementById("next-poly"));const updatePolyImages=()=>{setImagePos(currentPoly,POLYGONS_ENTITY_POS[RENDER_INFO.currentPoly]);setImagePos(nextPoly,POLYGONS_ENTITY_POS[getNextPolygon()]);};updatePolyImages();})();const addDebugBlockToPoint=({x,y})=>{if(!MENU_CONFIG.debugMode||RENDER_INFO.rotationTurns)return;if(MENU_CONFIG.usePerspective){x-=175;y+=60;}const cell=getCell(calculatePosBasedOnPoint({x,y}));const block=BLOCKS.ROCK;if(cell.wall)cell.wall=null;else placeBlock(cell,block,block.color);drawEveryCell(PLAYER_ENTITY);};const getJFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(x)=>(x-xSide)/(polySide/2);case KNOWN_POLYGONS.HEXAGON:return(x)=>(x-xSide)/(xSide+polySide/2);case KNOWN_POLYGONS.SQUARE:default:return(x)=>(x-xSide)/(xSide*2);}};const calcI=(y,ySide,shouldIntercalate,evenJ)=>{let dividend=y-ySide;if(shouldIntercalate){if(PLAYER_ENTITY.cell.pos.j%2&&!evenJ){dividend+=ySide;}else if(!(PLAYER_ENTITY.cell.pos.j%2)&&evenJ){dividend-=ySide;}}return dividend/(ySide*2);};const calculatePosBasedOnPoint=({x,y})=>{const{xSide,ySide,shouldIntercalate,polySide}=getPolyInfo();let j=getJFn(RENDER_INFO.currentPoly,polySide,xSide)(x);j=Math.round(j+(RENDER_INFO.jOffset||0));let i=calcI(y,ySide,shouldIntercalate,!!(j%2));i+=RENDER_INFO.iOffset||0;return{i:Math.round(i),j:j};};(()=>{const SELECTION_STICK_CONFIG={touchThreshold:20,};const selectionStickLeft=document.getElementById("selection-stick-left");const selectionStickRight=document.getElementById("selection-stick-right");const SELECTION_STICK_INFO=(()=>{const maxPoint=selectionStickLeft.offsetWidth/1.25;const minPoint=selectionStickLeft.offsetWidth/5;const midPoint=minPoint+(maxPoint-minPoint)/2;const maxMidPoint=midPoint+SELECTION_STICK_CONFIG.touchThreshold;const minMidPoint=midPoint-SELECTION_STICK_CONFIG.touchThreshold;return{maxPoint,minPoint,midPoint,maxMidPoint,minMidPoint};})();const moveStick=(e,stickElement)=>{e=e||(window.event);e.preventDefault();e.stopPropagation();const{clientX,clientY}=e.touches[0];const stickRect=stickElement.getBoundingClientRect();let finalX=clientX-stickRect.left;let finalY=clientY-stickRect.top;finalX=Math.min(finalX,SELECTION_STICK_INFO.maxPoint);finalX=Math.max(finalX,SELECTION_STICK_INFO.minPoint);finalY=Math.min(finalY,SELECTION_STICK_INFO.maxPoint);finalY=Math.max(finalY,SELECTION_STICK_INFO.minPoint);stickElement.style.setProperty("--selection-stick-left",`${finalX}px`);stickElement.style.setProperty("--selection-stick-top",`${finalY}px`);let code=null;const useDiagonal=finalY>SELECTION_STICK_INFO.maxMidPoint;if(useDiagonal)code=MOVEMENT.DOWN;if(finalY<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.UP;if(finalX>SELECTION_STICK_INFO.maxMidPoint)code=MOVEMENT.RIGHT;if(finalX<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.LEFT;return{code,useDiagonal};};selectionStickLeft.ontouchstart=selectionStickLeft.ontouchmove=(e)=>{const{code,useDiagonal}=moveStick(e,selectionStickLeft);if(code)changeSelectedOnCode(code,useDiagonal);};let rightStickInfo=({});const updateRightStickInfo=(e)=>(rightStickInfo=moveStick(e,selectionStickRight));selectionStickRight.ontouchstart=(e)=>{clearInterval(rightStickInfo.interval);updateRightStickInfo(e);rightStickInfo.interval=setInterval(()=>{if(rightStickInfo.code)moveBaseOnCode(rightStickInfo.code,rightStickInfo.useDiagonal);else stopMoving();},100);};selectionStickRight.ontouchmove=updateRightStickInfo;document.ontouchend=()=>{selectionStickLeft?.style.removeProperty("--selection-stick-left");selectionStickLeft?.style.removeProperty("--selection-stick-top");selectionStickRight?.style.removeProperty("--selection-stick-left");selectionStickRight?.style.removeProperty("--selection-stick-top");stopMoving();clearInterval(rightStickInfo.interval);rightStickInfo={code:null,useDiagonal:null,interval:null};};})();(()=>{const KEY_MOVEMENT_MAP={["KeyW"]:MOVEMENT.UP,["KeyA"]:MOVEMENT.LEFT,["KeyS"]:MOVEMENT.DOWN,["KeyD"]:MOVEMENT.RIGHT,};const ARROW_MOVEMENT_MAP={["ArrowUp"]:MOVEMENT.UP,["ArrowLeft"]:MOVEMENT.LEFT,["ArrowDown"]:MOVEMENT.DOWN,["ArrowRight"]:MOVEMENT.RIGHT,};let selectedToolbarIndex=1;const TOOLBAR_ACTIONS=[undefined,document.getElementById("toolbar-dig"),document.getElementById("toolbar-place"),document.getElementById("toolbar-fishing"),document.getElementById("toolbar-boat"),document.getElementById("toolbar-gun"),document.getElementById("toolbar-map"),];const MOVEMENT_KEYS=Object.keys(KEY_MOVEMENT_MAP);const menuToggle=(document.getElementById("menuToggle"));const closeDebugMenu=()=>(menuToggle.checked=false);document.onkeydown=(e)=>{e=e||(window.event);const targetElement=(e.target);if(targetElement.tagName==="INPUT"&&targetElement.id!=="menuToggle")return;if(e.code==="KeyR")movePlaceBlocks(e.altKey?-1:1);if(e.code.startsWith("Arrow"))return moveBaseOnCode(ARROW_MOVEMENT_MAP[e.code],e.altKey);if(e.code.startsWith("Digit")||e.code.startsWith("Numpad"))return updateToolbarSelected(+e.code.replace(/Numpad|Digit/gi,""));if(MOVEMENT_KEYS.includes(e.code))return changeSelectedOnCode(KEY_MOVEMENT_MAP[e.code],e.altKey);if(e.code==="KeyQ")return rotate(-1);if(e.code==="KeyE")return rotate(1);if(e.code==="KeyF")return TOOLBAR_ACTIONS[selectedToolbarIndex].onclick(null);if(e.code.includes("Shift"))return changePolySides();if(e.code==="Space")return move();if(e.code==="Escape"){closeDebugMenu();useMap(false);}};document.onkeyup=()=>{stopMoving();};const updateToolbarSelected=(keyIndex)=>{const element=TOOLBAR_ACTIONS[keyIndex];if(!element)return;TOOLBAR_ACTIONS[selectedToolbarIndex].classList.remove("toolbar-selected");selectedToolbarIndex=keyIndex;element.classList.add("toolbar-selected");};document.onwheel=(e)=>{e=e||(window.event);updateToolbarSelected(e.deltaY<0?selectedToolbarIndex-1:selectedToolbarIndex+1);};updateToolbarSelected(selectedToolbarIndex);TOOLBAR_ACTIONS[1].onclick=()=>dig();const toolbarPlace=document.getElementById("toolbar-place");TOOLBAR_ACTIONS[2].onclick=(e)=>{if(e){const{top}=toolbarPlace.getBoundingClientRect();const y=e.clientY-top;if(y<0)return movePlaceBlocks(-1);if(y>toolbarPlace.offsetHeight)return movePlaceBlocks(1);}place();};TOOLBAR_ACTIONS[3].onclick=()=>useFishingRod();TOOLBAR_ACTIONS[4].onclick=()=>useBoat();TOOLBAR_ACTIONS[5].onclick=()=>useGun();TOOLBAR_ACTIONS[6].onclick=()=>useMap();canvasContainer.onclick=(e)=>{e=e||(window.event);if(MENU_CONFIG.debugMode){const{left,top}=canvasContainer.getBoundingClientRect();const x=e.clientX-left;const y=e.clientY-top;addDebugBlockToPoint({x,y});}closeDebugMenu();stopFishing();};})();start();window.onresize=()=>{resetSize();};(()=>{const SELECT_OPTIONS={mapGeneration:Object.entries(MAP_GENERATION),};document.querySelectorAll("#menu label").forEach((l)=>{const config=(l).htmlFor;const element=(document.getElementById(config));if(!element)return;if(element.type==="checkbox"){const check=(element);check.checked=MENU_CONFIG[config];check.onchange=()=>{MENU_CONFIG[config]=check.checked;updateCanvasCss();drawEveryCell(PLAYER_ENTITY);check.blur();};}else if(element.tagName==="SELECT"){const select=(element);SELECT_OPTIONS[config].forEach(([key,value])=>{const option=document.createElement("option");option.value=value;option.innerHTML=key;select.appendChild(option);});select.value=MENU_CONFIG[config];select.onchange=()=>{MENU_CONFIG[config]=select.value;start();select.blur();};}});const teleportationIElement=(document.getElementById("teleportation-i"));const teleportationJElement=(document.getElementById("teleportation-j"));const teleportationBtn=(document.getElementById("teleport"));teleportationBtn.onclick=()=>{const i=+teleportationIElement.value;const j=+teleportationJElement.value;move(loadAndGetCell({i,j}));teleportationBtn.blur();};const zoomSlider=(document.getElementById("zoom"));zoomSlider.value=`${RENDER_INFO.cellHeight}`;zoomSlider.min=`${CONTROLS_CONFIG.minZoom}`;zoomSlider.max=`${CONTROLS_CONFIG.maxZoom}`;zoomSlider.oninput=()=>{resetSize(+zoomSlider.value);zoomSlider.blur();};const musicVolumeSlider=(document.getElementById("musicVolume"));musicVolumeSlider.value=`50`;musicVolumeSlider.min=`0`;musicVolumeSlider.max=`100`;musicVolumeSlider.oninput=()=>{setMusicVolume(+musicVolumeSlider.value);musicVolumeSlider.blur();};setMusicVolume(+musicVolumeSlider.value);})();(()=>{let mobileZoom=0;canvasContainer.ontouchstart=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];mobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);return;}};canvasContainer.ontouchmove=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];const nMobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);if(nMobileZoom>mobileZoom&&RENDER_INFO.cellHeight<CONTROLS_CONFIG.maxZoom){resetSize(RENDER_INFO.cellHeight+1);}else if(nMobileZoom<mobileZoom&&RENDER_INFO.cellHeight>CONTROLS_CONFIG.minZoom){resetSize(RENDER_INFO.cellHeight-1);}mobileZoom=nMobileZoom;}};canvasContainer.ontouchend=()=>{mobileZoom=0;};document.getElementById("change-poly").onclick=()=>{changePolySides();updatePolyImages();};document.getElementById("rotate-left").onclick=()=>rotate(-1);document.getElementById("rotate-right").onclick=()=>rotate(1);const currentPoly=(document.getElementById("current-poly"));const nextPoly=(document.getElementById("next-poly"));const updatePolyImages=()=>{setImagePos(currentPoly,POLYGONS_ENTITY_POS[RENDER_INFO.currentPoly]);setImagePos(nextPoly,POLYGONS_ENTITY_POS[getNextPolygon()]);};updatePolyImages();})();(()=>{const KEY_MOVEMENT_MAP={["KeyW"]:MOVEMENT.UP,["KeyA"]:MOVEMENT.LEFT,["KeyS"]:MOVEMENT.DOWN,["KeyD"]:MOVEMENT.RIGHT,};const ARROW_MOVEMENT_MAP={["ArrowUp"]:MOVEMENT.UP,["ArrowLeft"]:MOVEMENT.LEFT,["ArrowDown"]:MOVEMENT.DOWN,["ArrowRight"]:MOVEMENT.RIGHT,};let selectedToolbarIndex=1;const TOOLBAR_ACTIONS=[undefined,document.getElementById("toolbar-dig"),document.getElementById("toolbar-place"),document.getElementById("toolbar-fishing"),document.getElementById("toolbar-boat"),document.getElementById("toolbar-gun"),document.getElementById("toolbar-map"),];const MOVEMENT_KEYS=Object.keys(KEY_MOVEMENT_MAP);const menuToggle=(document.getElementById("menuToggle"));const closeDebugMenu=()=>(menuToggle.checked=false);document.onkeydown=(e)=>{e=e||(window.event);const targetElement=(e.target);if(targetElement.tagName==="INPUT"&&targetElement.id!=="menuToggle")return;if(e.code==="KeyR")movePlaceBlocks(e.altKey?-1:1);if(e.code.startsWith("Arrow"))return moveBaseOnCode(ARROW_MOVEMENT_MAP[e.code],e.altKey);if(e.code.startsWith("Digit")||e.code.startsWith("Numpad"))return updateToolbarSelected(+e.code.replace(/Numpad|Digit/gi,""));if(MOVEMENT_KEYS.includes(e.code))return changeSelectedOnCode(KEY_MOVEMENT_MAP[e.code],e.altKey);if(e.code==="KeyQ")return rotate(-1);if(e.code==="KeyE")return rotate(1);if(e.code==="KeyF")return TOOLBAR_ACTIONS[selectedToolbarIndex].onclick(null);if(e.code.includes("Shift"))return changePolySides();if(e.code==="Space")return move();if(e.code==="Escape"){closeDebugMenu();useMap(false);}};document.onkeyup=()=>{stopMoving();};const updateToolbarSelected=(keyIndex)=>{const element=TOOLBAR_ACTIONS[keyIndex];if(!element)return;TOOLBAR_ACTIONS[selectedToolbarIndex].classList.remove("toolbar-selected");selectedToolbarIndex=keyIndex;element.classList.add("toolbar-selected");};document.onwheel=(e)=>{e=e||(window.event);updateToolbarSelected(e.deltaY<0?selectedToolbarIndex-1:selectedToolbarIndex+1);};updateToolbarSelected(selectedToolbarIndex);TOOLBAR_ACTIONS[1].onclick=()=>dig();const toolbarPlace=document.getElementById("toolbar-place");TOOLBAR_ACTIONS[2].onclick=(e)=>{if(e){const{top}=toolbarPlace.getBoundingClientRect();const y=e.clientY-top;if(y<0)return movePlaceBlocks(-1);if(y>toolbarPlace.offsetHeight)return movePlaceBlocks(1);}place();};TOOLBAR_ACTIONS[3].onclick=()=>useFishingRod();TOOLBAR_ACTIONS[4].onclick=()=>useBoat();TOOLBAR_ACTIONS[5].onclick=()=>useGun();TOOLBAR_ACTIONS[6].onclick=()=>useMap();canvasContainer.onclick=(e)=>{e=e||(window.event);if(MENU_CONFIG.debugMode){const{left,top}=canvasContainer.getBoundingClientRect();const x=e.clientX-left;const y=e.clientY-top;addDebugBlockToPoint({x,y});}closeDebugMenu();stopFishing();};})();start();window.onresize=()=>{resetSize();};(()=>{const SELECTION_STICK_CONFIG={touchThreshold:20,};const selectionStickLeft=document.getElementById("selection-stick-left");const selectionStickRight=document.getElementById("selection-stick-right");const SELECTION_STICK_INFO=(()=>{const maxPoint=selectionStickLeft.offsetWidth/1.25;const minPoint=selectionStickLeft.offsetWidth/5;const midPoint=minPoint+(maxPoint-minPoint)/2;const maxMidPoint=midPoint+SELECTION_STICK_CONFIG.touchThreshold;const minMidPoint=midPoint-SELECTION_STICK_CONFIG.touchThreshold;return{maxPoint,minPoint,midPoint,maxMidPoint,minMidPoint};})();const moveStick=(e,stickElement)=>{e=e||(window.event);e.preventDefault();e.stopPropagation();const{clientX,clientY}=e.touches[0];const stickRect=stickElement.getBoundingClientRect();let finalX=clientX-stickRect.left;let finalY=clientY-stickRect.top;finalX=Math.min(finalX,SELECTION_STICK_INFO.maxPoint);finalX=Math.max(finalX,SELECTION_STICK_INFO.minPoint);finalY=Math.min(finalY,SELECTION_STICK_INFO.maxPoint);finalY=Math.max(finalY,SELECTION_STICK_INFO.minPoint);stickElement.style.setProperty("--selection-stick-left",`${finalX}px`);stickElement.style.setProperty("--selection-stick-top",`${finalY}px`);let code=null;const useDiagonal=finalY>SELECTION_STICK_INFO.maxMidPoint;if(useDiagonal)code=MOVEMENT.DOWN;if(finalY<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.UP;if(finalX>SELECTION_STICK_INFO.maxMidPoint)code=MOVEMENT.RIGHT;if(finalX<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.LEFT;return{code,useDiagonal};};selectionStickLeft.ontouchstart=selectionStickLeft.ontouchmove=(e)=>{const{code,useDiagonal}=moveStick(e,selectionStickLeft);if(code)changeSelectedOnCode(code,useDiagonal);};let rightStickInfo=({});const updateRightStickInfo=(e)=>(rightStickInfo=moveStick(e,selectionStickRight));selectionStickRight.ontouchstart=(e)=>{clearInterval(rightStickInfo.interval);updateRightStickInfo(e);rightStickInfo.interval=setInterval(()=>{if(rightStickInfo.code)moveBaseOnCode(rightStickInfo.code,rightStickInfo.useDiagonal);else stopMoving();},100);};selectionStickRight.ontouchmove=updateRightStickInfo;document.ontouchend=()=>{selectionStickLeft?.style.removeProperty("--selection-stick-left");selectionStickLeft?.style.removeProperty("--selection-stick-top");selectionStickRight?.style.removeProperty("--selection-stick-left");selectionStickRight?.style.removeProperty("--selection-stick-top");stopMoving();clearInterval(rightStickInfo.interval);rightStickInfo={code:null,useDiagonal:null,interval:null};};})();(()=>{const KEY_MOVEMENT_MAP={["KeyW"]:MOVEMENT.UP,["KeyA"]:MOVEMENT.LEFT,["KeyS"]:MOVEMENT.DOWN,["KeyD"]:MOVEMENT.RIGHT,};const ARROW_MOVEMENT_MAP={["ArrowUp"]:MOVEMENT.UP,["ArrowLeft"]:MOVEMENT.LEFT,["ArrowDown"]:MOVEMENT.DOWN,["ArrowRight"]:MOVEMENT.RIGHT,};let selectedToolbarIndex=1;const TOOLBAR_ACTIONS=[undefined,document.getElementById("toolbar-dig"),document.getElementById("toolbar-place"),document.getElementById("toolbar-fishing"),document.getElementById("toolbar-boat"),document.getElementById("toolbar-gun"),document.getElementById("toolbar-map"),];const MOVEMENT_KEYS=Object.keys(KEY_MOVEMENT_MAP);const menuToggle=(document.getElementById("menuToggle"));const closeDebugMenu=()=>(menuToggle.checked=false);document.onkeydown=(e)=>{e=e||(window.event);const targetElement=(e.target);if(targetElement.tagName==="INPUT"&&targetElement.id!=="menuToggle")return;if(e.code==="KeyR")movePlaceBlocks(e.altKey?-1:1);if(e.code.startsWith("Arrow"))return moveBaseOnCode(ARROW_MOVEMENT_MAP[e.code],e.altKey);if(e.code.startsWith("Digit")||e.code.startsWith("Numpad"))return updateToolbarSelected(+e.code.replace(/Numpad|Digit/gi,""));if(MOVEMENT_KEYS.includes(e.code))return changeSelectedOnCode(KEY_MOVEMENT_MAP[e.code],e.altKey);if(e.code==="KeyQ")return rotate(-1);if(e.code==="KeyE")return rotate(1);if(e.code==="KeyF")return TOOLBAR_ACTIONS[selectedToolbarIndex].onclick(null);if(e.code.includes("Shift"))return changePolySides();if(e.code==="Space")return move();if(e.code==="Escape"){closeDebugMenu();useMap(false);}};document.onkeyup=()=>{stopMoving();};const updateToolbarSelected=(keyIndex)=>{const element=TOOLBAR_ACTIONS[keyIndex];if(!element)return;TOOLBAR_ACTIONS[selectedToolbarIndex].classList.remove("toolbar-selected");selectedToolbarIndex=keyIndex;element.classList.add("toolbar-selected");};document.onwheel=(e)=>{e=e||(window.event);updateToolbarSelected(e.deltaY<0?selectedToolbarIndex-1:selectedToolbarIndex+1);};updateToolbarSelected(selectedToolbarIndex);TOOLBAR_ACTIONS[1].onclick=()=>dig();const toolbarPlace=document.getElementById("toolbar-place");TOOLBAR_ACTIONS[2].onclick=(e)=>{if(e){const{top}=toolbarPlace.getBoundingClientRect();const y=e.clientY-top;if(y<0)return movePlaceBlocks(-1);if(y>toolbarPlace.offsetHeight)return movePlaceBlocks(1);}place();};TOOLBAR_ACTIONS[3].onclick=()=>useFishingRod();TOOLBAR_ACTIONS[4].onclick=()=>useBoat();TOOLBAR_ACTIONS[5].onclick=()=>useGun();TOOLBAR_ACTIONS[6].onclick=()=>useMap();canvasContainer.onclick=(e)=>{e=e||(window.event);if(MENU_CONFIG.debugMode){const{left,top}=canvasContainer.getBoundingClientRect();const x=e.clientX-left;const y=e.clientY-top;addDebugBlockToPoint({x,y});}closeDebugMenu();stopFishing();};})();start();window.onresize=()=>{resetSize();};const CUT_MOVEMENTS_MAP={[MOVEMENT.DOWN]:"marginTop",[MOVEMENT.LEFT]:"marginLeft",[MOVEMENT.RIGHT]:"marginRight",[MOVEMENT.UP]:"marginTop",};const container=document.getElementById("entities");const createImageElement=()=>{const img=document.createElement("div");img.className="image";return img;};const createEntityImage=(entity)=>{const img=createImageElement();img.id=entity.id;img.style.zIndex=`${entity.zIndex ||2}`;container.appendChild(img);entity.img=img;setEntitySize(entity);};const displayWinAnimation=(entity,itemPos)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);const img=createImageElement();img.classList.add("won-item");img.style.marginTop=`-${ySide}px`;setImagePos(img,itemPos);container.appendChild(img);setEntityImageSize(img,ySide/2);setImagePoint(img,point,false,ySide/2);return()=>{container.removeChild(img);};};const removeEntityImage=(entity)=>{if(entity.img)container.removeChild(entity.img);entity.img=null;};const updateEntityPoint=(entity,parentPoint)=>{if(!parentPoint&&entity.isConnected)return;const{hasInverted,canvasHeight,canvasWidth}=getPolyInfo();const point=parentPoint||calculatePointBasedOnPos(entity.cell.pos,hasInverted&&entity.cell.isInverted,PLAYER_ENTITY.cell);if(isPointOutside(point,canvasHeight,canvasWidth)){if(entity.img)removeEntityImage(entity);}else if(!entity.img){createEntityImage(entity);}if(entity.img)setImagePoint(entity.img,point);verifyEntityHeight(entity);Object.values(entity.connectedEntities).forEach((e)=>updateEntityPoint(e,point));};const updateEntityOpacity=(entity)=>{if(!entity?.img||entity?.deleted)return;entity.img.style.setProperty("--entity-opacity",`${entity.cell.modifier ||1}`);};const getEntitySize=(ySide)=>Math.round((ySide||getPolyInfo().ySide)*2.5);const setImagePos=(img,pos)=>{img.style.setProperty("--entity-position-i",`${pos.i}`);img.style.setProperty("--entity-position-j",`${pos.j}`);};const setEntityImageSize=(img,ySide)=>{if(!img)return;const size=getEntitySize(ySide);img.style.setProperty("--entity-size",`${size}px`);};const setEntitySize=(entity,ySide)=>{if(!entity?.img)return;setEntityImageSize(entity.img,ySide);setEntityImageInfo(entity);};const setEntityImageInfo=(entity)=>{const imgInfo=getEntityImageInfo(entity);if(!imgInfo.src){entity.img.style.removeProperty("--entity-img");entity.img.classList.remove("dont-use-spritesheet");}if(imgInfo.pos){setImagePos(entity.img,imgInfo.pos);}else if(imgInfo.posFn){const pos=imgInfo.posFn(!!entity.leftFootWalk);entity.leftFootWalk=!entity.leftFootWalk;setImagePos(entity.img,pos);}else if(imgInfo.src){entity.img.style.setProperty("--entity-img",`url(${imgInfo.src})`);entity.img.classList.add("dont-use-spritesheet");setImagePos(entity.img,{i:0,j:0});}};const setImagePoint=(img,point,shouldCenter,ySide)=>{if(!point)return;const entitySize=getEntitySize(ySide);img.style.setProperty("--entity-top",`${point.y -entitySize /(shouldCenter ?2 :1.25)}px`);img.style.setProperty("--entity-left",`${point.x -entitySize /2}px`);};const verifyEntityHeight=(entity)=>{if(!entity?.cell||!entity?.img)return;const{hasInverted}=getPolyInfo();const downI=hasInverted&&entity.cell.isInverted?RENDER_INFO.rotationTurns:RENDER_INFO.rotationTurns+Math.floor(RENDER_INFO.currentPoly/2);const downPos=getPosByIndex(entity.cell,downI);const downCell=getCell(downPos);if(!downCell)return;entity.img.classList.remove("not-inverted-both-walls");entity.img.classList.remove("not-inverted-right-wall");entity.img.classList.remove("not-inverted-left-wall");entity.img.classList.remove("behind-wall");if(hasInverted&&!entity.cell.isInverted){const rightCell=downCell;const leftI=RENDER_INFO.rotationTurns+RENDER_INFO.currentPoly-1;const leftPos=getPosByIndex(entity.cell,leftI);const leftCell=getCell(leftPos);if(rightCell.wall&&leftCell.wall){entity.img.classList.add("not-inverted-both-walls");}else if(rightCell.wall){entity.img.classList.add("not-inverted-right-wall");}else if(leftCell.wall){entity.img.classList.add("not-inverted-left-wall");}}else if(downCell.wall){entity.img.classList.add("behind-wall");}if(Object.values(entity.connectedEntities).length)entity.img.classList.add("behind-wall");};const getEntityImageInfo=(entity)=>{const typeMap=ENTITY_IMAGES_MAP[entity.type];const mapType=typeMap[entity.currentImgType]||typeMap[IMG_MAP_TYPES.DEFAULT];return(mapType[entity.currentDirection||MOVEMENT.DOWN]||mapType[MOVEMENT.DOWN]);};const updateEntityImage=(entity,direction,imgMapType)=>{if(!entity?.img)return;entity.currentImgType=imgMapType;entity.currentDirection=direction;setEntityImageInfo(entity);entity.img.style.marginTop=null;entity.img.style.marginLeft=null;entity.img.style.marginRight=null;};const cutEntityImage=(entity,direction)=>{if(entity.movementsToCut?.length){if(entity.movementsToCut.includes(direction)){const{ySide}=getPolyInfo();entity.img.style[CUT_MOVEMENTS_MAP[direction]]=`${ySide}px`;}}};const playerHealthContainer=document.getElementById("health-container");const updatePlayerHearts=()=>{playerHealthContainer.innerHTML="";let curretnHealth=PLAYER_ENTITY.health;for(let i=0;i<PLAYER_CONFIG.maxHealth;i++){const heartImg=createImageElement();if(curretnHealth){setImagePos(heartImg,{i:2,j:3});heartImg.classList.add("filled");curretnHealth--;}else{setImagePos(heartImg,{i:2,j:2});}playerHealthContainer.appendChild(heartImg);}};updatePlayerHearts();const GENERATION_CONFIG={chunkSize:50,};const isCellInverted=({i,j})=>(i+j)%2!==0;const getAdjacentPos=({i,j},isInverted)=>{return{[KNOWN_POLYGONS.TRIANGLE]:isInverted?[{i:i+1,j},{i,j:j-1},{i,j:j+1},]:[{i:i-1,j},{i,j:j+1},{i,j:j-1},],[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j},{i,j:j+1},{i:i+1,j},{i,j:j-1},],[KNOWN_POLYGONS.HEXAGON]:j%2?[{i:i-1,j},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},]:[{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j},{i,j:j-1},{i:i-1,j:j-1},],};};const getAdjacentPosWithCorners=({i,j},isInverted)=>{return{...getAdjacentPos({i,j},isInverted),[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j:j-1},{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},],};};const createCellProps=(pos)=>{const isInverted=isCellInverted(pos);return{pos,isInverted,adjacentPos:getAdjacentPos(pos,isInverted),adjacentPosWithCorners:getAdjacentPosWithCorners(pos,isInverted),};};const createCell=(pos,block)=>{let cell=getCell(pos);if(!cell){cell=({});cell.entityType=null;if(block){cell.block=block;cell.layer=block.layer;cell.color=tweakColor(block.color);}}return{...createCellProps(pos),...cell};};const createEntitiesForCell=(cell,onMove=false)=>{if(!cell.block.spawnableEntities?.length)return;for(const sEntity of cell.block.spawnableEntities){const canSpawn=onMove?sEntity.spawnOnMove:!sEntity.spawnOnMove;if(!canSpawn)continue;let probability=sEntity.probability;if(sEntity.increaseWithTime)probability*=ENTITY_INFO.timeOfDay/2;if(Math.random()<probability){spawnEntity(sEntity.entityType,cell);return;}}};const getBiome=(pos)=>{switch(MENU_CONFIG.mapGeneration){case MAP_GENERATION.MIX:const biomeValue=getValue(pos.i,pos.j,PERLIN_VECTORS.BIOME);return BIOMES.find((b)=>biomeValue>=b.minValue);default:case MAP_GENERATION.DISTANCE:const distance=getPosDistance(INITIAL_POS,pos);return BIOMES.filter((b)=>(b.negativeJ===undefined||b.negativeJ===pos.j<0)&&(b.negativeI===undefined||b.negativeI===pos.i<0)).find((b)=>distance>=b.minDistance);}};const loadChunk=(initialPos)=>{const offsetPos=getChunkStart(initialPos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const biomeMap=({});let minesObj=(null);for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){const nI=i+offsetPos.i;for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){const nJ=j+offsetPos.j;const pos={i:nI,j:nJ};const biome=minesObj?MINE_BIOMES.MINES:getBiome(pos);biomeMap[biome.name]=(biomeMap[biome.name]||0)+1;const value=getValue(nI,nJ,PERLIN_VECTORS.BLOCK);const originalBlock=biome.ranges.find((r)=>value<=r.max);const isHighBlock=originalBlock.layer>0;const cellBlock=isHighBlock?biome.higherGroundBlock:originalBlock;const cell=createCell(pos,cellBlock);if(minesObj)cell.hasBomb=minesObj.isBomb({i,j});addCell(pos,cell);if(isHighBlock)cell.wall={block:originalBlock,color:tweakColor(originalBlock.color),};else createEntitiesForCell(cell);}}const biomeName=Object.entries(biomeMap).sort(([_,a],[__,b])=>b-a)[0][0];addBiomeToMap(offsetPos,BIOMES.find((b)=>b.name===biomeName));};const loadAndGetCell=(pos)=>{if(!getCell(pos))loadChunk(pos);return getCell(pos);};const getCenterCell=()=>{const{rows,columns}=getPolyInfo();const{iOffset,jOffset}=RENDER_INFO;const i=Math.floor(rows/2)+iOffset;const j=Math.floor(columns/2)+jOffset;return loadAndGetCell({i,j});};const getBorderCells=(baseCell)=>{const{rows,columns}=getPolyInfo();const halfR=Math.floor(rows/2);const halfC=Math.floor(columns/2);const{i,j}=baseCell.pos;const tI=i-halfR;const bI=i+halfR;const lJ=j-halfC;const rJ=j+halfC;const positions=([]);for(let index=lJ;index<=rJ;index++){positions.push({i:tI,j:index});positions.push({i:bI,j:index});}for(let index=tI;index<=bI;index++){positions.push({i:index,j:lJ});positions.push({i:index,j:rJ});}return positions.map(getCell);};const spawnEntities=(baseCell)=>{getBorderCells(baseCell).forEach((cell)=>{if(!!cell?.block&&!cell.wall&&!cell.entityType)createEntitiesForCell(cell,true);});};const destroyWall=(cell)=>{const onDestroy=cell.wall?.block?.onDestroy;if(cell.wall){cell.wall=null;}if(onDestroy)onDestroy(cell);};const getRange=(n,range)=>Math.floor(n/range)*range;const getChunkStart=(pos,height,width)=>({i:getRange(pos.i,height),j:getRange(pos.j,width),});const isCellInverted=({i,j})=>(i+j)%2!==0;const getAdjacentPos=({i,j},isInverted)=>{return{[KNOWN_POLYGONS.TRIANGLE]:isInverted?[{i:i+1,j},{i,j:j-1},{i,j:j+1},]:[{i:i-1,j},{i,j:j+1},{i,j:j-1},],[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j},{i,j:j+1},{i:i+1,j},{i,j:j-1},],[KNOWN_POLYGONS.HEXAGON]:j%2?[{i:i-1,j},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},]:[{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j},{i,j:j-1},{i:i-1,j:j-1},],};};const getAdjacentPosWithCorners=({i,j},isInverted)=>{return{...getAdjacentPos({i,j},isInverted),[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j:j-1},{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},],};};const createCellProps=(pos)=>{const isInverted=isCellInverted(pos);return{pos,isInverted,adjacentPos:getAdjacentPos(pos,isInverted),adjacentPosWithCorners:getAdjacentPosWithCorners(pos,isInverted),};};const createCell=(pos,block)=>{let cell=getCell(pos);if(!cell){cell=({});cell.entityType=null;if(block){cell.block=block;cell.layer=block.layer;cell.color=tweakColor(block.color);}}return{...createCellProps(pos),...cell};};const createEntitiesForCell=(cell,onMove=false)=>{if(!cell.block.spawnableEntities?.length)return;for(const sEntity of cell.block.spawnableEntities){const canSpawn=onMove?sEntity.spawnOnMove:!sEntity.spawnOnMove;if(!canSpawn)continue;let probability=sEntity.probability;if(sEntity.increaseWithTime)probability*=ENTITY_INFO.timeOfDay/2;if(Math.random()<probability){spawnEntity(sEntity.entityType,cell);return;}}};const getBiome=(pos)=>{switch(MENU_CONFIG.mapGeneration){case MAP_GENERATION.MIX:const biomeValue=getValue(pos.i,pos.j,PERLIN_VECTORS.BIOME);return BIOMES.find((b)=>biomeValue>=b.minValue);default:case MAP_GENERATION.DISTANCE:const distance=getPosDistance(INITIAL_POS,pos);return BIOMES.filter((b)=>(b.negativeJ===undefined||b.negativeJ===pos.j<0)&&(b.negativeI===undefined||b.negativeI===pos.i<0)).find((b)=>distance>=b.minDistance);}};const loadChunk=(initialPos)=>{const offsetPos=getChunkStart(initialPos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const biomeMap=({});let minesObj=(null);for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){const nI=i+offsetPos.i;for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){const nJ=j+offsetPos.j;const pos={i:nI,j:nJ};const biome=minesObj?MINE_BIOMES.MINES:getBiome(pos);biomeMap[biome.name]=(biomeMap[biome.name]||0)+1;const value=getValue(nI,nJ,PERLIN_VECTORS.BLOCK);const originalBlock=biome.ranges.find((r)=>value<=r.max);const isHighBlock=originalBlock.layer>0;const cellBlock=isHighBlock?biome.higherGroundBlock:originalBlock;const cell=createCell(pos,cellBlock);if(minesObj)cell.hasBomb=minesObj.isBomb({i,j});addCell(pos,cell);if(isHighBlock)cell.wall={block:originalBlock,color:tweakColor(originalBlock.color),};else createEntitiesForCell(cell);}}const biomeName=Object.entries(biomeMap).sort(([_,a],[__,b])=>b-a)[0][0];addBiomeToMap(offsetPos,BIOMES.find((b)=>b.name===biomeName));};const loadAndGetCell=(pos)=>{if(!getCell(pos))loadChunk(pos);return getCell(pos);};const getCenterCell=()=>{const{rows,columns}=getPolyInfo();const{iOffset,jOffset}=RENDER_INFO;const i=Math.floor(rows/2)+iOffset;const j=Math.floor(columns/2)+jOffset;return loadAndGetCell({i,j});};const getBorderCells=(baseCell)=>{const{rows,columns}=getPolyInfo();const halfR=Math.floor(rows/2);const halfC=Math.floor(columns/2);const{i,j}=baseCell.pos;const tI=i-halfR;const bI=i+halfR;const lJ=j-halfC;const rJ=j+halfC;const positions=([]);for(let index=lJ;index<=rJ;index++){positions.push({i:tI,j:index});positions.push({i:bI,j:index});}for(let index=tI;index<=bI;index++){positions.push({i:index,j:lJ});positions.push({i:index,j:rJ});}return positions.map(getCell);};const spawnEntities=(baseCell)=>{getBorderCells(baseCell).forEach((cell)=>{if(!!cell?.block&&!cell.wall&&!cell.entityType)createEntitiesForCell(cell,true);});};const destroyWall=(cell)=>{const onDestroy=cell.wall?.block?.onDestroy;if(cell.wall){cell.wall=null;}if(onDestroy)onDestroy(cell);};const hexToRgb=(hexColor)=>{let hex=hexColor.trim().slice(1);let r=parseInt(hex.substring(0,2),16);let g=parseInt(hex.substring(2,4),16);let b=parseInt(hex.substring(4,6),16);return{r,g,b};};const TRACK_TYPES={TRACK1:"TRACK1",TRACK2:"TRACK2",TRACK3:"TRACK3",TRACK4:"TRACK4",TRACK5:"TRACK5",TRACK6:"TRACK6",TRACK7:"TRACK7",TRACK8:"TRACK8",TRACK9:"TRACK9",TRACK11:"TRACK11",TRACK10:"TRACK10",TRACK12:"TRACK12",TRACK13:"TRACK13",TRACK14:"TRACK14",TRACK15:"TRACK15",TRACK16:"TRACK16",};const ENEMY_SPAWN={probability:0.00001,entityType:ENTITY_TYPES.ENEMY,spawnOnMove:true,increaseWithTime:true,};const WATER_SPAWNS=[{probability:0.0005,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const FOREST_SPAWNS=[{probability:0.01,entityType:ENTITY_TYPES.TREE},{probability:0.0005,entityType:ENTITY_TYPES.RABBIT},ENEMY_SPAWN,];const SNOW_PROPS={biomeType:BIOME_TYPES.SNOW,spawnableEntities:[{probability:0.01,entityType:ENTITY_TYPES.TREE},ENEMY_SPAWN,],};const DESERT_PROPS={biomeType:BIOME_TYPES.DESERT,spawnableEntities:[{probability:0.001,entityType:ENTITY_TYPES.TREE},{...ENEMY_SPAWN,probability:0.00005,},],};const EMPTY_BLOCK=({layer:0,color:{r:-1,g:-1,b:-1},});const BLOCKS=({DEEP_WATER:{name:"DEEP_WATER",color:hexToRgb("#256299"),layer:0,isFluid:true,spawnableEntities:WATER_SPAWNS,trackType:TRACK_TYPES.TRACK5,},WATER:{name:"WATER",color:hexToRgb("#2375b4"),layer:0,isFluid:true,trackType:TRACK_TYPES.TRACK4,},LOW_GRASS:{name:"LOW_GRASS",color:hexToRgb("#457950"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK2,},MID_GRASS:{name:"MID_GRASS",color:hexToRgb("#2d673e"),layer:0,spawnableEntities:FOREST_SPAWNS,trackType:TRACK_TYPES.TRACK1,},HIGH_GRASS:{name:"HIGH_GRASS",color:hexToRgb("#2d673e"),layer:1,trackType:TRACK_TYPES.TRACK1,},DIRT:{name:"DIRT",color:hexToRgb("#3F573A"),layer:1,trackType:TRACK_TYPES.TRACK6,},ROCK:{name:"ROCK",color:hexToRgb("#CBC0BB"),layer:1,},BEACH_SAND:{name:"BEACH_SAND",color:hexToRgb("#ab976a"),layer:0,spawnableEntities:[ENEMY_SPAWN],trackType:TRACK_TYPES.TRACK3,},FROZEN_WATER:{name:"FROZEN_WATER",color:hexToRgb("#94F2F4"),layer:0,trackType:TRACK_TYPES.TRACK11,...SNOW_PROPS,},FROZEN_SEA_SHORE:{name:"FROZEN_SEA_SHORE",color:hexToRgb("#A0E6EC"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},SLUSH:{name:"SLUSH",color:hexToRgb("#D0ECEB"),layer:0,trackType:TRACK_TYPES.TRACK8,...SNOW_PROPS,},ICE:{name:"ICE",color:hexToRgb("#ECFFFD"),layer:0,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},HIGH_ICE:{name:"HIGH_ICE",color:hexToRgb("#ECFFFD"),layer:1,trackType:TRACK_TYPES.TRACK7,...SNOW_PROPS,},DUST:{name:"DUST",color:hexToRgb("#DAA98B"),layer:0,trackType:TRACK_TYPES.TRACK16,...DESERT_PROPS,},SAND:{name:"SAND",color:hexToRgb("#EC912E"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},DARK_SAND:{name:"DARK_SAND",color:hexToRgb("#CC7025"),layer:0,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},TERRACOTA:{name:"TERRACOTA",color:hexToRgb("#9F561A"),layer:0,trackType:TRACK_TYPES.TRACK15,...DESERT_PROPS,},HIGH_TERRACOTA:{name:"HIGH_TERRACOTA",color:hexToRgb("#9F561A"),layer:1,trackType:TRACK_TYPES.TRACK14,...DESERT_PROPS,},});const addPropsToBlock=(block,props)=>({...block,...props});const BIOMES_RAW=({FOREST:{name:"FOREST",mapColor:BLOCKS.MID_GRASS.color,minValue:-1,minDistance:0,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.WATER,{max:-0.4}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:-0.2}),addPropsToBlock(BLOCKS.MID_GRASS,{max:0.4}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.5}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},OCEAN:{name:"OCEAN",mapColor:BLOCKS.WATER.color,minValue:-0.2,minDistance:75,higherGroundBlock:BLOCKS.MID_GRASS,ranges:[addPropsToBlock(BLOCKS.DEEP_WATER,{max:-0.1}),addPropsToBlock(BLOCKS.WATER,{max:0.3}),addPropsToBlock(BLOCKS.BEACH_SAND,{max:0.5}),addPropsToBlock(BLOCKS.LOW_GRASS,{max:0.7}),addPropsToBlock(BLOCKS.HIGH_GRASS,{max:0.8}),addPropsToBlock(BLOCKS.DIRT,{max:1}),],},SNOW:{name:"SNOW",mapColor:BLOCKS.ICE.color,minValue:0.2,minDistance:150,higherGroundBlock:BLOCKS.ICE,negativeJ:false,ranges:[addPropsToBlock(BLOCKS.FROZEN_WATER,{max:-0.2}),addPropsToBlock(BLOCKS.FROZEN_SEA_SHORE,{max:0}),addPropsToBlock(BLOCKS.SLUSH,{max:0.1}),addPropsToBlock(BLOCKS.HIGH_ICE,{max:1}),],},DESERT:{name:"DESERT",mapColor:BLOCKS.SAND.color,minValue:0,minDistance:150,higherGroundBlock:BLOCKS.TERRACOTA,negativeJ:true,ranges:[addPropsToBlock(BLOCKS.DUST,{max:-0.4}),addPropsToBlock(BLOCKS.SAND,{max:-0.2}),addPropsToBlock(BLOCKS.DARK_SAND,{max:0}),addPropsToBlock(BLOCKS.TERRACOTA,{max:0.2}),addPropsToBlock(BLOCKS.HIGH_TERRACOTA,{max:1}),],},});const BIOMES=Object.values(BIOMES_RAW).sort((a,b)=>b.minDistance-a.minDistance);let BIOME_MAPS=([]);const resetBiomes=()=>(BIOME_MAPS=[]);const getPosBiomeOffset=({i,j})=>({i:i/GENERATION_CONFIG.chunkSize,j:j/GENERATION_CONFIG.chunkSize,});const addBiomeToMap=(pos,biome)=>{const{i,j}=getPosBiomeOffset(pos);if(!BIOME_MAPS[i])BIOME_MAPS[i]=[];if(BIOME_MAPS[i][j])return;BIOME_MAPS[i][j]=biome;};const getBiomeFromMap=(pos)=>{pos=getChunkStart(pos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const{i,j}=getPosBiomeOffset(pos);return BIOME_MAPS[i]?.[j];};const getBiomeMap=()=>BIOME_MAPS;const createMinesObj=()=>{const minefield=([]);const MINES_CONFIG={bombsNum:Math.round(GENERATION_CONFIG.chunkSize**2/4),};const createField=()=>{for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){minefield[i]=[];for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){minefield[i][j]=false;}}};const getIndexForBomb=()=>{const limit=GENERATION_CONFIG.chunkSize-2;return Math.floor(Math.random()*limit)+1;};const addBomb=()=>{const row=getIndexForBomb();const column=getIndexForBomb();if(minefield[row][column])return false;minefield[row][column]=true;return true;};const addBombs=()=>{for(let i=0;i<MINES_CONFIG.bombsNum;i++){if(!addBomb())i--;}};createField();addBombs();return{isBomb:(pos)=>minefield[pos.i][pos.j],};};const MINE_BLOCKS=({MINES_LOW:{name:"MINES_LOW",color:hexToRgb("#d3d3d3"),layer:0,indestructible:true,isFluid:false,},MINES_HIGH:{name:"MINES_HIGH",color:hexToRgb("#d3d3d3"),layer:1,isFluid:false,onDestroy:(cell)=>{const aCells=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);const isNextToBomb=!!aCells.find((c)=>c.hasBomb);if(isNextToBomb)return;cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell).filter((c)=>c.wall?.block?.name==="MINES_HIGH"&&!c.hasBomb).forEach((c)=>{const onDestroy=c.wall.block.onDestroy;c.wall=null;onDestroy(c);});},},});const MINE_BIOMES=({MINES:{name:"MINES",mapColor:MINE_BLOCKS.MINES_LOW.color,minValue:-1,minDistance:0,higherGroundBlock:MINE_BLOCKS.MINES_LOW,ranges:[addPropsToBlock(MINE_BLOCKS.MINES_HIGH,{max:1})],},});const isCellInverted=({i,j})=>(i+j)%2!==0;const getAdjacentPos=({i,j},isInverted)=>{return{[KNOWN_POLYGONS.TRIANGLE]:isInverted?[{i:i+1,j},{i,j:j-1},{i,j:j+1},]:[{i:i-1,j},{i,j:j+1},{i,j:j-1},],[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j},{i,j:j+1},{i:i+1,j},{i,j:j-1},],[KNOWN_POLYGONS.HEXAGON]:j%2?[{i:i-1,j},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},]:[{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j},{i,j:j-1},{i:i-1,j:j-1},],};};const getAdjacentPosWithCorners=({i,j},isInverted)=>{return{...getAdjacentPos({i,j},isInverted),[KNOWN_POLYGONS.SQUARE]:[{i:i-1,j:j-1},{i:i-1,j},{i:i-1,j:j+1},{i,j:j+1},{i:i+1,j:j+1},{i:i+1,j},{i:i+1,j:j-1},{i,j:j-1},],};};const createCellProps=(pos)=>{const isInverted=isCellInverted(pos);return{pos,isInverted,adjacentPos:getAdjacentPos(pos,isInverted),adjacentPosWithCorners:getAdjacentPosWithCorners(pos,isInverted),};};const createCell=(pos,block)=>{let cell=getCell(pos);if(!cell){cell=({});cell.entityType=null;if(block){cell.block=block;cell.layer=block.layer;cell.color=tweakColor(block.color);}}return{...createCellProps(pos),...cell};};const createEntitiesForCell=(cell,onMove=false)=>{if(!cell.block.spawnableEntities?.length)return;for(const sEntity of cell.block.spawnableEntities){const canSpawn=onMove?sEntity.spawnOnMove:!sEntity.spawnOnMove;if(!canSpawn)continue;let probability=sEntity.probability;if(sEntity.increaseWithTime)probability*=ENTITY_INFO.timeOfDay/2;if(Math.random()<probability){spawnEntity(sEntity.entityType,cell);return;}}};const getBiome=(pos)=>{switch(MENU_CONFIG.mapGeneration){case MAP_GENERATION.MIX:const biomeValue=getValue(pos.i,pos.j,PERLIN_VECTORS.BIOME);return BIOMES.find((b)=>biomeValue>=b.minValue);default:case MAP_GENERATION.DISTANCE:const distance=getPosDistance(INITIAL_POS,pos);return BIOMES.filter((b)=>(b.negativeJ===undefined||b.negativeJ===pos.j<0)&&(b.negativeI===undefined||b.negativeI===pos.i<0)).find((b)=>distance>=b.minDistance);}};const loadChunk=(initialPos)=>{const offsetPos=getChunkStart(initialPos,GENERATION_CONFIG.chunkSize,GENERATION_CONFIG.chunkSize);const biomeMap=({});let minesObj=(null);for(let i=0;i<GENERATION_CONFIG.chunkSize;i++){const nI=i+offsetPos.i;for(let j=0;j<GENERATION_CONFIG.chunkSize;j++){const nJ=j+offsetPos.j;const pos={i:nI,j:nJ};const biome=minesObj?MINE_BIOMES.MINES:getBiome(pos);biomeMap[biome.name]=(biomeMap[biome.name]||0)+1;const value=getValue(nI,nJ,PERLIN_VECTORS.BLOCK);const originalBlock=biome.ranges.find((r)=>value<=r.max);const isHighBlock=originalBlock.layer>0;const cellBlock=isHighBlock?biome.higherGroundBlock:originalBlock;const cell=createCell(pos,cellBlock);if(minesObj)cell.hasBomb=minesObj.isBomb({i,j});addCell(pos,cell);if(isHighBlock)cell.wall={block:originalBlock,color:tweakColor(originalBlock.color),};else createEntitiesForCell(cell);}}const biomeName=Object.entries(biomeMap).sort(([_,a],[__,b])=>b-a)[0][0];addBiomeToMap(offsetPos,BIOMES.find((b)=>b.name===biomeName));};const loadAndGetCell=(pos)=>{if(!getCell(pos))loadChunk(pos);return getCell(pos);};const getCenterCell=()=>{const{rows,columns}=getPolyInfo();const{iOffset,jOffset}=RENDER_INFO;const i=Math.floor(rows/2)+iOffset;const j=Math.floor(columns/2)+jOffset;return loadAndGetCell({i,j});};const getBorderCells=(baseCell)=>{const{rows,columns}=getPolyInfo();const halfR=Math.floor(rows/2);const halfC=Math.floor(columns/2);const{i,j}=baseCell.pos;const tI=i-halfR;const bI=i+halfR;const lJ=j-halfC;const rJ=j+halfC;const positions=([]);for(let index=lJ;index<=rJ;index++){positions.push({i:tI,j:index});positions.push({i:bI,j:index});}for(let index=tI;index<=bI;index++){positions.push({i:index,j:lJ});positions.push({i:index,j:rJ});}return positions.map(getCell);};const spawnEntities=(baseCell)=>{getBorderCells(baseCell).forEach((cell)=>{if(!!cell?.block&&!cell.wall&&!cell.entityType)createEntitiesForCell(cell,true);});};const destroyWall=(cell)=>{const onDestroy=cell.wall?.block?.onDestroy;if(cell.wall){cell.wall=null;}if(onDestroy)onDestroy(cell);};const createMazeObj=(mazeInfos,mazeCircleInfos)=>{let MAZE_GRID=([]);const MAZE_POLYS_INFO=({});const getMazePolyInfo=()=>MAZE_POLYS_INFO[RENDER_INFO.currentPoly];const CIRCLE_INFO=({cellHeight:0,center:null,rows:0,columns:0,});const MAZE_INFO=({rows:0,columns:0,isCircle:false,currentCell:null,queue:[],});const getMazeCell=({i,j})=>MAZE_GRID[i]?.[j];function*iterateOverMaze(){const rows=getMazeRows();for(let i=0;i<rows;i++){const numCells=getNumCellsPerMazeRow(i);for(let j=0;j<numCells;j++){yield{i,j};}}}const createMazeGrid=()=>{MAZE_GRID=[];for(const{i,j}of iterateOverMaze()){MAZE_GRID[i]=MAZE_GRID[i]||[];MAZE_GRID[i][j]=createCellMaze({i,j});}};const createCellMaze=(pos)=>{const cell=(createCellProps(pos));cell.visited=false;cell.solved=false;cell.path=false;cell.borders=[...new Array(RENDER_INFO.currentPoly)].map(()=>true);if(MAZE_INFO.isCircle)createCircleCellMaze(cell);else cell.point=calculateMazePoint(pos);return cell;};const calculateMazePoint=({i,j})=>{const{calcX,calcY,ySide,shouldIntercalate}=getMazePolyInfo();const x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=ySide;return{x,y};};const getMazeRows=()=>MAZE_INFO.isCircle?CIRCLE_INFO.rows:MAZE_INFO.rows;const getNumCellsPerMazeRow=(rowIndex)=>MAZE_INFO.isCircle?CIRCLE_INFO.columns-Math.floor((rowIndex+1)/2):MAZE_INFO.columns;const createCircleCellMaze=(cell)=>{const{i,j}=cell.pos;const topRadius=(CIRCLE_INFO.rows-i)*CIRCLE_INFO.cellHeight;const bottomRadius=topRadius-CIRCLE_INFO.cellHeight;const topAngle=Math.atan2(-topRadius,0);const bottomAngle=bottomRadius?topAngle:0;const numCells=getNumCellsPerMazeRow(i);const parts=(Math.PI*1.5-topAngle)/numCells;const leftBorder=j*parts;const rightBorder=(j+1)*parts;const topLeftAngle=topAngle+leftBorder;const topRightAngle=topAngle+rightBorder;const bottomLeftAngle=bottomAngle+leftBorder;const bottomRightAngle=bottomAngle+rightBorder;const topLeftPoint=getMazePoint(topRadius,topLeftAngle);const topRightPoint=getMazePoint(topRadius,topRightAngle);const bottomLeftPoint=getMazePoint(bottomRadius,bottomLeftAngle);const bottomRightPoint=getMazePoint(bottomRadius,bottomRightAngle);const points=[getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topLeftAngle),getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topRightAngle),];const x=points.reduce((acc,p)=>acc+p.x,0)/points.length;const y=points.reduce((acc,p)=>acc+p.y,0)/points.length;cell.point={x,y};cell.circleProps={topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topRadius,bottomRadius,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,adjacentPos:cell.adjacentPos[KNOWN_POLYGONS.SQUARE].map((aPos)=>({i:aPos.i,j:aPos.j<0?numCells-1:aPos.j>=numCells?0:aPos.j,})),};};const getMazePoint=(radius,angle)=>({x:CIRCLE_INFO.center.x+Math.cos(angle)*radius,y:CIRCLE_INFO.center.y+Math.sin(angle)*radius,});const buildMaze=()=>{createMazeGrid();MAZE_INFO.queue=[];MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);const lastCell=getLastMazeCell();while(MAZE_INFO.currentCell)MAZE_INFO.currentCell=buildCellMaze(MAZE_INFO.currentCell,lastCell);if(!MAZE_INFO.isCircle&&lastCell){openBorderForCellMaze(lastCell,getMazeCell(getAdjPos(lastCell)[0]));lastCell.visited=true;}if(!MAZE_INFO.isCircle&&getMazePolyInfo().hasInverted){for(const pos of iterateOverMaze()){const cell=getMazeCell(pos);cell.invertedBorders=[...cell.borders].reverse();}}MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const openBorderForCellMaze=(cell,nextCell)=>{const adjacentIndex=getNextCellMazeAdjacentIndex(cell,nextCell);const nextAdjacentIndex=getNextCellMazeAdjacentIndex(nextCell,cell);cell.borders[adjacentIndex]=false;nextCell.borders[nextAdjacentIndex]=false;};const buildCellMaze=(cell,lastCell)=>{cell.visited=true;const nextCell=getNextCellMaze(cell,(c)=>!!c&&!c.visited&&c!==lastCell,true);if(!nextCell)return null;openBorderForCellMaze(cell,nextCell);return nextCell;};const getLastMazeCell=()=>getMazeCell({i:MAZE_INFO.rows-1,j:MAZE_INFO.columns-1});const isMazeSolved=()=>!MAZE_INFO.currentCell||(MAZE_INFO.isCircle?MAZE_INFO.currentCell.pos.i===CIRCLE_INFO.rows-1:MAZE_INFO.currentCell===getLastMazeCell());const solveMaze=()=>{while(!isMazeSolved())MAZE_INFO.currentCell=solveCellMaze(MAZE_INFO.currentCell);solveCellMaze(MAZE_INFO.currentCell);MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const solveCellMaze=(cell)=>{if(!cell)return;cell.solved=true;cell.path=true;const prevLength=MAZE_INFO.queue.length;const nextCell=getNextCellMaze(cell,(c)=>{if(!c||c.solved)return false;const nextIndex=getNextCellMazeAdjacentIndex(cell,c);return!cell.borders[nextIndex];});if(prevLength>MAZE_INFO.queue.length)cell.path=false;return nextCell;};const getAdjPos=(cell)=>cell.circleProps?.adjacentPos||cell.adjacentPos[RENDER_INFO.currentPoly];const getNextCellMaze=(cell,cellFilter,isRandom=false)=>{const adjacentPos=getAdjPos(cell);const aCells=adjacentPos.map(getMazeCell).filter(cellFilter);if(!aCells.length){if(!MAZE_INFO.queue.length)return null;const prevPos=MAZE_INFO.queue.pop();return getMazeCell(prevPos);}MAZE_INFO.queue.push(cell.pos);return aCells[isRandom?getRandomInt(aCells.length):aCells.length-1];};const getNextCellMazeAdjacentIndex=(cell,nextCell)=>{let nextIndex=0;const adjacentPos=getAdjPos(cell);while(nextIndex<adjacentPos.length){const{i,j}=adjacentPos[nextIndex];if(nextCell.pos.i===i&&nextCell.pos.j===j)break;nextIndex++;}return nextIndex;};const mazeMove=(posIndex)=>{if(posIndex===undefined||MAZE_INFO.currentCell.borders[posIndex])return;const nextPos=getAdjPos(MAZE_INFO.currentCell)[posIndex];if(!nextPos)return;const nextCell=getMazeCell(nextPos);if(!nextCell)return;const oldCell=MAZE_INFO.currentCell;MAZE_INFO.currentCell=nextCell;const prevCell=MAZE_INFO.queue[MAZE_INFO.queue.length-1];if(nextCell.pos===prevCell){oldCell.path=false;MAZE_INFO.queue.pop();}else{oldCell.path=true;MAZE_INFO.queue.push(oldCell.pos);}return MAZE_INFO.currentCell;};const initMaze=()=>{for(const p of KNOWN_POLYGONS_VALUES){MAZE_POLYS_INFO[p]=configPoly(p,mazeInfos.cellHeight);}MAZE_INFO.rows=mazeInfos.rows;MAZE_INFO.columns=mazeInfos.columns;CIRCLE_INFO.cellHeight=mazeCircleInfos?.cellHeight||mazeInfos.cellHeight;CIRCLE_INFO.rows=mazeCircleInfos?.rows||MAZE_INFO.rows*2;CIRCLE_INFO.columns=mazeCircleInfos?.columns||MAZE_INFO.columns*2;const center=(CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2)/2;CIRCLE_INFO.center={x:center,y:center};};const getMazeSize=()=>{let{ySide,xSide,shouldIntercalate,hasInverted,polySide}=getMazePolyInfo();let height=MAZE_INFO.rows*mazeInfos.cellHeight;let width=MAZE_INFO.columns*(xSide*2);if(MAZE_INFO.isCircle)height=width=CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2;else{if(hasInverted)width=(MAZE_INFO.columns*polySide)/2+polySide/2+2;if(shouldIntercalate){height+=ySide;width=width*0.8;}}return{height,width};};const setIsCircle=(isCircle)=>{MAZE_INFO.isCircle=isCircle;if(MAZE_INFO.isCircle)RENDER_INFO.currentPoly=KNOWN_POLYGONS.SQUARE;};initMaze();return{getMazeSize,mazeMove,buildMaze,solveMaze,isMazeSolved,setIsCircle,getCirclePoint:()=>CIRCLE_INFO.center,iterateOverMaze,getMazeCell,getCurrentMazeCell:()=>MAZE_INFO.currentCell,getLastMazeCell,getMazePolyInfo,};};const createMazeObj=(mazeInfos,mazeCircleInfos)=>{let MAZE_GRID=([]);const MAZE_POLYS_INFO=({});const getMazePolyInfo=()=>MAZE_POLYS_INFO[RENDER_INFO.currentPoly];const CIRCLE_INFO=({cellHeight:0,center:null,rows:0,columns:0,});const MAZE_INFO=({rows:0,columns:0,isCircle:false,currentCell:null,queue:[],});const getMazeCell=({i,j})=>MAZE_GRID[i]?.[j];function*iterateOverMaze(){const rows=getMazeRows();for(let i=0;i<rows;i++){const numCells=getNumCellsPerMazeRow(i);for(let j=0;j<numCells;j++){yield{i,j};}}}const createMazeGrid=()=>{MAZE_GRID=[];for(const{i,j}of iterateOverMaze()){MAZE_GRID[i]=MAZE_GRID[i]||[];MAZE_GRID[i][j]=createCellMaze({i,j});}};const createCellMaze=(pos)=>{const cell=(createCellProps(pos));cell.visited=false;cell.solved=false;cell.path=false;cell.borders=[...new Array(RENDER_INFO.currentPoly)].map(()=>true);if(MAZE_INFO.isCircle)createCircleCellMaze(cell);else cell.point=calculateMazePoint(pos);return cell;};const calculateMazePoint=({i,j})=>{const{calcX,calcY,ySide,shouldIntercalate}=getMazePolyInfo();const x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=ySide;return{x,y};};const getMazeRows=()=>MAZE_INFO.isCircle?CIRCLE_INFO.rows:MAZE_INFO.rows;const getNumCellsPerMazeRow=(rowIndex)=>MAZE_INFO.isCircle?CIRCLE_INFO.columns-Math.floor((rowIndex+1)/2):MAZE_INFO.columns;const createCircleCellMaze=(cell)=>{const{i,j}=cell.pos;const topRadius=(CIRCLE_INFO.rows-i)*CIRCLE_INFO.cellHeight;const bottomRadius=topRadius-CIRCLE_INFO.cellHeight;const topAngle=Math.atan2(-topRadius,0);const bottomAngle=bottomRadius?topAngle:0;const numCells=getNumCellsPerMazeRow(i);const parts=(Math.PI*1.5-topAngle)/numCells;const leftBorder=j*parts;const rightBorder=(j+1)*parts;const topLeftAngle=topAngle+leftBorder;const topRightAngle=topAngle+rightBorder;const bottomLeftAngle=bottomAngle+leftBorder;const bottomRightAngle=bottomAngle+rightBorder;const topLeftPoint=getMazePoint(topRadius,topLeftAngle);const topRightPoint=getMazePoint(topRadius,topRightAngle);const bottomLeftPoint=getMazePoint(bottomRadius,bottomLeftAngle);const bottomRightPoint=getMazePoint(bottomRadius,bottomRightAngle);const points=[getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topLeftAngle),getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topRightAngle),];const x=points.reduce((acc,p)=>acc+p.x,0)/points.length;const y=points.reduce((acc,p)=>acc+p.y,0)/points.length;cell.point={x,y};cell.circleProps={topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topRadius,bottomRadius,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,adjacentPos:cell.adjacentPos[KNOWN_POLYGONS.SQUARE].map((aPos)=>({i:aPos.i,j:aPos.j<0?numCells-1:aPos.j>=numCells?0:aPos.j,})),};};const getMazePoint=(radius,angle)=>({x:CIRCLE_INFO.center.x+Math.cos(angle)*radius,y:CIRCLE_INFO.center.y+Math.sin(angle)*radius,});const buildMaze=()=>{createMazeGrid();MAZE_INFO.queue=[];MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);const lastCell=getLastMazeCell();while(MAZE_INFO.currentCell)MAZE_INFO.currentCell=buildCellMaze(MAZE_INFO.currentCell,lastCell);if(!MAZE_INFO.isCircle&&lastCell){openBorderForCellMaze(lastCell,getMazeCell(getAdjPos(lastCell)[0]));lastCell.visited=true;}if(!MAZE_INFO.isCircle&&getMazePolyInfo().hasInverted){for(const pos of iterateOverMaze()){const cell=getMazeCell(pos);cell.invertedBorders=[...cell.borders].reverse();}}MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const openBorderForCellMaze=(cell,nextCell)=>{const adjacentIndex=getNextCellMazeAdjacentIndex(cell,nextCell);const nextAdjacentIndex=getNextCellMazeAdjacentIndex(nextCell,cell);cell.borders[adjacentIndex]=false;nextCell.borders[nextAdjacentIndex]=false;};const buildCellMaze=(cell,lastCell)=>{cell.visited=true;const nextCell=getNextCellMaze(cell,(c)=>!!c&&!c.visited&&c!==lastCell,true);if(!nextCell)return null;openBorderForCellMaze(cell,nextCell);return nextCell;};const getLastMazeCell=()=>getMazeCell({i:MAZE_INFO.rows-1,j:MAZE_INFO.columns-1});const isMazeSolved=()=>!MAZE_INFO.currentCell||(MAZE_INFO.isCircle?MAZE_INFO.currentCell.pos.i===CIRCLE_INFO.rows-1:MAZE_INFO.currentCell===getLastMazeCell());const solveMaze=()=>{while(!isMazeSolved())MAZE_INFO.currentCell=solveCellMaze(MAZE_INFO.currentCell);solveCellMaze(MAZE_INFO.currentCell);MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const solveCellMaze=(cell)=>{if(!cell)return;cell.solved=true;cell.path=true;const prevLength=MAZE_INFO.queue.length;const nextCell=getNextCellMaze(cell,(c)=>{if(!c||c.solved)return false;const nextIndex=getNextCellMazeAdjacentIndex(cell,c);return!cell.borders[nextIndex];});if(prevLength>MAZE_INFO.queue.length)cell.path=false;return nextCell;};const getAdjPos=(cell)=>cell.circleProps?.adjacentPos||cell.adjacentPos[RENDER_INFO.currentPoly];const getNextCellMaze=(cell,cellFilter,isRandom=false)=>{const adjacentPos=getAdjPos(cell);const aCells=adjacentPos.map(getMazeCell).filter(cellFilter);if(!aCells.length){if(!MAZE_INFO.queue.length)return null;const prevPos=MAZE_INFO.queue.pop();return getMazeCell(prevPos);}MAZE_INFO.queue.push(cell.pos);return aCells[isRandom?getRandomInt(aCells.length):aCells.length-1];};const getNextCellMazeAdjacentIndex=(cell,nextCell)=>{let nextIndex=0;const adjacentPos=getAdjPos(cell);while(nextIndex<adjacentPos.length){const{i,j}=adjacentPos[nextIndex];if(nextCell.pos.i===i&&nextCell.pos.j===j)break;nextIndex++;}return nextIndex;};const mazeMove=(posIndex)=>{if(posIndex===undefined||MAZE_INFO.currentCell.borders[posIndex])return;const nextPos=getAdjPos(MAZE_INFO.currentCell)[posIndex];if(!nextPos)return;const nextCell=getMazeCell(nextPos);if(!nextCell)return;const oldCell=MAZE_INFO.currentCell;MAZE_INFO.currentCell=nextCell;const prevCell=MAZE_INFO.queue[MAZE_INFO.queue.length-1];if(nextCell.pos===prevCell){oldCell.path=false;MAZE_INFO.queue.pop();}else{oldCell.path=true;MAZE_INFO.queue.push(oldCell.pos);}return MAZE_INFO.currentCell;};const initMaze=()=>{for(const p of KNOWN_POLYGONS_VALUES){MAZE_POLYS_INFO[p]=configPoly(p,mazeInfos.cellHeight);}MAZE_INFO.rows=mazeInfos.rows;MAZE_INFO.columns=mazeInfos.columns;CIRCLE_INFO.cellHeight=mazeCircleInfos?.cellHeight||mazeInfos.cellHeight;CIRCLE_INFO.rows=mazeCircleInfos?.rows||MAZE_INFO.rows*2;CIRCLE_INFO.columns=mazeCircleInfos?.columns||MAZE_INFO.columns*2;const center=(CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2)/2;CIRCLE_INFO.center={x:center,y:center};};const getMazeSize=()=>{let{ySide,xSide,shouldIntercalate,hasInverted,polySide}=getMazePolyInfo();let height=MAZE_INFO.rows*mazeInfos.cellHeight;let width=MAZE_INFO.columns*(xSide*2);if(MAZE_INFO.isCircle)height=width=CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2;else{if(hasInverted)width=(MAZE_INFO.columns*polySide)/2+polySide/2+2;if(shouldIntercalate){height+=ySide;width=width*0.8;}}return{height,width};};const setIsCircle=(isCircle)=>{MAZE_INFO.isCircle=isCircle;if(MAZE_INFO.isCircle)RENDER_INFO.currentPoly=KNOWN_POLYGONS.SQUARE;};initMaze();return{getMazeSize,mazeMove,buildMaze,solveMaze,isMazeSolved,setIsCircle,getCirclePoint:()=>CIRCLE_INFO.center,iterateOverMaze,getMazeCell,getCurrentMazeCell:()=>MAZE_INFO.currentCell,getLastMazeCell,getMazePolyInfo,};};const PERLIN_VECTORS={BIOME:Symbol("BIOME"),BLOCK:Symbol("BLOCK"),};const getValue=(()=>{const PERLIN_CONFIG={noiseResolutionBiome:75,noiseResolution:10,};const getSizeFromNoise=(size,resolution)=>{const numVectorsX=Math.floor(size/resolution)+1;const extraVectorX=size%resolution==0?0:1;return numVectorsX+extraVectorX;};const initializeVector=(vector)=>{return{width:getSizeFromNoise(vector.width,vector.resolution),height:getSizeFromNoise(vector.height,vector.resolution),vectors:[],resolution:vector.resolution,};};const vectors=({[PERLIN_VECTORS.BIOME]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolutionBiome,}),[PERLIN_VECTORS.BLOCK]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolution,}),});const updateVector=(i,j,vector)=>{const offsetPos=getChunkStart({i,j},vector.height,vector.width);for(let i=0;i<=vector.height-1;i++){const nI=i+offsetPos.i;vector.vectors[nI]=vector.vectors[nI]||[];for(let j=0;j<=vector.width-1;j++){const nJ=j+offsetPos.j;vector.vectors[nI][nJ]=getRandUnitVect();}}};const getRandUnitVect=()=>{const theta=Math.random()*2*Math.PI;return{x:Math.cos(theta),y:Math.sin(theta)};};const dotProduct=(vector,x,y,vx,vy)=>{if(!vector.vectors[vy]?.[vx])updateVector(vy,vx,vector);return dot({x:x-vx,y:y-vy},vector.vectors[vy][vx]);};const dot=(v1,v2)=>v1.x*v2.x+v1.y*v2.y;const lerp=(a,b,c)=>a+smootherstep(c)*(b-a);const smootherstep=(x)=>6*x**5-15*x**4+10*x**3;return(i,j,vectorType)=>{const vector=vectors[vectorType];const offset=0.5/vector.resolution;const x=i/vector.resolution+offset;const y=j/vector.resolution+offset;const xF=Math.floor(x);const yF=Math.floor(y);const tlv=dotProduct(vector,x,y,xF,yF);const trv=dotProduct(vector,x,y,xF+1,yF);const blv=dotProduct(vector,x,y,xF,yF+1);const brv=dotProduct(vector,x,y,xF+1,yF+1);const lerpTop=lerp(tlv,trv,x-xF);const lerpBottom=lerp(blv,brv,x-xF);const value=lerp(lerpTop,lerpBottom,y-yF);return value;};})();const DRAW_CONFIG={lightDepth:2,maxLayer:2,fluidSpeed:500,};const RENDER_CONFIG={selectedBorderColor:"white",borderColor:"black",emptyColor:"black",lineWidth:1,wallDarkness:0.5,};const blockToWall=(block,point,wallParams={},polyInfo)=>{polyInfo=polyInfo||getPolyInfo();const points=wallParams.isInverted?polyInfo.invertedPoints:polyInfo.points;const layer=wallParams.layer||0;const wallLayer=layer+1;const wallPoints=wallParams.isInverted?polyInfo.wallInvertedPoints:polyInfo.wallPoints;const commonInfos={color:block.color,pos:wallParams.pos,isInverted:wallParams.isInverted,isSelectedCell:wallParams.isSelectedCell,};return{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*layer},points:wallPoints,topInfo:{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*wallLayer},points,modifier:wallParams.modifier,},borderMap:wallParams.borderMap,modifier:wallParams.modifier*RENDER_CONFIG.wallDarkness,};};const drawContainer=document.getElementById("draw-container");const canvasContainer=document.getElementById("canvas-container");const PERLIN_VECTORS={BIOME:Symbol("BIOME"),BLOCK:Symbol("BLOCK"),};const getValue=(()=>{const PERLIN_CONFIG={noiseResolutionBiome:75,noiseResolution:10,};const getSizeFromNoise=(size,resolution)=>{const numVectorsX=Math.floor(size/resolution)+1;const extraVectorX=size%resolution==0?0:1;return numVectorsX+extraVectorX;};const initializeVector=(vector)=>{return{width:getSizeFromNoise(vector.width,vector.resolution),height:getSizeFromNoise(vector.height,vector.resolution),vectors:[],resolution:vector.resolution,};};const vectors=({[PERLIN_VECTORS.BIOME]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolutionBiome,}),[PERLIN_VECTORS.BLOCK]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolution,}),});const updateVector=(i,j,vector)=>{const offsetPos=getChunkStart({i,j},vector.height,vector.width);for(let i=0;i<=vector.height-1;i++){const nI=i+offsetPos.i;vector.vectors[nI]=vector.vectors[nI]||[];for(let j=0;j<=vector.width-1;j++){const nJ=j+offsetPos.j;vector.vectors[nI][nJ]=getRandUnitVect();}}};const getRandUnitVect=()=>{const theta=Math.random()*2*Math.PI;return{x:Math.cos(theta),y:Math.sin(theta)};};const dotProduct=(vector,x,y,vx,vy)=>{if(!vector.vectors[vy]?.[vx])updateVector(vy,vx,vector);return dot({x:x-vx,y:y-vy},vector.vectors[vy][vx]);};const dot=(v1,v2)=>v1.x*v2.x+v1.y*v2.y;const lerp=(a,b,c)=>a+smootherstep(c)*(b-a);const smootherstep=(x)=>6*x**5-15*x**4+10*x**3;return(i,j,vectorType)=>{const vector=vectors[vectorType];const offset=0.5/vector.resolution;const x=i/vector.resolution+offset;const y=j/vector.resolution+offset;const xF=Math.floor(x);const yF=Math.floor(y);const tlv=dotProduct(vector,x,y,xF,yF);const trv=dotProduct(vector,x,y,xF+1,yF);const blv=dotProduct(vector,x,y,xF,yF+1);const brv=dotProduct(vector,x,y,xF+1,yF+1);const lerpTop=lerp(tlv,trv,x-xF);const lerpBottom=lerp(blv,brv,x-xF);const value=lerp(lerpTop,lerpBottom,y-yF);return value;};})();const DRAW_CONFIG={lightDepth:2,maxLayer:2,fluidSpeed:500,};const RENDER_CONFIG={selectedBorderColor:"white",borderColor:"black",emptyColor:"black",lineWidth:1,wallDarkness:0.5,};const blockToWall=(block,point,wallParams={},polyInfo)=>{polyInfo=polyInfo||getPolyInfo();const points=wallParams.isInverted?polyInfo.invertedPoints:polyInfo.points;const layer=wallParams.layer||0;const wallLayer=layer+1;const wallPoints=wallParams.isInverted?polyInfo.wallInvertedPoints:polyInfo.wallPoints;const commonInfos={color:block.color,pos:wallParams.pos,isInverted:wallParams.isInverted,isSelectedCell:wallParams.isSelectedCell,};return{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*layer},points:wallPoints,topInfo:{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*wallLayer},points,modifier:wallParams.modifier,},borderMap:wallParams.borderMap,modifier:wallParams.modifier*RENDER_CONFIG.wallDarkness,};};const drawContainer=document.getElementById("draw-container");const canvasContainer=document.getElementById("canvas-container");const resetCanvas=()=>{const polyInfo=getPolyInfo();setCanvasSize(polyInfo.canvasHeight,polyInfo.canvasWidth);setFavicon();};const updateCanvasCss=()=>{updateConfigs();updateWeather();updateWidgets();};let filledThisRound=(new Set());let tracksCount=({});const addToTrackCount=(block)=>{if(block?.trackType)tracksCount[block.trackType]=(tracksCount[block.trackType]||0)+1;};const getAjacentCells=(cell,depth=1)=>{const result=[[cell]];for(let index=0;index<depth;index++){const cells=([]);const current=result[index];for(const element of current){if(!element)continue;const aCells=element.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);cells.push(...aCells.filter((c)=>!current.includes(c)&&!cells.includes(c)&&c!==cell));}result.push(cells);}return result;};const drawEveryCell=(baseEntity)=>{wallLayers=[];fluids=[];filledThisRound=new Set();tracksCount={};const offsetCell=baseEntity.cell.pos.j%2;const{rows,columns,shouldIntercalate}=getPolyInfo();const size=rows+columns;const adjacentCells=getAjacentCells(baseEntity.cell,DRAW_CONFIG.lightDepth);const selectedCell=getSelectedCell(baseEntity);for(let i=-columns;i<size;i++){const baseI=i+RENDER_INFO.iOffset;for(let j=-rows;j<size;j++){let nI=baseI;const nJ=j+RENDER_INFO.jOffset;const pos={i:nI,j:nJ};if(shouldIntercalate&&offsetCell&&nJ%2===0)nI=nI+1;drawCell(loadAndGetCell(pos),contextsLayers[0],baseEntity,adjacentCells,selectedCell);}}drawWalls();updateEntities();tweakFluids();updateBiomeMap();updateTracks(tracksCount);};let wallLayers=([]);const drawWalls=()=>{for(let i=1;i<DRAW_CONFIG.maxLayer;i++){const walls=wallLayers[i];clearCanvas(canvasLayers[i]);if(!walls)continue;walls.forEach((w)=>drawWall(w,contextsLayers[i]));walls.forEach((w)=>drawWallTop(w,contextsLayers[i]));}wallLayers=[];};let fluidInterval=null;let fluids=([]);const tweakFluids=debounce(()=>{clearInterval(fluidInterval);if(!fluids.length)return;const context=contextsLayers[0];fluidInterval=setInterval(()=>{fluids.forEach((fluid)=>{drawItem(context,{...fluid,color:tweakColor(fluid.color),});});},DRAW_CONFIG.fluidSpeed);},DRAW_CONFIG.fluidSpeed);const drawCell=(cell,context,baseEntity,adjacentCells,selectedCell)=>{const polyInfo=getPolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const point=calculatePointBasedOnPos(cell.pos,isInverted,baseEntity.cell);if(isPointOutside(point,polyInfo.canvasHeight,polyInfo.canvasWidth))return;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const aCells=cell.adjacentPos[RENDER_INFO.currentPoly].map(getCell);const isSelectedCell=MENU_CONFIG.showSelectedCell&&cell===selectedCell;cell.modifier=getStyleModifier(adjacentCells.findIndex((c)=>c.includes(cell)));addToTrackCount(cell.wall?.block||cell.block);if(cell.wall){const wallLayer=cell.layer+1;const shouldOffset=polyInfo.hasInverted&&!cell.isInverted;if(!wallLayers[wallLayer])wallLayers[wallLayer]=[];wallLayers[wallLayer].push(blockToWall(cell.wall,point,{layer:cell.layer,isInverted,modifier:cell.modifier,isSelectedCell,pos:cell.pos,borderMap:aCells.reduce((acc,c,i)=>{let index=i-RENDER_INFO.rotationTurns;if(shouldOffset)index=RENDER_INFO.currentPoly-1-index;acc[getMod(index,RENDER_INFO.currentPoly)]=!c?.wall;return acc;},[]),}));return;}if(!cell.block){const aFluid=aCells.find((c)=>c?.block?.isFluid);if(aFluid&&!filledThisRound.has(aFluid.pos)){filledThisRound.add(cell.pos);cell.block=aFluid.block;cell.color=aFluid.color;}}const drawable=({point,points,isInverted,pos:cell.pos,color:cell.color,modifier:cell.modifier,isSelectedCell,});if(cell.block?.isFluid)fluids.push(drawable);drawItem(context,drawable);if(cell.block===MINE_BLOCKS.MINES_LOW){const aCellsCorner=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);showMineValue(context,aCellsCorner.reduce((acc,c)=>(c.hasBomb?acc+1:acc),0),point,isInverted,polyInfo.ySide);}};const drawCircleOnCell=(cell,baseEntity)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(cell.pos,hasInverted&&cell.isInverted,baseEntity.cell);drawCircle(contextsLayers[0],point,ySide/4);};const MAZE_CANVAS_CONFIG={defaultColor:"#cdcdcd",};const drawMaze=(context,mazeObj)=>{for(const pos of mazeObj.iterateOverMaze()){drawCellMaze(context,mazeObj,mazeObj.getMazeCell(pos));}};const drawCellMaze=(context,mazeObj,cell,color)=>{context.fillStyle=color?getFillStyle(color):MAZE_CANVAS_CONFIG.defaultColor;if(cell.circleProps)drawCellMazeCircle(context,cell,mazeObj.getCirclePoint());else drawCellMazePolygon(context,mazeObj,cell);};const drawCellMazePolygon=(context,mazeObj,cell)=>{const polyInfo=mazeObj.getMazePolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const borders=polyInfo.hasInverted&&!cell.isInverted?cell.invertedBorders:cell.borders;fillPolygon(context,cell.point,points);applyBorders(context,cell.point,points,borders);if(MENU_CONFIG.showPos&&cell.pos)showPos(context,cell.pos,cell.point,isInverted,polyInfo.ySide);};const drawCellMazeCircle=(context,cell,circlePoint)=>{const{topRadius,bottomRadius,topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,}=cell.circleProps;context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.closePath();context.fill();if(cell.borders[0]){context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.stroke();}if(cell.borders[1]){context.beginPath();context.moveTo(topRightPoint.x,topRightPoint.y);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.stroke();}if(cell.borders[2]){context.beginPath();context.moveTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.stroke();}if(cell.borders[3]){context.beginPath();context.moveTo(bottomLeftPoint.x,bottomLeftPoint.y);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.stroke();}};const resetCanvas=()=>{const polyInfo=getPolyInfo();setCanvasSize(polyInfo.canvasHeight,polyInfo.canvasWidth);setFavicon();};const updateCanvasCss=()=>{updateConfigs();updateWeather();updateWidgets();};let filledThisRound=(new Set());let tracksCount=({});const addToTrackCount=(block)=>{if(block?.trackType)tracksCount[block.trackType]=(tracksCount[block.trackType]||0)+1;};const getAjacentCells=(cell,depth=1)=>{const result=[[cell]];for(let index=0;index<depth;index++){const cells=([]);const current=result[index];for(const element of current){if(!element)continue;const aCells=element.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);cells.push(...aCells.filter((c)=>!current.includes(c)&&!cells.includes(c)&&c!==cell));}result.push(cells);}return result;};const drawEveryCell=(baseEntity)=>{wallLayers=[];fluids=[];filledThisRound=new Set();tracksCount={};const offsetCell=baseEntity.cell.pos.j%2;const{rows,columns,shouldIntercalate}=getPolyInfo();const size=rows+columns;const adjacentCells=getAjacentCells(baseEntity.cell,DRAW_CONFIG.lightDepth);const selectedCell=getSelectedCell(baseEntity);for(let i=-columns;i<size;i++){const baseI=i+RENDER_INFO.iOffset;for(let j=-rows;j<size;j++){let nI=baseI;const nJ=j+RENDER_INFO.jOffset;const pos={i:nI,j:nJ};if(shouldIntercalate&&offsetCell&&nJ%2===0)nI=nI+1;drawCell(loadAndGetCell(pos),contextsLayers[0],baseEntity,adjacentCells,selectedCell);}}drawWalls();updateEntities();tweakFluids();updateBiomeMap();updateTracks(tracksCount);};let wallLayers=([]);const drawWalls=()=>{for(let i=1;i<DRAW_CONFIG.maxLayer;i++){const walls=wallLayers[i];clearCanvas(canvasLayers[i]);if(!walls)continue;walls.forEach((w)=>drawWall(w,contextsLayers[i]));walls.forEach((w)=>drawWallTop(w,contextsLayers[i]));}wallLayers=[];};let fluidInterval=null;let fluids=([]);const tweakFluids=debounce(()=>{clearInterval(fluidInterval);if(!fluids.length)return;const context=contextsLayers[0];fluidInterval=setInterval(()=>{fluids.forEach((fluid)=>{drawItem(context,{...fluid,color:tweakColor(fluid.color),});});},DRAW_CONFIG.fluidSpeed);},DRAW_CONFIG.fluidSpeed);const drawCell=(cell,context,baseEntity,adjacentCells,selectedCell)=>{const polyInfo=getPolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const point=calculatePointBasedOnPos(cell.pos,isInverted,baseEntity.cell);if(isPointOutside(point,polyInfo.canvasHeight,polyInfo.canvasWidth))return;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const aCells=cell.adjacentPos[RENDER_INFO.currentPoly].map(getCell);const isSelectedCell=MENU_CONFIG.showSelectedCell&&cell===selectedCell;cell.modifier=getStyleModifier(adjacentCells.findIndex((c)=>c.includes(cell)));addToTrackCount(cell.wall?.block||cell.block);if(cell.wall){const wallLayer=cell.layer+1;const shouldOffset=polyInfo.hasInverted&&!cell.isInverted;if(!wallLayers[wallLayer])wallLayers[wallLayer]=[];wallLayers[wallLayer].push(blockToWall(cell.wall,point,{layer:cell.layer,isInverted,modifier:cell.modifier,isSelectedCell,pos:cell.pos,borderMap:aCells.reduce((acc,c,i)=>{let index=i-RENDER_INFO.rotationTurns;if(shouldOffset)index=RENDER_INFO.currentPoly-1-index;acc[getMod(index,RENDER_INFO.currentPoly)]=!c?.wall;return acc;},[]),}));return;}if(!cell.block){const aFluid=aCells.find((c)=>c?.block?.isFluid);if(aFluid&&!filledThisRound.has(aFluid.pos)){filledThisRound.add(cell.pos);cell.block=aFluid.block;cell.color=aFluid.color;}}const drawable=({point,points,isInverted,pos:cell.pos,color:cell.color,modifier:cell.modifier,isSelectedCell,});if(cell.block?.isFluid)fluids.push(drawable);drawItem(context,drawable);if(cell.block===MINE_BLOCKS.MINES_LOW){const aCellsCorner=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);showMineValue(context,aCellsCorner.reduce((acc,c)=>(c.hasBomb?acc+1:acc),0),point,isInverted,polyInfo.ySide);}};const drawCircleOnCell=(cell,baseEntity)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(cell.pos,hasInverted&&cell.isInverted,baseEntity.cell);drawCircle(contextsLayers[0],point,ySide/4);};const canvasLayers =([]);const contextsLayers =([]);for (let i =0;i <DRAW_CONFIG.maxLayer;i++){const canvas =document.createElement("canvas");canvasContainer.appendChild(canvas);canvasLayers.push(canvas);contextsLayers.push(canvas.getContext("2d"));}const setCanvasSize =(height,width)=>{drawContainer.style.setProperty("--canvas-height",`${height}px`);canvasLayers.forEach((canvas)=>(canvas.height =height));drawContainer.style.setProperty("--canvas-width",`${width}px`);canvasLayers.forEach((canvas)=>(canvas.width =width));};const setFavicon =()=>{const link =(document.querySelector("link[rel~='icon']"));link.href=POLYGONS_IMAGES[RENDER_INFO.currentPoly];};const updateConfigs=()=>{canvasContainer.classList[MENU_CONFIG.usePerspective?"add":"remove"]("perspective");};const clearCanvas=(canvas)=>{canvas.width=canvas.width;};const drawWall=(wall,context)=>{if(!wall.borderMap||wall.borderMap.find((b)=>!!b))drawItem(context,wall);};const drawWallTop=(wall,context)=>{drawItem(context,wall.topInfo);context.strokeStyle=wall.isSelectedCell?RENDER_CONFIG.selectedBorderColor:RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,wall.topInfo.point,wall.topInfo.points,wall.borderMap);};const drawItem=(context,{point,points,pos,isInverted,color,modifier,isSelectedCell})=>{context.fillStyle=color?getFillStyle(color,modifier):RENDER_CONFIG.emptyColor;fillPolygon(context,point,points);if(MENU_CONFIG.showPos&&pos)showPos(context,pos,point,isInverted,getPolyInfo().ySide);if(isSelectedCell){context.strokeStyle=RENDER_CONFIG.selectedBorderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}else if(MENU_CONFIG.showChunks&&pos)showChunks(context,pos,point,points);};const getFillStyle=(color,modifier=1)=>color===EMPTY_BLOCK.color?"transparent":`rgb(`+`${color.r *modifier},`+`${color.g *modifier},`+`${color.b *modifier})`;const getStyleModifier=(intensity)=>{if(!ENTITY_INFO.timeOfDay)return 1;let modifier=1-ENTITY_INFO.timeOfDay/100;if(intensity>=0)modifier=(1-modifier)/(intensity||1)+modifier;return modifier;};const fillPolygon=(context,{x,y},points)=>{context.beginPath();for(const point of points){context.lineTo(x+point.x,y+point.y);}context.closePath();context.fill();};const applyBorders=(context,{x,y},points,map,ignoreLast)=>{for(let i=0;i<points.length;i++){if(!map?.length||map[i]){const point=points[i];let nextPoint=points[i+1];if(!nextPoint){if(ignoreLast)return;nextPoint=points[0];}const pointA={x:x+point.x,y:y+point.y};const pointB={x:x+nextPoint.x,y:y+nextPoint.y};drawLine(context,pointA,pointB);}}};const drawLine=(context,pointA,pointB)=>{context.beginPath();context.moveTo(pointA.x,pointA.y);context.lineTo(pointB.x,pointB.y);context.stroke();};const showPos=(context,pos,point,isInverted,ySide)=>{context.fillStyle="black";context.font=`bold ${ySide /2}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${pos.i},${pos.j}`,point.x,isInverted?point.y+ySide/2:point.y);};const showChunks=(context,pos,point,points)=>{if(pos.i%GENERATION_CONFIG.chunkSize===0||pos.j%GENERATION_CONFIG.chunkSize===0){context.strokeStyle=RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}};const mineValueColors=["blue","green","red","darkblue","brown","darkred","black","grey",];const showMineValue=(context,value,point,isInverted,ySide)=>{if(value){context.fillStyle=mineValueColors[value-1];context.font=`bold ${ySide}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${value}`,point.x,isInverted?point.y+ySide/2:point.y);}};const drawCircle=(context,point,radius)=>{context.beginPath();context.arc(point.x,point.y,radius,0,2*Math.PI);context.fillStyle="black";context.fill();};const MAZE_CANVAS_CONFIG={defaultColor:"#cdcdcd",};const drawMaze=(context,mazeObj)=>{for(const pos of mazeObj.iterateOverMaze()){drawCellMaze(context,mazeObj,mazeObj.getMazeCell(pos));}};const drawCellMaze=(context,mazeObj,cell,color)=>{context.fillStyle=color?getFillStyle(color):MAZE_CANVAS_CONFIG.defaultColor;if(cell.circleProps)drawCellMazeCircle(context,cell,mazeObj.getCirclePoint());else drawCellMazePolygon(context,mazeObj,cell);};const drawCellMazePolygon=(context,mazeObj,cell)=>{const polyInfo=mazeObj.getMazePolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const borders=polyInfo.hasInverted&&!cell.isInverted?cell.invertedBorders:cell.borders;fillPolygon(context,cell.point,points);applyBorders(context,cell.point,points,borders);if(MENU_CONFIG.showPos&&cell.pos)showPos(context,cell.pos,cell.point,isInverted,polyInfo.ySide);};const drawCellMazeCircle=(context,cell,circlePoint)=>{const{topRadius,bottomRadius,topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,}=cell.circleProps;context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.closePath();context.fill();if(cell.borders[0]){context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.stroke();}if(cell.borders[1]){context.beginPath();context.moveTo(topRightPoint.x,topRightPoint.y);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.stroke();}if(cell.borders[2]){context.beginPath();context.moveTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.stroke();}if(cell.borders[3]){context.beginPath();context.moveTo(bottomLeftPoint.x,bottomLeftPoint.y);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.stroke();}};const audios=({});let MUSIC_VOLUME=1;const TRACK_FILES={[TRACK_TYPES.TRACK1]:"sounds/blocks/track1.wav",[TRACK_TYPES.TRACK2]:"sounds/blocks/track2.wav",[TRACK_TYPES.TRACK3]:"sounds/blocks/track3.wav",[TRACK_TYPES.TRACK4]:"sounds/blocks/track4.wav",[TRACK_TYPES.TRACK5]:"sounds/blocks/track5.wav",[TRACK_TYPES.TRACK6]:"sounds/blocks/track6.wav",[TRACK_TYPES.TRACK7]:"sounds/blocks/track7.wav",[TRACK_TYPES.TRACK8]:"sounds/blocks/track8.wav",[TRACK_TYPES.TRACK11]:"sounds/blocks/track11.wav",[TRACK_TYPES.TRACK14]:"sounds/blocks/track14.wav",[TRACK_TYPES.TRACK15]:"sounds/blocks/track15.wav",[TRACK_TYPES.TRACK16]:"sounds/blocks/track16.wav",};Object.entries(TRACK_FILES).forEach(([track,path])=>{const pan=+track.replace("TRACK","")%2?-1:1;const ctx=new AudioContext();const srcNode=ctx.createBufferSource();const gainNode=ctx.createGain();gainNode.gain.value=0;gainNode.connect(ctx.destination);const ambientPan=ctx.createStereoPanner();ambientPan.pan.value=pan;ambientPan.connect(gainNode);audios[track]={srcNode,gainNode,volume:0};fetch(path,{mode:"cors"}).then((resp)=>resp.arrayBuffer()).then((buffer)=>ctx.decodeAudioData(buffer,(abuffer)=>{srcNode.buffer=abuffer;srcNode.connect(ambientPan);srcNode.loop=true;srcNode.loopEnd=35.99;}));});const audiosList=Object.values(audios);const TRACK_LIST=Object.keys(TRACK_FILES);let audioStarted=false;const updateTracks=(tracksCount)=>{if(MENU_CONFIG.music){const polyInfo=getPolyInfo();const max=polyInfo.rows*polyInfo.columns*1.2;TRACK_LIST.forEach((track)=>{const audio=audios[track];audio.volume=(tracksCount[track]||0)/max;updateTrackVolume(audio);if(!audioStarted)audio.srcNode.start();});audioStarted=true;}else{audiosList.forEach((a)=>(a.gainNode.gain.value=0));}};const setMusicVolume=(volume)=>{MUSIC_VOLUME=volume;TRACK_LIST.forEach((track)=>updateTrackVolume(audios[track]));};const updateTrackVolume=(audio)=>{const{gainNode,volume}=audio;gainNode.gain.value=(MUSIC_VOLUME*volume)/100;};const canvasLayers =([]);const contextsLayers =([]);for (let i =0;i <DRAW_CONFIG.maxLayer;i++){const canvas =document.createElement("canvas");canvasContainer.appendChild(canvas);canvasLayers.push(canvas);contextsLayers.push(canvas.getContext("2d"));}const setCanvasSize =(height,width)=>{drawContainer.style.setProperty("--canvas-height",`${height}px`);canvasLayers.forEach((canvas)=>(canvas.height =height));drawContainer.style.setProperty("--canvas-width",`${width}px`);canvasLayers.forEach((canvas)=>(canvas.width =width));};const setFavicon =()=>{const link =(document.querySelector("link[rel~='icon']"));link.href=POLYGONS_IMAGES[RENDER_INFO.currentPoly];};const updateConfigs=()=>{canvasContainer.classList[MENU_CONFIG.usePerspective?"add":"remove"]("perspective");};const clearCanvas=(canvas)=>{canvas.width=canvas.width;};const drawWall=(wall,context)=>{if(!wall.borderMap||wall.borderMap.find((b)=>!!b))drawItem(context,wall);};const drawWallTop=(wall,context)=>{drawItem(context,wall.topInfo);context.strokeStyle=wall.isSelectedCell?RENDER_CONFIG.selectedBorderColor:RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,wall.topInfo.point,wall.topInfo.points,wall.borderMap);};const drawItem=(context,{point,points,pos,isInverted,color,modifier,isSelectedCell})=>{context.fillStyle=color?getFillStyle(color,modifier):RENDER_CONFIG.emptyColor;fillPolygon(context,point,points);if(MENU_CONFIG.showPos&&pos)showPos(context,pos,point,isInverted,getPolyInfo().ySide);if(isSelectedCell){context.strokeStyle=RENDER_CONFIG.selectedBorderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}else if(MENU_CONFIG.showChunks&&pos)showChunks(context,pos,point,points);};const getFillStyle=(color,modifier=1)=>color===EMPTY_BLOCK.color?"transparent":`rgb(`+`${color.r *modifier},`+`${color.g *modifier},`+`${color.b *modifier})`;const getStyleModifier=(intensity)=>{if(!ENTITY_INFO.timeOfDay)return 1;let modifier=1-ENTITY_INFO.timeOfDay/100;if(intensity>=0)modifier=(1-modifier)/(intensity||1)+modifier;return modifier;};const fillPolygon=(context,{x,y},points)=>{context.beginPath();for(const point of points){context.lineTo(x+point.x,y+point.y);}context.closePath();context.fill();};const applyBorders=(context,{x,y},points,map,ignoreLast)=>{for(let i=0;i<points.length;i++){if(!map?.length||map[i]){const point=points[i];let nextPoint=points[i+1];if(!nextPoint){if(ignoreLast)return;nextPoint=points[0];}const pointA={x:x+point.x,y:y+point.y};const pointB={x:x+nextPoint.x,y:y+nextPoint.y};drawLine(context,pointA,pointB);}}};const drawLine=(context,pointA,pointB)=>{context.beginPath();context.moveTo(pointA.x,pointA.y);context.lineTo(pointB.x,pointB.y);context.stroke();};const showPos=(context,pos,point,isInverted,ySide)=>{context.fillStyle="black";context.font=`bold ${ySide /2}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${pos.i},${pos.j}`,point.x,isInverted?point.y+ySide/2:point.y);};const showChunks=(context,pos,point,points)=>{if(pos.i%GENERATION_CONFIG.chunkSize===0||pos.j%GENERATION_CONFIG.chunkSize===0){context.strokeStyle=RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}};const mineValueColors=["blue","green","red","darkblue","brown","darkred","black","grey",];const showMineValue=(context,value,point,isInverted,ySide)=>{if(value){context.fillStyle=mineValueColors[value-1];context.font=`bold ${ySide}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${value}`,point.x,isInverted?point.y+ySide/2:point.y);}};const drawCircle=(context,point,radius)=>{context.beginPath();context.arc(point.x,point.y,radius,0,2*Math.PI);context.fillStyle="black";context.fill();};const audios=({});let MUSIC_VOLUME=1;const TRACK_FILES={[TRACK_TYPES.TRACK1]:"sounds/blocks/track1.wav",[TRACK_TYPES.TRACK2]:"sounds/blocks/track2.wav",[TRACK_TYPES.TRACK3]:"sounds/blocks/track3.wav",[TRACK_TYPES.TRACK4]:"sounds/blocks/track4.wav",[TRACK_TYPES.TRACK5]:"sounds/blocks/track5.wav",[TRACK_TYPES.TRACK6]:"sounds/blocks/track6.wav",[TRACK_TYPES.TRACK7]:"sounds/blocks/track7.wav",[TRACK_TYPES.TRACK8]:"sounds/blocks/track8.wav",[TRACK_TYPES.TRACK11]:"sounds/blocks/track11.wav",[TRACK_TYPES.TRACK14]:"sounds/blocks/track14.wav",[TRACK_TYPES.TRACK15]:"sounds/blocks/track15.wav",[TRACK_TYPES.TRACK16]:"sounds/blocks/track16.wav",};Object.entries(TRACK_FILES).forEach(([track,path])=>{const pan=+track.replace("TRACK","")%2?-1:1;const ctx=new AudioContext();const srcNode=ctx.createBufferSource();const gainNode=ctx.createGain();gainNode.gain.value=0;gainNode.connect(ctx.destination);const ambientPan=ctx.createStereoPanner();ambientPan.pan.value=pan;ambientPan.connect(gainNode);audios[track]={srcNode,gainNode,volume:0};fetch(path,{mode:"cors"}).then((resp)=>resp.arrayBuffer()).then((buffer)=>ctx.decodeAudioData(buffer,(abuffer)=>{srcNode.buffer=abuffer;srcNode.connect(ambientPan);srcNode.loop=true;srcNode.loopEnd=35.99;}));});const audiosList=Object.values(audios);const TRACK_LIST=Object.keys(TRACK_FILES);let audioStarted=false;const updateTracks=(tracksCount)=>{if(MENU_CONFIG.music){const polyInfo=getPolyInfo();const max=polyInfo.rows*polyInfo.columns*1.2;TRACK_LIST.forEach((track)=>{const audio=audios[track];audio.volume=(tracksCount[track]||0)/max;updateTrackVolume(audio);if(!audioStarted)audio.srcNode.start();});audioStarted=true;}else{audiosList.forEach((a)=>(a.gainNode.gain.value=0));}};const setMusicVolume=(volume)=>{MUSIC_VOLUME=volume;TRACK_LIST.forEach((track)=>updateTrackVolume(audios[track]));};const updateTrackVolume=(audio)=>{const{gainNode,volume}=audio;gainNode.gain.value=(MUSIC_VOLUME*volume)/100;};const fishingCanvas=(document.getElementById("fishing-canvas"));const fishingContext=fishingCanvas.getContext("2d");const fishingLineCanvas=(document.getElementById("fishing-line-canvas"));const fishingLineContext=fishingLineCanvas.getContext("2d");fishingLineContext.strokeStyle="black";const fishingContainer=document.getElementById("fishing-container");const fishingRodImg=(document.getElementById("fishing-rod"));const fishingRodPos=({i:8,j:0});const fishingFishImg=(document.getElementById("fishing-fish"));const fishingFishPos=({i:2,j:1});const FISHING_CONFIG={mazeSize:7,cellHeight:45,circleMazeSize:5,circleCellHeight:30,isCircleProbability:0.05,secondsToFish:20,timerDelay:100,timer:null,};let fishingMazeObj=(null);let IS_FISHING_ACTIVE=false;let FISHING_IS_CIRCLE=false;const setFishingCanvasSize=({height,width})=>{fishingLineCanvas.height=fishingCanvas.height=height;fishingLineCanvas.width=fishingCanvas.width=width;};const getFishingRodPoint=()=>FISHING_IS_CIRCLE?fishingMazeObj.getCirclePoint():fishingMazeObj.getLastMazeCell().point;const drawFishingLine=()=>{fishingLineCanvas.height=fishingLineCanvas.height;const fishPoint=fishingMazeObj.getCurrentMazeCell().point;const rodPoint=getFishingRodPoint();fishingLineContext.moveTo(fishPoint.x,fishPoint.y);fishingLineContext.lineTo(rodPoint.x,rodPoint.y);fishingLineContext.stroke();};const initFishingImages=()=>{const{ySide}=fishingMazeObj.getMazePolyInfo();setImagePos(fishingRodImg,fishingRodPos);setEntityImageSize(fishingRodImg,ySide);setImagePoint(fishingRodImg,getFishingRodPoint(),true,ySide);setImagePos(fishingFishImg,fishingFishPos);setEntityImageSize(fishingFishImg,ySide);setImagePoint(fishingFishImg,fishingMazeObj.getCurrentMazeCell().point,true,ySide);drawFishingLine();};const stopFishing=()=>{clearInterval(FISHING_CONFIG.timer);fishingContainer.classList.add("hide");IS_FISHING_ACTIVE=false;};const initFishingMazeObj=()=>{if(!fishingMazeObj)fishingMazeObj=createMazeObj({cellHeight:FISHING_CONFIG.cellHeight,rows:FISHING_CONFIG.mazeSize,columns:FISHING_CONFIG.mazeSize,},{cellHeight:FISHING_CONFIG.circleCellHeight,rows:FISHING_CONFIG.circleMazeSize,columns:FISHING_CONFIG.circleMazeSize,});fishingMazeObj.setIsCircle(FISHING_IS_CIRCLE);fishingMazeObj.buildMaze();};const initFishingTimer=(height)=>{fishingContainer.style.setProperty("--fishing-progress-bar-init-height",`${height}px`);fishingContainer.style.setProperty("--fishing-progress-bar-height",`${height}px`);let currentHeight=height;const timerSteps=height/((FISHING_CONFIG.secondsToFish*1000)/FISHING_CONFIG.timerDelay);FISHING_CONFIG.timer=setInterval(()=>{currentHeight-=timerSteps;fishingContainer.style.setProperty("--fishing-progress-bar-height",`${currentHeight}px`);if(currentHeight<=0){stopFishing();hurtEntity(PLAYER_ENTITY,1);}},FISHING_CONFIG.timerDelay);};let fishingFluidInterval=null;const initFishingDraw=(mazeObj)=>{clearInterval(fishingFluidInterval);const cells=([]);for(const pos of mazeObj.iterateOverMaze()){const cell=mazeObj.getMazeCell(pos);cells.push(cell);drawCellMaze(fishingContext,mazeObj,cell,tweakColor(BLOCKS.WATER.color));}if(!cells.length)return;fishingFluidInterval=setInterval(()=>{cells.forEach((c)=>drawCellMaze(fishingContext,mazeObj,c,tweakColor(BLOCKS.WATER.color)));},DRAW_CONFIG.fluidSpeed);};const startFishing=()=>{if(IS_FISHING_ACTIVE)return stopFishing();IS_FISHING_ACTIVE=true;FISHING_IS_CIRCLE=Math.random()<FISHING_CONFIG.isCircleProbability;initFishingMazeObj();const size=fishingMazeObj.getMazeSize();size.height+=FISHING_CONFIG.cellHeight/9;setFishingCanvasSize(size);initFishingImages();fishingContainer.classList.remove("hide");initFishingTimer(size.height);initFishingDraw(fishingMazeObj);};let canMoveFishing=true;const moveFishing=(code,useDiagonal)=>{if(canMoveFishing){const{ySide,hasInverted,polySides}=fishingMazeObj.getMazePolyInfo();const currentCell=fishingMazeObj.getCurrentMazeCell();const aIndex=getMovementMap(currentCell,useDiagonal,0,polySides,!FISHING_IS_CIRCLE&&hasInverted)[code];const nextCell=fishingMazeObj.mazeMove(aIndex);if(!nextCell)return;if(fishingMazeObj.isMazeSolved()){stopFishing();giveItemToEntity(PLAYER_ENTITY,{imgPos:fishingFishPos,health:1});return;}setImagePoint(fishingFishImg,nextCell.point,true,ySide);drawFishingLine();canMoveFishing=false;setTimeout(()=>{canMoveFishing=true;},100);}};const MAP_CONFIG={currentPosRatio:5,posRatio:5,fullScreenPosRatio:50,playerColor:({r:212,g:172,b:156,}),xRatio:0,yRatio:0,};const mapCanvas=(document.getElementById("map-canvas"));const mapContext=mapCanvas.getContext("2d");const resetBiomeMap=()=>{let size=0;if(fullMap){size=Math.min(window.innerWidth,window.innerHeight)*0.96;MAP_CONFIG.currentPosRatio=MAP_CONFIG.fullScreenPosRatio;}else{size=mapCanvas.parentElement.offsetWidth;MAP_CONFIG.currentPosRatio=MAP_CONFIG.posRatio;}mapCanvas.width=size;mapCanvas.height=size;MAP_CONFIG.xRatio=mapCanvas.width/(MAP_CONFIG.currentPosRatio*2+1);MAP_CONFIG.yRatio=mapCanvas.height/(MAP_CONFIG.currentPosRatio*2+1);};const updateBiomeMap=()=>{clearCanvas(mapCanvas);const biomes=getBiomeMap();const iOffset=Math.round(RENDER_INFO.iOffset/GENERATION_CONFIG.chunkSize);const jOffset=Math.round(RENDER_INFO.jOffset/GENERATION_CONFIG.chunkSize);const iNegLimit=iOffset-MAP_CONFIG.currentPosRatio;const iPosLimit=iOffset+MAP_CONFIG.currentPosRatio+1;const jNegLimit=jOffset-MAP_CONFIG.currentPosRatio;const jPosLimit=jOffset+MAP_CONFIG.currentPosRatio+1;for(let i=iNegLimit;i<=iPosLimit;i++){const nI=i-iOffset;for(let j=jNegLimit;j<=jPosLimit;j++){const nJ=j-jOffset;const biome=biomes[i]?.[j];if(!biome)continue;createRect({i:nI,j:nJ},biome.mapColor);}}createRect({i:0,j:0},MAP_CONFIG.playerColor);};let fullMap=false;const toggleFullMap=(toggle=!fullMap)=>{fullMap=toggle;if(toggle){mapCanvas.classList.add("full-screen");resetBiomeMap();updateBiomeMap();}else{mapCanvas.classList.remove("full-screen");resetBiomeMap();updateBiomeMap();}};const createRect=(pos,color)=>{mapContext.fillStyle=getFillStyle(color);mapContext.fillRect((MAP_CONFIG.currentPosRatio+pos.j)*MAP_CONFIG.xRatio,(MAP_CONFIG.currentPosRatio+pos.i)*MAP_CONFIG.yRatio,MAP_CONFIG.xRatio,MAP_CONFIG.yRatio);};const fishingCanvas=(document.getElementById("fishing-canvas"));const fishingContext=fishingCanvas.getContext("2d");const fishingLineCanvas=(document.getElementById("fishing-line-canvas"));const fishingLineContext=fishingLineCanvas.getContext("2d");fishingLineContext.strokeStyle="black";const fishingContainer=document.getElementById("fishing-container");const fishingRodImg=(document.getElementById("fishing-rod"));const fishingRodPos=({i:8,j:0});const fishingFishImg=(document.getElementById("fishing-fish"));const fishingFishPos=({i:2,j:1});const FISHING_CONFIG={mazeSize:7,cellHeight:45,circleMazeSize:5,circleCellHeight:30,isCircleProbability:0.05,secondsToFish:20,timerDelay:100,timer:null,};let fishingMazeObj=(null);let IS_FISHING_ACTIVE=false;let FISHING_IS_CIRCLE=false;const setFishingCanvasSize=({height,width})=>{fishingLineCanvas.height=fishingCanvas.height=height;fishingLineCanvas.width=fishingCanvas.width=width;};const getFishingRodPoint=()=>FISHING_IS_CIRCLE?fishingMazeObj.getCirclePoint():fishingMazeObj.getLastMazeCell().point;const drawFishingLine=()=>{fishingLineCanvas.height=fishingLineCanvas.height;const fishPoint=fishingMazeObj.getCurrentMazeCell().point;const rodPoint=getFishingRodPoint();fishingLineContext.moveTo(fishPoint.x,fishPoint.y);fishingLineContext.lineTo(rodPoint.x,rodPoint.y);fishingLineContext.stroke();};const initFishingImages=()=>{const{ySide}=fishingMazeObj.getMazePolyInfo();setImagePos(fishingRodImg,fishingRodPos);setEntityImageSize(fishingRodImg,ySide);setImagePoint(fishingRodImg,getFishingRodPoint(),true,ySide);setImagePos(fishingFishImg,fishingFishPos);setEntityImageSize(fishingFishImg,ySide);setImagePoint(fishingFishImg,fishingMazeObj.getCurrentMazeCell().point,true,ySide);drawFishingLine();};const stopFishing=()=>{clearInterval(FISHING_CONFIG.timer);fishingContainer.classList.add("hide");IS_FISHING_ACTIVE=false;};const initFishingMazeObj=()=>{if(!fishingMazeObj)fishingMazeObj=createMazeObj({cellHeight:FISHING_CONFIG.cellHeight,rows:FISHING_CONFIG.mazeSize,columns:FISHING_CONFIG.mazeSize,},{cellHeight:FISHING_CONFIG.circleCellHeight,rows:FISHING_CONFIG.circleMazeSize,columns:FISHING_CONFIG.circleMazeSize,});fishingMazeObj.setIsCircle(FISHING_IS_CIRCLE);fishingMazeObj.buildMaze();};const initFishingTimer=(height)=>{fishingContainer.style.setProperty("--fishing-progress-bar-init-height",`${height}px`);fishingContainer.style.setProperty("--fishing-progress-bar-height",`${height}px`);let currentHeight=height;const timerSteps=height/((FISHING_CONFIG.secondsToFish*1000)/FISHING_CONFIG.timerDelay);FISHING_CONFIG.timer=setInterval(()=>{currentHeight-=timerSteps;fishingContainer.style.setProperty("--fishing-progress-bar-height",`${currentHeight}px`);if(currentHeight<=0){stopFishing();hurtEntity(PLAYER_ENTITY,1);}},FISHING_CONFIG.timerDelay);};let fishingFluidInterval=null;const initFishingDraw=(mazeObj)=>{clearInterval(fishingFluidInterval);const cells=([]);for(const pos of mazeObj.iterateOverMaze()){const cell=mazeObj.getMazeCell(pos);cells.push(cell);drawCellMaze(fishingContext,mazeObj,cell,tweakColor(BLOCKS.WATER.color));}if(!cells.length)return;fishingFluidInterval=setInterval(()=>{cells.forEach((c)=>drawCellMaze(fishingContext,mazeObj,c,tweakColor(BLOCKS.WATER.color)));},DRAW_CONFIG.fluidSpeed);};const startFishing=()=>{if(IS_FISHING_ACTIVE)return stopFishing();IS_FISHING_ACTIVE=true;FISHING_IS_CIRCLE=Math.random()<FISHING_CONFIG.isCircleProbability;initFishingMazeObj();const size=fishingMazeObj.getMazeSize();size.height+=FISHING_CONFIG.cellHeight/9;setFishingCanvasSize(size);initFishingImages();fishingContainer.classList.remove("hide");initFishingTimer(size.height);initFishingDraw(fishingMazeObj);};let canMoveFishing=true;const moveFishing=(code,useDiagonal)=>{if(canMoveFishing){const{ySide,hasInverted,polySides}=fishingMazeObj.getMazePolyInfo();const currentCell=fishingMazeObj.getCurrentMazeCell();const aIndex=getMovementMap(currentCell,useDiagonal,0,polySides,!FISHING_IS_CIRCLE&&hasInverted)[code];const nextCell=fishingMazeObj.mazeMove(aIndex);if(!nextCell)return;if(fishingMazeObj.isMazeSolved()){stopFishing();giveItemToEntity(PLAYER_ENTITY,{imgPos:fishingFishPos,health:1});return;}setImagePoint(fishingFishImg,nextCell.point,true,ySide);drawFishingLine();canMoveFishing=false;setTimeout(()=>{canMoveFishing=true;},100);}};const areColorsEqual=(color1,color2)=>color1.r===color2.r&&color1.g===color2.g&&color1.b===color2.b;const PLACE_CONFIG={cellHeight:24,canvasNum:7,};const BLOCKS_LISTS=Object.values(BLOCKS).filter((b)=>!b.isFluid).filter((b,i,a)=>!a.find((b2,i2)=>areColorsEqual(b.color,b2.color)&&i<i2));PLACE_CONFIG.steps=360/PLACE_CONFIG.canvasNum;let PLACE_POLYS_INFO=(null);const placeContainer=document.getElementById("place-canvas-container");const placeCanvas=([]);const placeContexts=([]);for(let i=0;i<PLACE_CONFIG.canvasNum;i++){const canvas=document.createElement("canvas");canvas.style.setProperty("--place-rotate-canvas",`${PLACE_CONFIG.steps *i}deg`);placeContainer.appendChild(canvas);placeCanvas.push(canvas);placeContexts.push(canvas.getContext("2d"));}placeContainer.ontouchend=()=>{};const getSelectedBlockToPlace=()=>{const block=BLOCKS_LISTS[getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length)];return{block,color:block.color};};const resetPlace=()=>{placeCanvas.forEach((p)=>{p.width=placeContainer.parentElement.offsetWidth;p.height=placeContainer.parentElement.offsetHeight;});showSelectedPlaceBlocks();};const drawPlaceBlock=(context,block)=>{if(!PLACE_POLYS_INFO){PLACE_POLYS_INFO={};for(const p of KNOWN_POLYGONS_VALUES){PLACE_POLYS_INFO[p]=configPoly(p,PLACE_CONFIG.cellHeight);}}const polyInfo=PLACE_POLYS_INFO[RENDER_INFO.currentPoly];const wall=blockToWall({block,color:block.color},{x:placeContainer.parentElement.offsetWidth/2,y:placeContainer.parentElement.offsetHeight/1.75,},{isInverted:polyInfo.hasInverted},polyInfo);drawWall(wall,context);applyBorders(context,wall.point,wall.points,[],true);drawWallTop(wall,context);};let SELECTED_PLACE_BLOCKS=0;let PLACE_BLOCKS_DEG=0;const movePlaceBlocks=(orientation)=>{SELECTED_PLACE_BLOCKS=SELECTED_PLACE_BLOCKS+orientation;PLACE_BLOCKS_DEG+=orientation>0?PLACE_CONFIG.steps:-PLACE_CONFIG.steps;placeContainer.style.setProperty("--place-rotate-container",`${-PLACE_BLOCKS_DEG}deg`);showSelectedPlaceBlocks();};const showSelectedPlaceBlocks=()=>{const showIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS+1,PLACE_CONFIG.canvasNum),];const drawIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS+1,BLOCKS_LISTS.length),];placeCanvas.forEach((p,i)=>{p.classList[showIndexes.includes(i)?"add":"remove"]("active");});showIndexes.forEach((index,i)=>{clearCanvas(placeCanvas[index]);drawPlaceBlock(placeContexts[index],BLOCKS_LISTS[drawIndexes[i]]);});};const resetToolbar=()=>{resetBiomeMap();resetPlace();};const MAP_CONFIG={currentPosRatio:5,posRatio:5,fullScreenPosRatio:50,playerColor:({r:212,g:172,b:156,}),xRatio:0,yRatio:0,};const mapCanvas=(document.getElementById("map-canvas"));const mapContext=mapCanvas.getContext("2d");const resetBiomeMap=()=>{let size=0;if(fullMap){size=Math.min(window.innerWidth,window.innerHeight)*0.96;MAP_CONFIG.currentPosRatio=MAP_CONFIG.fullScreenPosRatio;}else{size=mapCanvas.parentElement.offsetWidth;MAP_CONFIG.currentPosRatio=MAP_CONFIG.posRatio;}mapCanvas.width=size;mapCanvas.height=size;MAP_CONFIG.xRatio=mapCanvas.width/(MAP_CONFIG.currentPosRatio*2+1);MAP_CONFIG.yRatio=mapCanvas.height/(MAP_CONFIG.currentPosRatio*2+1);};const updateBiomeMap=()=>{clearCanvas(mapCanvas);const biomes=getBiomeMap();const iOffset=Math.round(RENDER_INFO.iOffset/GENERATION_CONFIG.chunkSize);const jOffset=Math.round(RENDER_INFO.jOffset/GENERATION_CONFIG.chunkSize);const iNegLimit=iOffset-MAP_CONFIG.currentPosRatio;const iPosLimit=iOffset+MAP_CONFIG.currentPosRatio+1;const jNegLimit=jOffset-MAP_CONFIG.currentPosRatio;const jPosLimit=jOffset+MAP_CONFIG.currentPosRatio+1;for(let i=iNegLimit;i<=iPosLimit;i++){const nI=i-iOffset;for(let j=jNegLimit;j<=jPosLimit;j++){const nJ=j-jOffset;const biome=biomes[i]?.[j];if(!biome)continue;createRect({i:nI,j:nJ},biome.mapColor);}}createRect({i:0,j:0},MAP_CONFIG.playerColor);};let fullMap=false;const toggleFullMap=(toggle=!fullMap)=>{fullMap=toggle;if(toggle){mapCanvas.classList.add("full-screen");resetBiomeMap();updateBiomeMap();}else{mapCanvas.classList.remove("full-screen");resetBiomeMap();updateBiomeMap();}};const createRect=(pos,color)=>{mapContext.fillStyle=getFillStyle(color);mapContext.fillRect((MAP_CONFIG.currentPosRatio+pos.j)*MAP_CONFIG.xRatio,(MAP_CONFIG.currentPosRatio+pos.i)*MAP_CONFIG.yRatio,MAP_CONFIG.xRatio,MAP_CONFIG.yRatio);};const CLOUDS_CONFIG={num:4,rows:3,columns:3,durationMult:30,offsetSize:6,offset:0,};const CLOUDS_DIRECTION_MAP={[MOVEMENT.RIGHT]:-CLOUDS_CONFIG.offsetSize,[MOVEMENT.LEFT]:CLOUDS_CONFIG.offsetSize,};const cloudsContainer=document.getElementById("clouds-container");let clouds=([]);const updateClouds=(direction)=>{if(MENU_CONFIG.clouds){if(!clouds.length){createClouds();offsetClouds(MOVEMENT.RIGHT);}setCloudShape();offsetClouds(direction);}else{cloudsContainer.classList.add("off");}};const setCloudShape=()=>{const{currentPoly,cellHeight}=RENDER_INFO;const size=Math.min(cellHeight*4,cloudsContainer.offsetWidth/(CLOUDS_CONFIG.num*CLOUDS_CONFIG.columns*1.5));cloudsContainer.className=`p${currentPoly}`;cloudsContainer.style.setProperty("--clouds-default-size",`${size}px`);};const offsetClouds=(direction)=>{const offsetSize=CLOUDS_DIRECTION_MAP[direction];if(!offsetSize)return;CLOUDS_CONFIG.offset+=offsetSize;const offsetLeft=getMod(CLOUDS_CONFIG.offset,cloudsContainer.offsetWidth);const width=cloudsContainer.offsetWidth/CLOUDS_CONFIG.num;const defaultOffsetLeft=cloudsContainer.offsetWidth/4;cloudsContainer.style.setProperty("--clouds-offset-left",`${getMod(CLOUDS_CONFIG.offset,width)-defaultOffsetLeft}px`);const offset=Math.floor(offsetLeft/width);for(let index=0;index<clouds.length;index++){clouds[index].style.setProperty("--clouds-order",`${getMod(index +offset,CLOUDS_CONFIG.num)+1}`);}};const createClouds=()=>{const min=1-CLOUDS_CONFIG.num/10;const max=Math.min(min+0.5,1);for(let i=0;i<CLOUDS_CONFIG.num;i++){const cloud=document.createElement("div");cloud.className="cloud";const scale=correctRoundError(getRandomFloat(min,max),2);const duration=Math.round(scale*CLOUDS_CONFIG.durationMult);cloud.style.setProperty("--clouds-scale",`${scale}`);cloud.style.setProperty("--clouds-animation-duration",`${duration}s`);cloudsContainer.appendChild(cloud);clouds.push(cloud);for(let j=0;j<CLOUDS_CONFIG.rows;j++){const cloudRow=document.createElement("div");cloudRow.className="cloud-row";cloud.appendChild(cloudRow);for(let z=0;z<CLOUDS_CONFIG.columns;z++){const cloudShape=document.createElement("div");cloudShape.className="cloud-shape";cloudRow.appendChild(cloudShape);}}}};const areColorsEqual=(color1,color2)=>color1.r===color2.r&&color1.g===color2.g&&color1.b===color2.b;const PLACE_CONFIG={cellHeight:24,canvasNum:7,};const BLOCKS_LISTS=Object.values(BLOCKS).filter((b)=>!b.isFluid).filter((b,i,a)=>!a.find((b2,i2)=>areColorsEqual(b.color,b2.color)&&i<i2));PLACE_CONFIG.steps=360/PLACE_CONFIG.canvasNum;let PLACE_POLYS_INFO=(null);const placeContainer=document.getElementById("place-canvas-container");const placeCanvas=([]);const placeContexts=([]);for(let i=0;i<PLACE_CONFIG.canvasNum;i++){const canvas=document.createElement("canvas");canvas.style.setProperty("--place-rotate-canvas",`${PLACE_CONFIG.steps *i}deg`);placeContainer.appendChild(canvas);placeCanvas.push(canvas);placeContexts.push(canvas.getContext("2d"));}placeContainer.ontouchend=()=>{};const getSelectedBlockToPlace=()=>{const block=BLOCKS_LISTS[getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length)];return{block,color:block.color};};const resetPlace=()=>{placeCanvas.forEach((p)=>{p.width=placeContainer.parentElement.offsetWidth;p.height=placeContainer.parentElement.offsetHeight;});showSelectedPlaceBlocks();};const drawPlaceBlock=(context,block)=>{if(!PLACE_POLYS_INFO){PLACE_POLYS_INFO={};for(const p of KNOWN_POLYGONS_VALUES){PLACE_POLYS_INFO[p]=configPoly(p,PLACE_CONFIG.cellHeight);}}const polyInfo=PLACE_POLYS_INFO[RENDER_INFO.currentPoly];const wall=blockToWall({block,color:block.color},{x:placeContainer.parentElement.offsetWidth/2,y:placeContainer.parentElement.offsetHeight/1.75,},{isInverted:polyInfo.hasInverted},polyInfo);drawWall(wall,context);applyBorders(context,wall.point,wall.points,[],true);drawWallTop(wall,context);};let SELECTED_PLACE_BLOCKS=0;let PLACE_BLOCKS_DEG=0;const movePlaceBlocks=(orientation)=>{SELECTED_PLACE_BLOCKS=SELECTED_PLACE_BLOCKS+orientation;PLACE_BLOCKS_DEG+=orientation>0?PLACE_CONFIG.steps:-PLACE_CONFIG.steps;placeContainer.style.setProperty("--place-rotate-container",`${-PLACE_BLOCKS_DEG}deg`);showSelectedPlaceBlocks();};const showSelectedPlaceBlocks=()=>{const showIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS+1,PLACE_CONFIG.canvasNum),];const drawIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS+1,BLOCKS_LISTS.length),];placeCanvas.forEach((p,i)=>{p.classList[showIndexes.includes(i)?"add":"remove"]("active");});showIndexes.forEach((index,i)=>{clearCanvas(placeCanvas[index]);drawPlaceBlock(placeContexts[index],BLOCKS_LISTS[drawIndexes[i]]);});};const resetToolbar=()=>{resetBiomeMap();resetPlace();};const rainContainer =document.getElementById("rain-container");const BIOME_RAIN_MAP ={DEFAULT:"../images/weather/rain.gif",[BIOME_TYPES.SNOW]:"../images/weather/snow.gif",};const rainAudio =new Audio("sounds/weather/rain.mp3");rainAudio.volume =0.25;rainAudio.loop =true;const lightningAudio =new Audio("sounds/weather/lightning.mp3");lightningAudio.volume =0.25;let isRainOn =false;const updateRain =()=>{if (MENU_CONFIG.rain){if (!isRainOn){clearLightning();isRainOn =true;rainAudio.play();rainContainer.classList.remove("hide");const size =RENDER_INFO.cellHeight *10;rainContainer.style.setProperty("--rain-size",`${size}px`);createLightining();}updateRainImg();}else {if (isRainOn){clearLightning();isRainOn =false;rainAudio.pause();rainContainer.classList.add("hide");}}};let lightningInterval =null;const createLightining =()=>{clearTimeout(lightningInterval);const secs =getRandomFloat(10000,30000);lightningInterval =setTimeout(()=>{rainContainer.classList.remove("lightning");rainContainer.offsetHeight;rainContainer.classList.add("lightning");lightningAudio.play();createLightining();},secs);};const clearLightning =()=>{clearTimeout(lightningInterval);rainContainer.classList.remove("lightning");};const updateRainImg =()=>{const gif =`url("${BIOME_RAIN_MAP[PLAYER_ENTITY.cell.block.biomeType]||BIOME_RAIN_MAP.DEFAULT }")`;const currentGif=rainContainer.style.getPropertyValue("--rain-img");if(gif!==currentGif)rainContainer.style.setProperty("--rain-img",gif);};const updateWeather=(direction)=>{updateRain();updateClouds(direction);};const CLOUDS_CONFIG={num:4,rows:3,columns:3,durationMult:30,offsetSize:6,offset:0,};const CLOUDS_DIRECTION_MAP={[MOVEMENT.RIGHT]:-CLOUDS_CONFIG.offsetSize,[MOVEMENT.LEFT]:CLOUDS_CONFIG.offsetSize,};const cloudsContainer=document.getElementById("clouds-container");let clouds=([]);const updateClouds=(direction)=>{if(MENU_CONFIG.clouds){if(!clouds.length){createClouds();offsetClouds(MOVEMENT.RIGHT);}setCloudShape();offsetClouds(direction);}else{cloudsContainer.classList.add("off");}};const setCloudShape=()=>{const{currentPoly,cellHeight}=RENDER_INFO;const size=Math.min(cellHeight*4,cloudsContainer.offsetWidth/(CLOUDS_CONFIG.num*CLOUDS_CONFIG.columns*1.5));cloudsContainer.className=`p${currentPoly}`;cloudsContainer.style.setProperty("--clouds-default-size",`${size}px`);};const offsetClouds=(direction)=>{const offsetSize=CLOUDS_DIRECTION_MAP[direction];if(!offsetSize)return;CLOUDS_CONFIG.offset+=offsetSize;const offsetLeft=getMod(CLOUDS_CONFIG.offset,cloudsContainer.offsetWidth);const width=cloudsContainer.offsetWidth/CLOUDS_CONFIG.num;const defaultOffsetLeft=cloudsContainer.offsetWidth/4;cloudsContainer.style.setProperty("--clouds-offset-left",`${getMod(CLOUDS_CONFIG.offset,width)-defaultOffsetLeft}px`);const offset=Math.floor(offsetLeft/width);for(let index=0;index<clouds.length;index++){clouds[index].style.setProperty("--clouds-order",`${getMod(index +offset,CLOUDS_CONFIG.num)+1}`);}};const createClouds=()=>{const min=1-CLOUDS_CONFIG.num/10;const max=Math.min(min+0.5,1);for(let i=0;i<CLOUDS_CONFIG.num;i++){const cloud=document.createElement("div");cloud.className="cloud";const scale=correctRoundError(getRandomFloat(min,max),2);const duration=Math.round(scale*CLOUDS_CONFIG.durationMult);cloud.style.setProperty("--clouds-scale",`${scale}`);cloud.style.setProperty("--clouds-animation-duration",`${duration}s`);cloudsContainer.appendChild(cloud);clouds.push(cloud);for(let j=0;j<CLOUDS_CONFIG.rows;j++){const cloudRow=document.createElement("div");cloudRow.className="cloud-row";cloud.appendChild(cloudRow);for(let z=0;z<CLOUDS_CONFIG.columns;z++){const cloudShape=document.createElement("div");cloudShape.className="cloud-shape";cloudRow.appendChild(cloudShape);}}}};const CLOCK_CONFIG={passHour:0.25,midNightHour:60,};const analogClock=document.getElementById("analog-clock");const digitalClock=document.getElementById("digital-clock");const hourTensSegments=document.querySelectorAll("#digital-clock-hours .digit-tens .segment");const hourUnitsSegments=document.querySelectorAll("#digital-clock-hours .digit-units .segment");const minuteTensSegments=document.querySelectorAll("#digital-clock-minutes .digit-tens .segment");const minuteUnitsSegments=document.querySelectorAll("#digital-clock-minutes .digit-units .segment");const updateClock=()=>{const{hour,hour24,minute}=getTime();if(MENU_CONFIG.digitalClock){digitalClock.classList.remove("hide");analogClock.classList.add("hide");setNumber(hourTensSegments,Math.floor(hour24/10));setNumber(hourUnitsSegments,Math.floor(hour24%10));setNumber(minuteTensSegments,Math.floor(minute/10));setNumber(minuteUnitsSegments,Math.floor(minute%10));}else{analogClock.classList.remove("hide");digitalClock.classList.add("hide");analogClock.style.setProperty("--clock-hour-rotate",`${hour *30 +minute *0.5}deg`);analogClock.style.setProperty("--clock-minute-rotate",`${minute *6}deg`);}};const passTime=()=>{ENTITY_INFO.timeOfDay+=CLOCK_CONFIG.passHour;if(ENTITY_INFO.timeOfDay>=CLOCK_CONFIG.midNightHour||ENTITY_INFO.timeOfDay<=0){CLOCK_CONFIG.passHour=-CLOCK_CONFIG.passHour;}updateClock();};const getTime=()=>{const hourRaw=(12*ENTITY_INFO.timeOfDay)/CLOCK_CONFIG.midNightHour;let hour=Math.floor(hourRaw);let minute=Math.round((hourRaw-hour)*100);minute=Math.floor(minute*0.6);minute=CLOCK_CONFIG.passHour>0?minute:60-minute;minute=getMod(minute,60);if(CLOCK_CONFIG.passHour<0)hour=Math.max((minute?11:12)-hour,0);const hour24=CLOCK_CONFIG.passHour>0?hour+12:hour;return{hour,hour24,minute};};const setNumber=(segments,value)=>{segments.forEach((el)=>{el.classList[el.classList.contains(`n${value}`)?"add":"remove"]("active");});};const rainContainer =document.getElementById("rain-container");const BIOME_RAIN_MAP ={DEFAULT:"../images/weather/rain.gif",[BIOME_TYPES.SNOW]:"../images/weather/snow.gif",};const rainAudio =new Audio("sounds/weather/rain.mp3");rainAudio.volume =0.25;rainAudio.loop =true;const lightningAudio =new Audio("sounds/weather/lightning.mp3");lightningAudio.volume =0.25;let isRainOn =false;const updateRain =()=>{if (MENU_CONFIG.rain){if (!isRainOn){clearLightning();isRainOn =true;rainAudio.play();rainContainer.classList.remove("hide");const size =RENDER_INFO.cellHeight *10;rainContainer.style.setProperty("--rain-size",`${size}px`);createLightining();}updateRainImg();}else {if (isRainOn){clearLightning();isRainOn =false;rainAudio.pause();rainContainer.classList.add("hide");}}};let lightningInterval =null;const createLightining =()=>{clearTimeout(lightningInterval);const secs =getRandomFloat(10000,30000);lightningInterval =setTimeout(()=>{rainContainer.classList.remove("lightning");rainContainer.offsetHeight;rainContainer.classList.add("lightning");lightningAudio.play();createLightining();},secs);};const clearLightning =()=>{clearTimeout(lightningInterval);rainContainer.classList.remove("lightning");};const updateRainImg =()=>{const gif =`url("${BIOME_RAIN_MAP[PLAYER_ENTITY.cell.block.biomeType]||BIOME_RAIN_MAP.DEFAULT }")`;const currentGif=rainContainer.style.getPropertyValue("--rain-img");if(gif!==currentGif)rainContainer.style.setProperty("--rain-img",gif);};const compass=document.getElementById("compass");const COMPASS_CONFIG={rotateDelay:750,};const updateCompass=()=>{const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;compass.style.setProperty("--compass-rotate",`${-angle}deg`);};const entitiesContainer=document.getElementById("entities");const rotateCanvas=(deg,rotateDelay)=>{rotateElement(entitiesContainer,-deg,rotateDelay);rotateElement(drawContainer,deg,rotateDelay);};const resetRotateCanvas=()=>{rotateElement(entitiesContainer);rotateElement(drawContainer);};const rotateElement=(element,deg,rotateDelay)=>{if(rotateDelay)element.style.setProperty("--transition-duration",`${rotateDelay}ms`);if(deg)element.style.setProperty("--rotate-deg",`${deg}deg`);element.classList[deg?"add":"remove"]("rotate");element.classList[deg?"add":"remove"]("zoom-in");};const updateWeather=(direction)=>{updateRain();updateClouds(direction);};const updateWidgets=()=>{updateClock();updateCompass();};const CLOCK_CONFIG={passHour:0.25,midNightHour:60,};const analogClock=document.getElementById("analog-clock");const digitalClock=document.getElementById("digital-clock");const hourTensSegments=document.querySelectorAll("#digital-clock-hours .digit-tens .segment");const hourUnitsSegments=document.querySelectorAll("#digital-clock-hours .digit-units .segment");const minuteTensSegments=document.querySelectorAll("#digital-clock-minutes .digit-tens .segment");const minuteUnitsSegments=document.querySelectorAll("#digital-clock-minutes .digit-units .segment");const updateClock=()=>{const{hour,hour24,minute}=getTime();if(MENU_CONFIG.digitalClock){digitalClock.classList.remove("hide");analogClock.classList.add("hide");setNumber(hourTensSegments,Math.floor(hour24/10));setNumber(hourUnitsSegments,Math.floor(hour24%10));setNumber(minuteTensSegments,Math.floor(minute/10));setNumber(minuteUnitsSegments,Math.floor(minute%10));}else{analogClock.classList.remove("hide");digitalClock.classList.add("hide");analogClock.style.setProperty("--clock-hour-rotate",`${hour *30 +minute *0.5}deg`);analogClock.style.setProperty("--clock-minute-rotate",`${minute *6}deg`);}};const passTime=()=>{ENTITY_INFO.timeOfDay+=CLOCK_CONFIG.passHour;if(ENTITY_INFO.timeOfDay>=CLOCK_CONFIG.midNightHour||ENTITY_INFO.timeOfDay<=0){CLOCK_CONFIG.passHour=-CLOCK_CONFIG.passHour;}updateClock();};const getTime=()=>{const hourRaw=(12*ENTITY_INFO.timeOfDay)/CLOCK_CONFIG.midNightHour;let hour=Math.floor(hourRaw);let minute=Math.round((hourRaw-hour)*100);minute=Math.floor(minute*0.6);minute=CLOCK_CONFIG.passHour>0?minute:60-minute;minute=getMod(minute,60);if(CLOCK_CONFIG.passHour<0)hour=Math.max((minute?11:12)-hour,0);const hour24=CLOCK_CONFIG.passHour>0?hour+12:hour;return{hour,hour24,minute};};const setNumber=(segments,value)=>{segments.forEach((el)=>{el.classList[el.classList.contains(`n${value}`)?"add":"remove"]("active");});};const compass=document.getElementById("compass");const COMPASS_CONFIG={rotateDelay:750,};const updateCompass=()=>{const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;compass.style.setProperty("--compass-rotate",`${-angle}deg`);};const entitiesContainer=document.getElementById("entities");const rotateCanvas=(deg,rotateDelay)=>{rotateElement(entitiesContainer,-deg,rotateDelay);rotateElement(drawContainer,deg,rotateDelay);};const resetRotateCanvas=()=>{rotateElement(entitiesContainer);rotateElement(drawContainer);};const rotateElement=(element,deg,rotateDelay)=>{if(rotateDelay)element.style.setProperty("--transition-duration",`${rotateDelay}ms`);if(deg)element.style.setProperty("--rotate-deg",`${deg}deg`);element.classList[deg?"add":"remove"]("rotate");element.classList[deg?"add":"remove"]("zoom-in");};const updateWidgets=()=>{updateClock();updateCompass();};const digAudio=new Audio("sounds/actions/dig.mp3");digAudio.volume=0.25;const punchAudio=new Audio("sounds/actions/punch.mp3");punchAudio.volume=0.25;const gunShotAudio=new Audio("sounds/actions/gun-shot.mp3");gunShotAudio.volume=1;const rotateAudio=new Audio("sounds/actions/rotate.mp3");rotateAudio.volume=0.25;let canRotate=true;const canDoActions=()=>PLAYER_ENTITY.health>0;const rotate=(orientation)=>{if(canRotate){canRotate=false;RENDER_INFO.rotationTurns=PLAYER_ENTITY.selectedCellIndex=getMod(RENDER_INFO.rotationTurns+orientation,RENDER_INFO.currentPoly);if(MENU_CONFIG.rotationAnimation){rotateCanvas((360/RENDER_INFO.currentPoly)*-orientation,COMPASS_CONFIG.rotateDelay);rotateAudio.play();}updateCompass();resetDirection();setTimeout(()=>{if(MENU_CONFIG.rotationAnimation)resetRotateCanvas();drawEveryCell(PLAYER_ENTITY);canRotate=true;},COMPASS_CONFIG.rotateDelay);}};const getNextCellIndexBasedOnCode=(code,useDiagonal)=>{const aIndex=getMovementMap(PLAYER_ENTITY.cell,useDiagonal)[code];if(aIndex===undefined)return;return getMod(aIndex,RENDER_INFO.currentPoly);};let isMoving=false;const moveBaseOnCode=(direction,useDiagonal)=>{if(!direction||!canDoActions())return;if(IS_FISHING_ACTIVE){moveFishing(direction,useDiagonal);return;}isMoving=true;makeEntityRun(PLAYER_ENTITY,direction);const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined)return;const nextPos=getPosByIndex(PLAYER_ENTITY.cell,aModI);if(!nextPos)return;const nextCell=getCell(nextPos);if(cellIsBlocked(nextCell,PLAYER_ENTITY))return;move(nextCell);updateWeather(direction);};const MOVEMENT_VALUES=Object.values(MOVEMENT);const stopMoving=()=>{if(!isMoving)return;let lastSelection=PLAYER_ENTITY.currentDirection;const movementMap=getMovementMap(PLAYER_ENTITY.cell);for(const movement of MOVEMENT_VALUES){if(movementMap[movement]===PLAYER_ENTITY.selectedCellIndex){lastSelection=movement;break;}}isMoving=false;updateEntityDirection(PLAYER_ENTITY,lastSelection);};const changeSelectedOnCode=(direction,useDiagonal)=>{if(!direction)return;const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined||aModI===PLAYER_ENTITY.selectedCellIndex)return;PLAYER_ENTITY.selectedCellIndex=aModI;if(MENU_CONFIG.showSelectedCell)drawEveryCell(PLAYER_ENTITY);updateEntityDirection(PLAYER_ENTITY,direction);};const getNextPolygon=()=>KNOWN_POLYGONS_VALUES[(KNOWN_POLYGONS_VALUES.indexOf(RENDER_INFO.currentPoly)+1)%KNOWN_POLYGONS_VALUES.length];const changePolySides=()=>{RENDER_INFO.currentPoly=getNextPolygon();RENDER_INFO.rotationTurns=0;PLAYER_ENTITY.selectedCellIndex=0;updateCompass();resetDirection();resetMap();};const resetDirection=()=>updateEntityDirection(PLAYER_ENTITY,MOVEMENT.UP);const updateAndGetSelectedCell=()=>{updateEntityDirection(PLAYER_ENTITY,PLAYER_ENTITY.currentDirection);return getSelectedCell(PLAYER_ENTITY);};const dig=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(!selectedCell?.block)return;if(selectedCell.entityType){makeEntityUse(PLAYER_ENTITY);const entities=getEntitiesFromCell(selectedCell);entities.forEach((e)=>hurtEntity(e,1));punchAudio.play();move();return;}if(selectedCell.block.isFluid)return;if(selectedCell.wall){if(selectedCell.wall.block.indestructible)return;}else if(selectedCell.block.indestructible)return;makeEntityUse(PLAYER_ENTITY);digAudio.play();if(selectedCell.wall){destroyWall(selectedCell);}else{selectedCell.block=null;selectedCell.color=null;}move();};const place=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.wall||selectedCell.entityType)return;makeEntityUse(PLAYER_ENTITY);placeBlock(selectedCell);move();};const placeBlock=(cell,block,color)=>{if(!cell||!!cell.entityType)return;if(!block){const cellBlock=getSelectedBlockToPlace();if(!cellBlock)return;block=cellBlock.block;color=cellBlock.color;}digAudio.play();if(cell.block&&!cell.block.isFluid){cell.wall={block:block,color:color};}else{cell.block=block;cell.color=color;}};const useBoat=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();const canMove=!selectedCell.wall&&selectedCell.block;if(PLAYER_ENTITY.connectedEntities[ENTITY_TYPES.BOAT]){if(!selectedCell?.block?.isFluid&&canMove){getOutBoat(PLAYER_ENTITY);move(selectedCell);}return;}if(selectedCell.entityType===ENTITY_TYPES.BOAT){getInBoat(PLAYER_ENTITY);move(selectedCell);}else if(canMove){makeEntityUse(PLAYER_ENTITY);addBoat(selectedCell,PLAYER_ENTITY);}};const useGun=()=>{const range=getPolyInfo().hasInverted?1:10;updateAndGetSelectedCell();gunShotAudio.currentTime=0;let{cell,selectedCellIndex}=PLAYER_ENTITY;for(let i=0;i<range;i++){const nextCell=getCell(getPosByIndex(cell,selectedCellIndex));if(nextCell.wall)break;cell=nextCell;drawCircleOnCell(cell,PLAYER_ENTITY);if(cell.entityType){const entities=getEntitiesFromCell(cell);entities.forEach((e)=>hurtEntity(e,1));break;}}gunShotAudio.play();move();};const useMap=(toggle)=>{if(IS_FISHING_ACTIVE||!canDoActions())return;toggleFullMap(toggle);};const useFishingRod=()=>{if(!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.block?.isFluid){makeEntityUse(PLAYER_ENTITY);startFishing();}};const resetMap=()=>{resetPlace();setEntitiesSize();resetCanvas();moveCurrentCell(getCenterCell(),PLAYER_ENTITY.cell);drawEveryCell(PLAYER_ENTITY);updateWeather();};const MOVEMENT_CONFIG={velocity:10,};const getCleanPos=(pos)=>({i:pos?.i||0,j:pos?.j||0});const moveCurrentCell=(oldCell,nextCell)=>{const oldPos=getCleanPos(oldCell?.pos);const nextPos=getCleanPos(nextCell?.pos);RENDER_INFO.iOffset+=nextPos.i-oldPos.i;RENDER_INFO.jOffset+=nextPos.j-oldPos.j;moveEntityToCell(PLAYER_ENTITY,nextCell);};let canMove=true;const move=(nextCell)=>{if(canMove&&PLAYER_ENTITY.health>0){canMove=false;if(nextCell)moveCurrentCell(PLAYER_ENTITY.cell,nextCell);if(MENU_CONFIG.passTime)passTime();setTimeout(()=>{drawEveryCell(PLAYER_ENTITY);killEntitiesByTimeOfDay();moveEntities(PLAYER_ENTITY.cell);spawnEntities(PLAYER_ENTITY.cell);canMove=true;},1000/MOVEMENT_CONFIG.velocity);}};const findAccessibleCell=(cell,entity)=>{let accessibleCell=cell;while(cellIsBlocked(accessibleCell,entity)){accessibleCell=loadAndGetCell({i:accessibleCell.pos.i+1,j:accessibleCell.pos.j,});}return accessibleCell;};const start=()=>{addEntity(PLAYER_ENTITY);configPolys();resetGrid();resetBiomes();removeGeneratedEntities();updateCanvasCss();resetDirection();PLAYER_ENTITY.cell=findAccessibleCell(loadAndGetCell(INITIAL_POS),PLAYER_ENTITY);resetToolbar();resetMap();};const resetSize=debounce((newSize)=>{RENDER_INFO.cellHeight=newSize||RENDER_INFO.cellHeight;configPolys();resetToolbar();resetMap();});const digAudio=new Audio("sounds/actions/dig.mp3");digAudio.volume=0.25;const punchAudio=new Audio("sounds/actions/punch.mp3");punchAudio.volume=0.25;const gunShotAudio=new Audio("sounds/actions/gun-shot.mp3");gunShotAudio.volume=1;const rotateAudio=new Audio("sounds/actions/rotate.mp3");rotateAudio.volume=0.25;let canRotate=true;const canDoActions=()=>PLAYER_ENTITY.health>0;const rotate=(orientation)=>{if(canRotate){canRotate=false;RENDER_INFO.rotationTurns=PLAYER_ENTITY.selectedCellIndex=getMod(RENDER_INFO.rotationTurns+orientation,RENDER_INFO.currentPoly);if(MENU_CONFIG.rotationAnimation){rotateCanvas((360/RENDER_INFO.currentPoly)*-orientation,COMPASS_CONFIG.rotateDelay);rotateAudio.play();}updateCompass();resetDirection();setTimeout(()=>{if(MENU_CONFIG.rotationAnimation)resetRotateCanvas();drawEveryCell(PLAYER_ENTITY);canRotate=true;},COMPASS_CONFIG.rotateDelay);}};const getNextCellIndexBasedOnCode=(code,useDiagonal)=>{const aIndex=getMovementMap(PLAYER_ENTITY.cell,useDiagonal)[code];if(aIndex===undefined)return;return getMod(aIndex,RENDER_INFO.currentPoly);};let isMoving=false;const moveBaseOnCode=(direction,useDiagonal)=>{if(!direction||!canDoActions())return;if(IS_FISHING_ACTIVE){moveFishing(direction,useDiagonal);return;}isMoving=true;makeEntityRun(PLAYER_ENTITY,direction);const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined)return;const nextPos=getPosByIndex(PLAYER_ENTITY.cell,aModI);if(!nextPos)return;const nextCell=getCell(nextPos);if(cellIsBlocked(nextCell,PLAYER_ENTITY))return;move(nextCell);updateWeather(direction);};const MOVEMENT_VALUES=Object.values(MOVEMENT);const stopMoving=()=>{if(!isMoving)return;let lastSelection=PLAYER_ENTITY.currentDirection;const movementMap=getMovementMap(PLAYER_ENTITY.cell);for(const movement of MOVEMENT_VALUES){if(movementMap[movement]===PLAYER_ENTITY.selectedCellIndex){lastSelection=movement;break;}}isMoving=false;updateEntityDirection(PLAYER_ENTITY,lastSelection);};const changeSelectedOnCode=(direction,useDiagonal)=>{if(!direction)return;const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined||aModI===PLAYER_ENTITY.selectedCellIndex)return;PLAYER_ENTITY.selectedCellIndex=aModI;if(MENU_CONFIG.showSelectedCell)drawEveryCell(PLAYER_ENTITY);updateEntityDirection(PLAYER_ENTITY,direction);};const getNextPolygon=()=>KNOWN_POLYGONS_VALUES[(KNOWN_POLYGONS_VALUES.indexOf(RENDER_INFO.currentPoly)+1)%KNOWN_POLYGONS_VALUES.length];const changePolySides=()=>{RENDER_INFO.currentPoly=getNextPolygon();RENDER_INFO.rotationTurns=0;PLAYER_ENTITY.selectedCellIndex=0;updateCompass();resetDirection();resetMap();};const resetDirection=()=>updateEntityDirection(PLAYER_ENTITY,MOVEMENT.UP);const updateAndGetSelectedCell=()=>{updateEntityDirection(PLAYER_ENTITY,PLAYER_ENTITY.currentDirection);return getSelectedCell(PLAYER_ENTITY);};const dig=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(!selectedCell?.block)return;if(selectedCell.entityType){makeEntityUse(PLAYER_ENTITY);const entities=getEntitiesFromCell(selectedCell);entities.forEach((e)=>hurtEntity(e,1));punchAudio.play();move();return;}if(selectedCell.block.isFluid)return;if(selectedCell.wall){if(selectedCell.wall.block.indestructible)return;}else if(selectedCell.block.indestructible)return;makeEntityUse(PLAYER_ENTITY);digAudio.play();if(selectedCell.wall){destroyWall(selectedCell);}else{selectedCell.block=null;selectedCell.color=null;}move();};const place=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.wall||selectedCell.entityType)return;makeEntityUse(PLAYER_ENTITY);placeBlock(selectedCell);move();};const placeBlock=(cell,block,color)=>{if(!cell||!!cell.entityType)return;if(!block){const cellBlock=getSelectedBlockToPlace();if(!cellBlock)return;block=cellBlock.block;color=cellBlock.color;}digAudio.play();if(cell.block&&!cell.block.isFluid){cell.wall={block:block,color:color};}else{cell.block=block;cell.color=color;}};const useBoat=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();const canMove=!selectedCell.wall&&selectedCell.block;if(PLAYER_ENTITY.connectedEntities[ENTITY_TYPES.BOAT]){if(!selectedCell?.block?.isFluid&&canMove){getOutBoat(PLAYER_ENTITY);move(selectedCell);}return;}if(selectedCell.entityType===ENTITY_TYPES.BOAT){getInBoat(PLAYER_ENTITY);move(selectedCell);}else if(canMove){makeEntityUse(PLAYER_ENTITY);addBoat(selectedCell,PLAYER_ENTITY);}};const useGun=()=>{const range=getPolyInfo().hasInverted?1:10;updateAndGetSelectedCell();gunShotAudio.currentTime=0;let{cell,selectedCellIndex}=PLAYER_ENTITY;for(let i=0;i<range;i++){const nextCell=getCell(getPosByIndex(cell,selectedCellIndex));if(nextCell.wall)break;cell=nextCell;drawCircleOnCell(cell,PLAYER_ENTITY);if(cell.entityType){const entities=getEntitiesFromCell(cell);entities.forEach((e)=>hurtEntity(e,1));break;}}gunShotAudio.play();move();};const useMap=(toggle)=>{if(IS_FISHING_ACTIVE||!canDoActions())return;toggleFullMap(toggle);};const useFishingRod=()=>{if(!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.block?.isFluid){makeEntityUse(PLAYER_ENTITY);startFishing();}};const resetMap=()=>{resetPlace();setEntitiesSize();resetCanvas();moveCurrentCell(getCenterCell(),PLAYER_ENTITY.cell);drawEveryCell(PLAYER_ENTITY);updateWeather();};const CONTROLS_CONFIG={minZoom:12,maxZoom:120,};const MOVEMENT_CONFIG={velocity:10,};const getCleanPos=(pos)=>({i:pos?.i||0,j:pos?.j||0});const moveCurrentCell=(oldCell,nextCell)=>{const oldPos=getCleanPos(oldCell?.pos);const nextPos=getCleanPos(nextCell?.pos);RENDER_INFO.iOffset+=nextPos.i-oldPos.i;RENDER_INFO.jOffset+=nextPos.j-oldPos.j;moveEntityToCell(PLAYER_ENTITY,nextCell);};let canMove=true;const move=(nextCell)=>{if(canMove&&PLAYER_ENTITY.health>0){canMove=false;if(nextCell)moveCurrentCell(PLAYER_ENTITY.cell,nextCell);if(MENU_CONFIG.passTime)passTime();setTimeout(()=>{drawEveryCell(PLAYER_ENTITY);killEntitiesByTimeOfDay();moveEntities(PLAYER_ENTITY.cell);spawnEntities(PLAYER_ENTITY.cell);canMove=true;},1000/MOVEMENT_CONFIG.velocity);}};const findAccessibleCell=(cell,entity)=>{let accessibleCell=cell;while(cellIsBlocked(accessibleCell,entity)){accessibleCell=loadAndGetCell({i:accessibleCell.pos.i+1,j:accessibleCell.pos.j,});}return accessibleCell;};const addDebugBlockToPoint=({x,y})=>{if(!MENU_CONFIG.debugMode||RENDER_INFO.rotationTurns)return;if(MENU_CONFIG.usePerspective){x-=175;y+=60;}const cell=getCell(calculatePosBasedOnPoint({x,y}));const block=BLOCKS.ROCK;if(cell.wall)cell.wall=null;else placeBlock(cell,block,block.color);drawEveryCell(PLAYER_ENTITY);};const getJFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(x)=>(x-xSide)/(polySide/2);case KNOWN_POLYGONS.HEXAGON:return(x)=>(x-xSide)/(xSide+polySide/2);case KNOWN_POLYGONS.SQUARE:default:return(x)=>(x-xSide)/(xSide*2);}};const calcI=(y,ySide,shouldIntercalate,evenJ)=>{let dividend=y-ySide;if(shouldIntercalate){if(PLAYER_ENTITY.cell.pos.j%2&&!evenJ){dividend+=ySide;}else if(!(PLAYER_ENTITY.cell.pos.j%2)&&evenJ){dividend-=ySide;}}return dividend/(ySide*2);};const calculatePosBasedOnPoint=({x,y})=>{const{xSide,ySide,shouldIntercalate,polySide}=getPolyInfo();let j=getJFn(RENDER_INFO.currentPoly,polySide,xSide)(x);j=Math.round(j+(RENDER_INFO.jOffset||0));let i=calcI(y,ySide,shouldIntercalate,!!(j%2));i+=RENDER_INFO.iOffset||0;return{i:Math.round(i),j:j};};const start=()=>{addEntity(PLAYER_ENTITY);configPolys();resetGrid();resetBiomes();removeGeneratedEntities();updateCanvasCss();resetDirection();PLAYER_ENTITY.cell=findAccessibleCell(loadAndGetCell(INITIAL_POS),PLAYER_ENTITY);resetToolbar();resetMap();};const resetSize=debounce((newSize)=>{RENDER_INFO.cellHeight=newSize||RENDER_INFO.cellHeight;configPolys();resetToolbar();resetMap();});(()=>{const SELECT_OPTIONS={mapGeneration:Object.entries(MAP_GENERATION),};document.querySelectorAll("#menu label").forEach((l)=>{const config=(l).htmlFor;const element=(document.getElementById(config));if(!element)return;if(element.type==="checkbox"){const check=(element);check.checked=MENU_CONFIG[config];check.onchange=()=>{MENU_CONFIG[config]=check.checked;updateCanvasCss();drawEveryCell(PLAYER_ENTITY);check.blur();};}else if(element.tagName==="SELECT"){const select=(element);SELECT_OPTIONS[config].forEach(([key,value])=>{const option=document.createElement("option");option.value=value;option.innerHTML=key;select.appendChild(option);});select.value=MENU_CONFIG[config];select.onchange=()=>{MENU_CONFIG[config]=select.value;start();select.blur();};}});const teleportationIElement=(document.getElementById("teleportation-i"));const teleportationJElement=(document.getElementById("teleportation-j"));const teleportationBtn=(document.getElementById("teleport"));teleportationBtn.onclick=()=>{const i=+teleportationIElement.value;const j=+teleportationJElement.value;move(loadAndGetCell({i,j}));teleportationBtn.blur();};const zoomSlider=(document.getElementById("zoom"));zoomSlider.value=`${RENDER_INFO.cellHeight}`;zoomSlider.min=`${CONTROLS_CONFIG.minZoom}`;zoomSlider.max=`${CONTROLS_CONFIG.maxZoom}`;zoomSlider.oninput=()=>{resetSize(+zoomSlider.value);zoomSlider.blur();};const musicVolumeSlider=(document.getElementById("musicVolume"));musicVolumeSlider.value=`50`;musicVolumeSlider.min=`0`;musicVolumeSlider.max=`100`;musicVolumeSlider.oninput=()=>{setMusicVolume(+musicVolumeSlider.value);musicVolumeSlider.blur();};setMusicVolume(+musicVolumeSlider.value);})();const CONTROLS_CONFIG={minZoom:12,maxZoom:120,};(()=>{let mobileZoom=0;canvasContainer.ontouchstart=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];mobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);return;}};canvasContainer.ontouchmove=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];const nMobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);if(nMobileZoom>mobileZoom&&RENDER_INFO.cellHeight<CONTROLS_CONFIG.maxZoom){resetSize(RENDER_INFO.cellHeight+1);}else if(nMobileZoom<mobileZoom&&RENDER_INFO.cellHeight>CONTROLS_CONFIG.minZoom){resetSize(RENDER_INFO.cellHeight-1);}mobileZoom=nMobileZoom;}};canvasContainer.ontouchend=()=>{mobileZoom=0;};document.getElementById("change-poly").onclick=()=>{changePolySides();updatePolyImages();};document.getElementById("rotate-left").onclick=()=>rotate(-1);document.getElementById("rotate-right").onclick=()=>rotate(1);const currentPoly=(document.getElementById("current-poly"));const nextPoly=(document.getElementById("next-poly"));const updatePolyImages=()=>{setImagePos(currentPoly,POLYGONS_ENTITY_POS[RENDER_INFO.currentPoly]);setImagePos(nextPoly,POLYGONS_ENTITY_POS[getNextPolygon()]);};updatePolyImages();})();const createMazeObj=(mazeInfos,mazeCircleInfos)=>{let MAZE_GRID=([]);const MAZE_POLYS_INFO=({});const getMazePolyInfo=()=>MAZE_POLYS_INFO[RENDER_INFO.currentPoly];const CIRCLE_INFO=({cellHeight:0,center:null,rows:0,columns:0,});const MAZE_INFO=({rows:0,columns:0,isCircle:false,currentCell:null,queue:[],});const getMazeCell=({i,j})=>MAZE_GRID[i]?.[j];function*iterateOverMaze(){const rows=getMazeRows();for(let i=0;i<rows;i++){const numCells=getNumCellsPerMazeRow(i);for(let j=0;j<numCells;j++){yield{i,j};}}}const createMazeGrid=()=>{MAZE_GRID=[];for(const{i,j}of iterateOverMaze()){MAZE_GRID[i]=MAZE_GRID[i]||[];MAZE_GRID[i][j]=createCellMaze({i,j});}};const createCellMaze=(pos)=>{const cell=(createCellProps(pos));cell.visited=false;cell.solved=false;cell.path=false;cell.borders=[...new Array(RENDER_INFO.currentPoly)].map(()=>true);if(MAZE_INFO.isCircle)createCircleCellMaze(cell);else cell.point=calculateMazePoint(pos);return cell;};const calculateMazePoint=({i,j})=>{const{calcX,calcY,ySide,shouldIntercalate}=getMazePolyInfo();const x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=ySide;return{x,y};};const getMazeRows=()=>MAZE_INFO.isCircle?CIRCLE_INFO.rows:MAZE_INFO.rows;const getNumCellsPerMazeRow=(rowIndex)=>MAZE_INFO.isCircle?CIRCLE_INFO.columns-Math.floor((rowIndex+1)/2):MAZE_INFO.columns;const createCircleCellMaze=(cell)=>{const{i,j}=cell.pos;const topRadius=(CIRCLE_INFO.rows-i)*CIRCLE_INFO.cellHeight;const bottomRadius=topRadius-CIRCLE_INFO.cellHeight;const topAngle=Math.atan2(-topRadius,0);const bottomAngle=bottomRadius?topAngle:0;const numCells=getNumCellsPerMazeRow(i);const parts=(Math.PI*1.5-topAngle)/numCells;const leftBorder=j*parts;const rightBorder=(j+1)*parts;const topLeftAngle=topAngle+leftBorder;const topRightAngle=topAngle+rightBorder;const bottomLeftAngle=bottomAngle+leftBorder;const bottomRightAngle=bottomAngle+rightBorder;const topLeftPoint=getMazePoint(topRadius,topLeftAngle);const topRightPoint=getMazePoint(topRadius,topRightAngle);const bottomLeftPoint=getMazePoint(bottomRadius,bottomLeftAngle);const bottomRightPoint=getMazePoint(bottomRadius,bottomRightAngle);const points=[getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topLeftAngle),getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topRightAngle),];const x=points.reduce((acc,p)=>acc+p.x,0)/points.length;const y=points.reduce((acc,p)=>acc+p.y,0)/points.length;cell.point={x,y};cell.circleProps={topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topRadius,bottomRadius,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,adjacentPos:cell.adjacentPos[KNOWN_POLYGONS.SQUARE].map((aPos)=>({i:aPos.i,j:aPos.j<0?numCells-1:aPos.j>=numCells?0:aPos.j,})),};};const getMazePoint=(radius,angle)=>({x:CIRCLE_INFO.center.x+Math.cos(angle)*radius,y:CIRCLE_INFO.center.y+Math.sin(angle)*radius,});const buildMaze=()=>{createMazeGrid();MAZE_INFO.queue=[];MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);const lastCell=getLastMazeCell();while(MAZE_INFO.currentCell)MAZE_INFO.currentCell=buildCellMaze(MAZE_INFO.currentCell,lastCell);if(!MAZE_INFO.isCircle&&lastCell){openBorderForCellMaze(lastCell,getMazeCell(getAdjPos(lastCell)[0]));lastCell.visited=true;}if(!MAZE_INFO.isCircle&&getMazePolyInfo().hasInverted){for(const pos of iterateOverMaze()){const cell=getMazeCell(pos);cell.invertedBorders=[...cell.borders].reverse();}}MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const openBorderForCellMaze=(cell,nextCell)=>{const adjacentIndex=getNextCellMazeAdjacentIndex(cell,nextCell);const nextAdjacentIndex=getNextCellMazeAdjacentIndex(nextCell,cell);cell.borders[adjacentIndex]=false;nextCell.borders[nextAdjacentIndex]=false;};const buildCellMaze=(cell,lastCell)=>{cell.visited=true;const nextCell=getNextCellMaze(cell,(c)=>!!c&&!c.visited&&c!==lastCell,true);if(!nextCell)return null;openBorderForCellMaze(cell,nextCell);return nextCell;};const getLastMazeCell=()=>getMazeCell({i:MAZE_INFO.rows-1,j:MAZE_INFO.columns-1});const isMazeSolved=()=>!MAZE_INFO.currentCell||(MAZE_INFO.isCircle?MAZE_INFO.currentCell.pos.i===CIRCLE_INFO.rows-1:MAZE_INFO.currentCell===getLastMazeCell());const solveMaze=()=>{while(!isMazeSolved())MAZE_INFO.currentCell=solveCellMaze(MAZE_INFO.currentCell);solveCellMaze(MAZE_INFO.currentCell);MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const solveCellMaze=(cell)=>{if(!cell)return;cell.solved=true;cell.path=true;const prevLength=MAZE_INFO.queue.length;const nextCell=getNextCellMaze(cell,(c)=>{if(!c||c.solved)return false;const nextIndex=getNextCellMazeAdjacentIndex(cell,c);return!cell.borders[nextIndex];});if(prevLength>MAZE_INFO.queue.length)cell.path=false;return nextCell;};const getAdjPos=(cell)=>cell.circleProps?.adjacentPos||cell.adjacentPos[RENDER_INFO.currentPoly];const getNextCellMaze=(cell,cellFilter,isRandom=false)=>{const adjacentPos=getAdjPos(cell);const aCells=adjacentPos.map(getMazeCell).filter(cellFilter);if(!aCells.length){if(!MAZE_INFO.queue.length)return null;const prevPos=MAZE_INFO.queue.pop();return getMazeCell(prevPos);}MAZE_INFO.queue.push(cell.pos);return aCells[isRandom?getRandomInt(aCells.length):aCells.length-1];};const getNextCellMazeAdjacentIndex=(cell,nextCell)=>{let nextIndex=0;const adjacentPos=getAdjPos(cell);while(nextIndex<adjacentPos.length){const{i,j}=adjacentPos[nextIndex];if(nextCell.pos.i===i&&nextCell.pos.j===j)break;nextIndex++;}return nextIndex;};const mazeMove=(posIndex)=>{if(posIndex===undefined||MAZE_INFO.currentCell.borders[posIndex])return;const nextPos=getAdjPos(MAZE_INFO.currentCell)[posIndex];if(!nextPos)return;const nextCell=getMazeCell(nextPos);if(!nextCell)return;const oldCell=MAZE_INFO.currentCell;MAZE_INFO.currentCell=nextCell;const prevCell=MAZE_INFO.queue[MAZE_INFO.queue.length-1];if(nextCell.pos===prevCell){oldCell.path=false;MAZE_INFO.queue.pop();}else{oldCell.path=true;MAZE_INFO.queue.push(oldCell.pos);}return MAZE_INFO.currentCell;};const initMaze=()=>{for(const p of KNOWN_POLYGONS_VALUES){MAZE_POLYS_INFO[p]=configPoly(p,mazeInfos.cellHeight);}MAZE_INFO.rows=mazeInfos.rows;MAZE_INFO.columns=mazeInfos.columns;CIRCLE_INFO.cellHeight=mazeCircleInfos?.cellHeight||mazeInfos.cellHeight;CIRCLE_INFO.rows=mazeCircleInfos?.rows||MAZE_INFO.rows*2;CIRCLE_INFO.columns=mazeCircleInfos?.columns||MAZE_INFO.columns*2;const center=(CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2)/2;CIRCLE_INFO.center={x:center,y:center};};const getMazeSize=()=>{let{ySide,xSide,shouldIntercalate,hasInverted,polySide}=getMazePolyInfo();let height=MAZE_INFO.rows*mazeInfos.cellHeight;let width=MAZE_INFO.columns*(xSide*2);if(MAZE_INFO.isCircle)height=width=CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2;else{if(hasInverted)width=(MAZE_INFO.columns*polySide)/2+polySide/2+2;if(shouldIntercalate){height+=ySide;width=width*0.8;}}return{height,width};};const setIsCircle=(isCircle)=>{MAZE_INFO.isCircle=isCircle;if(MAZE_INFO.isCircle)RENDER_INFO.currentPoly=KNOWN_POLYGONS.SQUARE;};initMaze();return{getMazeSize,mazeMove,buildMaze,solveMaze,isMazeSolved,setIsCircle,getCirclePoint:()=>CIRCLE_INFO.center,iterateOverMaze,getMazeCell,getCurrentMazeCell:()=>MAZE_INFO.currentCell,getLastMazeCell,getMazePolyInfo,};};const addDebugBlockToPoint=({x,y})=>{if(!MENU_CONFIG.debugMode||RENDER_INFO.rotationTurns)return;if(MENU_CONFIG.usePerspective){x-=175;y+=60;}const cell=getCell(calculatePosBasedOnPoint({x,y}));const block=BLOCKS.ROCK;if(cell.wall)cell.wall=null;else placeBlock(cell,block,block.color);drawEveryCell(PLAYER_ENTITY);};const getJFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(x)=>(x-xSide)/(polySide/2);case KNOWN_POLYGONS.HEXAGON:return(x)=>(x-xSide)/(xSide+polySide/2);case KNOWN_POLYGONS.SQUARE:default:return(x)=>(x-xSide)/(xSide*2);}};const calcI=(y,ySide,shouldIntercalate,evenJ)=>{let dividend=y-ySide;if(shouldIntercalate){if(PLAYER_ENTITY.cell.pos.j%2&&!evenJ){dividend+=ySide;}else if(!(PLAYER_ENTITY.cell.pos.j%2)&&evenJ){dividend-=ySide;}}return dividend/(ySide*2);};const calculatePosBasedOnPoint=({x,y})=>{const{xSide,ySide,shouldIntercalate,polySide}=getPolyInfo();let j=getJFn(RENDER_INFO.currentPoly,polySide,xSide)(x);j=Math.round(j+(RENDER_INFO.jOffset||0));let i=calcI(y,ySide,shouldIntercalate,!!(j%2));i+=RENDER_INFO.iOffset||0;return{i:Math.round(i),j:j};};(()=>{const SELECTION_STICK_CONFIG={touchThreshold:20,};const selectionStickLeft=document.getElementById("selection-stick-left");const selectionStickRight=document.getElementById("selection-stick-right");const SELECTION_STICK_INFO=(()=>{const maxPoint=selectionStickLeft.offsetWidth/1.25;const minPoint=selectionStickLeft.offsetWidth/5;const midPoint=minPoint+(maxPoint-minPoint)/2;const maxMidPoint=midPoint+SELECTION_STICK_CONFIG.touchThreshold;const minMidPoint=midPoint-SELECTION_STICK_CONFIG.touchThreshold;return{maxPoint,minPoint,midPoint,maxMidPoint,minMidPoint};})();const moveStick=(e,stickElement)=>{e=e||(window.event);e.preventDefault();e.stopPropagation();const{clientX,clientY}=e.touches[0];const stickRect=stickElement.getBoundingClientRect();let finalX=clientX-stickRect.left;let finalY=clientY-stickRect.top;finalX=Math.min(finalX,SELECTION_STICK_INFO.maxPoint);finalX=Math.max(finalX,SELECTION_STICK_INFO.minPoint);finalY=Math.min(finalY,SELECTION_STICK_INFO.maxPoint);finalY=Math.max(finalY,SELECTION_STICK_INFO.minPoint);stickElement.style.setProperty("--selection-stick-left",`${finalX}px`);stickElement.style.setProperty("--selection-stick-top",`${finalY}px`);let code=null;const useDiagonal=finalY>SELECTION_STICK_INFO.maxMidPoint;if(useDiagonal)code=MOVEMENT.DOWN;if(finalY<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.UP;if(finalX>SELECTION_STICK_INFO.maxMidPoint)code=MOVEMENT.RIGHT;if(finalX<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.LEFT;return{code,useDiagonal};};selectionStickLeft.ontouchstart=selectionStickLeft.ontouchmove=(e)=>{const{code,useDiagonal}=moveStick(e,selectionStickLeft);if(code)changeSelectedOnCode(code,useDiagonal);};let rightStickInfo=({});const updateRightStickInfo=(e)=>(rightStickInfo=moveStick(e,selectionStickRight));selectionStickRight.ontouchstart=(e)=>{clearInterval(rightStickInfo.interval);updateRightStickInfo(e);rightStickInfo.interval=setInterval(()=>{if(rightStickInfo.code)moveBaseOnCode(rightStickInfo.code,rightStickInfo.useDiagonal);else stopMoving();},100);};selectionStickRight.ontouchmove=updateRightStickInfo;document.ontouchend=()=>{selectionStickLeft?.style.removeProperty("--selection-stick-left");selectionStickLeft?.style.removeProperty("--selection-stick-top");selectionStickRight?.style.removeProperty("--selection-stick-left");selectionStickRight?.style.removeProperty("--selection-stick-top");stopMoving();clearInterval(rightStickInfo.interval);rightStickInfo={code:null,useDiagonal:null,interval:null};};})();(()=>{const SELECT_OPTIONS={mapGeneration:Object.entries(MAP_GENERATION),};document.querySelectorAll("#menu label").forEach((l)=>{const config=(l).htmlFor;const element=(document.getElementById(config));if(!element)return;if(element.type==="checkbox"){const check=(element);check.checked=MENU_CONFIG[config];check.onchange=()=>{MENU_CONFIG[config]=check.checked;updateCanvasCss();drawEveryCell(PLAYER_ENTITY);check.blur();};}else if(element.tagName==="SELECT"){const select=(element);SELECT_OPTIONS[config].forEach(([key,value])=>{const option=document.createElement("option");option.value=value;option.innerHTML=key;select.appendChild(option);});select.value=MENU_CONFIG[config];select.onchange=()=>{MENU_CONFIG[config]=select.value;start();select.blur();};}});const teleportationIElement=(document.getElementById("teleportation-i"));const teleportationJElement=(document.getElementById("teleportation-j"));const teleportationBtn=(document.getElementById("teleport"));teleportationBtn.onclick=()=>{const i=+teleportationIElement.value;const j=+teleportationJElement.value;move(loadAndGetCell({i,j}));teleportationBtn.blur();};const zoomSlider=(document.getElementById("zoom"));zoomSlider.value=`${RENDER_INFO.cellHeight}`;zoomSlider.min=`${CONTROLS_CONFIG.minZoom}`;zoomSlider.max=`${CONTROLS_CONFIG.maxZoom}`;zoomSlider.oninput=()=>{resetSize(+zoomSlider.value);zoomSlider.blur();};const musicVolumeSlider=(document.getElementById("musicVolume"));musicVolumeSlider.value=`50`;musicVolumeSlider.min=`0`;musicVolumeSlider.max=`100`;musicVolumeSlider.oninput=()=>{setMusicVolume(+musicVolumeSlider.value);musicVolumeSlider.blur();};setMusicVolume(+musicVolumeSlider.value);})();(()=>{let mobileZoom=0;canvasContainer.ontouchstart=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];mobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);return;}};canvasContainer.ontouchmove=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];const nMobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);if(nMobileZoom>mobileZoom&&RENDER_INFO.cellHeight<CONTROLS_CONFIG.maxZoom){resetSize(RENDER_INFO.cellHeight+1);}else if(nMobileZoom<mobileZoom&&RENDER_INFO.cellHeight>CONTROLS_CONFIG.minZoom){resetSize(RENDER_INFO.cellHeight-1);}mobileZoom=nMobileZoom;}};canvasContainer.ontouchend=()=>{mobileZoom=0;};document.getElementById("change-poly").onclick=()=>{changePolySides();updatePolyImages();};document.getElementById("rotate-left").onclick=()=>rotate(-1);document.getElementById("rotate-right").onclick=()=>rotate(1);const currentPoly=(document.getElementById("current-poly"));const nextPoly=(document.getElementById("next-poly"));const updatePolyImages=()=>{setImagePos(currentPoly,POLYGONS_ENTITY_POS[RENDER_INFO.currentPoly]);setImagePos(nextPoly,POLYGONS_ENTITY_POS[getNextPolygon()]);};updatePolyImages();})();(()=>{const KEY_MOVEMENT_MAP={["KeyW"]:MOVEMENT.UP,["KeyA"]:MOVEMENT.LEFT,["KeyS"]:MOVEMENT.DOWN,["KeyD"]:MOVEMENT.RIGHT,};const ARROW_MOVEMENT_MAP={["ArrowUp"]:MOVEMENT.UP,["ArrowLeft"]:MOVEMENT.LEFT,["ArrowDown"]:MOVEMENT.DOWN,["ArrowRight"]:MOVEMENT.RIGHT,};let selectedToolbarIndex=1;const TOOLBAR_ACTIONS=[undefined,document.getElementById("toolbar-dig"),document.getElementById("toolbar-place"),document.getElementById("toolbar-fishing"),document.getElementById("toolbar-boat"),document.getElementById("toolbar-gun"),document.getElementById("toolbar-map"),];const MOVEMENT_KEYS=Object.keys(KEY_MOVEMENT_MAP);const menuToggle=(document.getElementById("menuToggle"));const closeDebugMenu=()=>(menuToggle.checked=false);document.onkeydown=(e)=>{e=e||(window.event);const targetElement=(e.target);if(targetElement.tagName==="INPUT"&&targetElement.id!=="menuToggle")return;if(e.code==="KeyR")movePlaceBlocks(e.altKey?-1:1);if(e.code.startsWith("Arrow"))return moveBaseOnCode(ARROW_MOVEMENT_MAP[e.code],e.altKey);if(e.code.startsWith("Digit")||e.code.startsWith("Numpad"))return updateToolbarSelected(+e.code.replace(/Numpad|Digit/gi,""));if(MOVEMENT_KEYS.includes(e.code))return changeSelectedOnCode(KEY_MOVEMENT_MAP[e.code],e.altKey);if(e.code==="KeyQ")return rotate(-1);if(e.code==="KeyE")return rotate(1);if(e.code==="KeyF")return TOOLBAR_ACTIONS[selectedToolbarIndex].onclick(null);if(e.code.includes("Shift"))return changePolySides();if(e.code==="Space")return move();if(e.code==="Escape"){closeDebugMenu();useMap(false);}};document.onkeyup=()=>{stopMoving();};const updateToolbarSelected=(keyIndex)=>{const element=TOOLBAR_ACTIONS[keyIndex];if(!element)return;TOOLBAR_ACTIONS[selectedToolbarIndex].classList.remove("toolbar-selected");selectedToolbarIndex=keyIndex;element.classList.add("toolbar-selected");};document.onwheel=(e)=>{e=e||(window.event);updateToolbarSelected(e.deltaY<0?selectedToolbarIndex-1:selectedToolbarIndex+1);};updateToolbarSelected(selectedToolbarIndex);TOOLBAR_ACTIONS[1].onclick=()=>dig();const toolbarPlace=document.getElementById("toolbar-place");TOOLBAR_ACTIONS[2].onclick=(e)=>{if(e){const{top}=toolbarPlace.getBoundingClientRect();const y=e.clientY-top;if(y<0)return movePlaceBlocks(-1);if(y>toolbarPlace.offsetHeight)return movePlaceBlocks(1);}place();};TOOLBAR_ACTIONS[3].onclick=()=>useFishingRod();TOOLBAR_ACTIONS[4].onclick=()=>useBoat();TOOLBAR_ACTIONS[5].onclick=()=>useGun();TOOLBAR_ACTIONS[6].onclick=()=>useMap();canvasContainer.onclick=(e)=>{e=e||(window.event);if(MENU_CONFIG.debugMode){const{left,top}=canvasContainer.getBoundingClientRect();const x=e.clientX-left;const y=e.clientY-top;addDebugBlockToPoint({x,y});}closeDebugMenu();stopFishing();};})();start();window.onresize=()=>{resetSize();};(()=>{const SELECTION_STICK_CONFIG={touchThreshold:20,};const selectionStickLeft=document.getElementById("selection-stick-left");const selectionStickRight=document.getElementById("selection-stick-right");const SELECTION_STICK_INFO=(()=>{const maxPoint=selectionStickLeft.offsetWidth/1.25;const minPoint=selectionStickLeft.offsetWidth/5;const midPoint=minPoint+(maxPoint-minPoint)/2;const maxMidPoint=midPoint+SELECTION_STICK_CONFIG.touchThreshold;const minMidPoint=midPoint-SELECTION_STICK_CONFIG.touchThreshold;return{maxPoint,minPoint,midPoint,maxMidPoint,minMidPoint};})();const moveStick=(e,stickElement)=>{e=e||(window.event);e.preventDefault();e.stopPropagation();const{clientX,clientY}=e.touches[0];const stickRect=stickElement.getBoundingClientRect();let finalX=clientX-stickRect.left;let finalY=clientY-stickRect.top;finalX=Math.min(finalX,SELECTION_STICK_INFO.maxPoint);finalX=Math.max(finalX,SELECTION_STICK_INFO.minPoint);finalY=Math.min(finalY,SELECTION_STICK_INFO.maxPoint);finalY=Math.max(finalY,SELECTION_STICK_INFO.minPoint);stickElement.style.setProperty("--selection-stick-left",`${finalX}px`);stickElement.style.setProperty("--selection-stick-top",`${finalY}px`);let code=null;const useDiagonal=finalY>SELECTION_STICK_INFO.maxMidPoint;if(useDiagonal)code=MOVEMENT.DOWN;if(finalY<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.UP;if(finalX>SELECTION_STICK_INFO.maxMidPoint)code=MOVEMENT.RIGHT;if(finalX<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.LEFT;return{code,useDiagonal};};selectionStickLeft.ontouchstart=selectionStickLeft.ontouchmove=(e)=>{const{code,useDiagonal}=moveStick(e,selectionStickLeft);if(code)changeSelectedOnCode(code,useDiagonal);};let rightStickInfo=({});const updateRightStickInfo=(e)=>(rightStickInfo=moveStick(e,selectionStickRight));selectionStickRight.ontouchstart=(e)=>{clearInterval(rightStickInfo.interval);updateRightStickInfo(e);rightStickInfo.interval=setInterval(()=>{if(rightStickInfo.code)moveBaseOnCode(rightStickInfo.code,rightStickInfo.useDiagonal);else stopMoving();},100);};selectionStickRight.ontouchmove=updateRightStickInfo;document.ontouchend=()=>{selectionStickLeft?.style.removeProperty("--selection-stick-left");selectionStickLeft?.style.removeProperty("--selection-stick-top");selectionStickRight?.style.removeProperty("--selection-stick-left");selectionStickRight?.style.removeProperty("--selection-stick-top");stopMoving();clearInterval(rightStickInfo.interval);rightStickInfo={code:null,useDiagonal:null,interval:null};};})();const createMazeObj=(mazeInfos,mazeCircleInfos)=>{let MAZE_GRID=([]);const MAZE_POLYS_INFO=({});const getMazePolyInfo=()=>MAZE_POLYS_INFO[RENDER_INFO.currentPoly];const CIRCLE_INFO=({cellHeight:0,center:null,rows:0,columns:0,});const MAZE_INFO=({rows:0,columns:0,isCircle:false,currentCell:null,queue:[],});const getMazeCell=({i,j})=>MAZE_GRID[i]?.[j];function*iterateOverMaze(){const rows=getMazeRows();for(let i=0;i<rows;i++){const numCells=getNumCellsPerMazeRow(i);for(let j=0;j<numCells;j++){yield{i,j};}}}const createMazeGrid=()=>{MAZE_GRID=[];for(const{i,j}of iterateOverMaze()){MAZE_GRID[i]=MAZE_GRID[i]||[];MAZE_GRID[i][j]=createCellMaze({i,j});}};const createCellMaze=(pos)=>{const cell=(createCellProps(pos));cell.visited=false;cell.solved=false;cell.path=false;cell.borders=[...new Array(RENDER_INFO.currentPoly)].map(()=>true);if(MAZE_INFO.isCircle)createCircleCellMaze(cell);else cell.point=calculateMazePoint(pos);return cell;};const calculateMazePoint=({i,j})=>{const{calcX,calcY,ySide,shouldIntercalate}=getMazePolyInfo();const x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=ySide;return{x,y};};const getMazeRows=()=>MAZE_INFO.isCircle?CIRCLE_INFO.rows:MAZE_INFO.rows;const getNumCellsPerMazeRow=(rowIndex)=>MAZE_INFO.isCircle?CIRCLE_INFO.columns-Math.floor((rowIndex+1)/2):MAZE_INFO.columns;const createCircleCellMaze=(cell)=>{const{i,j}=cell.pos;const topRadius=(CIRCLE_INFO.rows-i)*CIRCLE_INFO.cellHeight;const bottomRadius=topRadius-CIRCLE_INFO.cellHeight;const topAngle=Math.atan2(-topRadius,0);const bottomAngle=bottomRadius?topAngle:0;const numCells=getNumCellsPerMazeRow(i);const parts=(Math.PI*1.5-topAngle)/numCells;const leftBorder=j*parts;const rightBorder=(j+1)*parts;const topLeftAngle=topAngle+leftBorder;const topRightAngle=topAngle+rightBorder;const bottomLeftAngle=bottomAngle+leftBorder;const bottomRightAngle=bottomAngle+rightBorder;const topLeftPoint=getMazePoint(topRadius,topLeftAngle);const topRightPoint=getMazePoint(topRadius,topRightAngle);const bottomLeftPoint=getMazePoint(bottomRadius,bottomLeftAngle);const bottomRightPoint=getMazePoint(bottomRadius,bottomRightAngle);const points=[getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topLeftAngle),getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topRightAngle),];const x=points.reduce((acc,p)=>acc+p.x,0)/points.length;const y=points.reduce((acc,p)=>acc+p.y,0)/points.length;cell.point={x,y};cell.circleProps={topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topRadius,bottomRadius,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,adjacentPos:cell.adjacentPos[KNOWN_POLYGONS.SQUARE].map((aPos)=>({i:aPos.i,j:aPos.j<0?numCells-1:aPos.j>=numCells?0:aPos.j,})),};};const getMazePoint=(radius,angle)=>({x:CIRCLE_INFO.center.x+Math.cos(angle)*radius,y:CIRCLE_INFO.center.y+Math.sin(angle)*radius,});const buildMaze=()=>{createMazeGrid();MAZE_INFO.queue=[];MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);const lastCell=getLastMazeCell();while(MAZE_INFO.currentCell)MAZE_INFO.currentCell=buildCellMaze(MAZE_INFO.currentCell,lastCell);if(!MAZE_INFO.isCircle&&lastCell){openBorderForCellMaze(lastCell,getMazeCell(getAdjPos(lastCell)[0]));lastCell.visited=true;}if(!MAZE_INFO.isCircle&&getMazePolyInfo().hasInverted){for(const pos of iterateOverMaze()){const cell=getMazeCell(pos);cell.invertedBorders=[...cell.borders].reverse();}}MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const openBorderForCellMaze=(cell,nextCell)=>{const adjacentIndex=getNextCellMazeAdjacentIndex(cell,nextCell);const nextAdjacentIndex=getNextCellMazeAdjacentIndex(nextCell,cell);cell.borders[adjacentIndex]=false;nextCell.borders[nextAdjacentIndex]=false;};const buildCellMaze=(cell,lastCell)=>{cell.visited=true;const nextCell=getNextCellMaze(cell,(c)=>!!c&&!c.visited&&c!==lastCell,true);if(!nextCell)return null;openBorderForCellMaze(cell,nextCell);return nextCell;};const getLastMazeCell=()=>getMazeCell({i:MAZE_INFO.rows-1,j:MAZE_INFO.columns-1});const isMazeSolved=()=>!MAZE_INFO.currentCell||(MAZE_INFO.isCircle?MAZE_INFO.currentCell.pos.i===CIRCLE_INFO.rows-1:MAZE_INFO.currentCell===getLastMazeCell());const solveMaze=()=>{while(!isMazeSolved())MAZE_INFO.currentCell=solveCellMaze(MAZE_INFO.currentCell);solveCellMaze(MAZE_INFO.currentCell);MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const solveCellMaze=(cell)=>{if(!cell)return;cell.solved=true;cell.path=true;const prevLength=MAZE_INFO.queue.length;const nextCell=getNextCellMaze(cell,(c)=>{if(!c||c.solved)return false;const nextIndex=getNextCellMazeAdjacentIndex(cell,c);return!cell.borders[nextIndex];});if(prevLength>MAZE_INFO.queue.length)cell.path=false;return nextCell;};const getAdjPos=(cell)=>cell.circleProps?.adjacentPos||cell.adjacentPos[RENDER_INFO.currentPoly];const getNextCellMaze=(cell,cellFilter,isRandom=false)=>{const adjacentPos=getAdjPos(cell);const aCells=adjacentPos.map(getMazeCell).filter(cellFilter);if(!aCells.length){if(!MAZE_INFO.queue.length)return null;const prevPos=MAZE_INFO.queue.pop();return getMazeCell(prevPos);}MAZE_INFO.queue.push(cell.pos);return aCells[isRandom?getRandomInt(aCells.length):aCells.length-1];};const getNextCellMazeAdjacentIndex=(cell,nextCell)=>{let nextIndex=0;const adjacentPos=getAdjPos(cell);while(nextIndex<adjacentPos.length){const{i,j}=adjacentPos[nextIndex];if(nextCell.pos.i===i&&nextCell.pos.j===j)break;nextIndex++;}return nextIndex;};const mazeMove=(posIndex)=>{if(posIndex===undefined||MAZE_INFO.currentCell.borders[posIndex])return;const nextPos=getAdjPos(MAZE_INFO.currentCell)[posIndex];if(!nextPos)return;const nextCell=getMazeCell(nextPos);if(!nextCell)return;const oldCell=MAZE_INFO.currentCell;MAZE_INFO.currentCell=nextCell;const prevCell=MAZE_INFO.queue[MAZE_INFO.queue.length-1];if(nextCell.pos===prevCell){oldCell.path=false;MAZE_INFO.queue.pop();}else{oldCell.path=true;MAZE_INFO.queue.push(oldCell.pos);}return MAZE_INFO.currentCell;};const initMaze=()=>{for(const p of KNOWN_POLYGONS_VALUES){MAZE_POLYS_INFO[p]=configPoly(p,mazeInfos.cellHeight);}MAZE_INFO.rows=mazeInfos.rows;MAZE_INFO.columns=mazeInfos.columns;CIRCLE_INFO.cellHeight=mazeCircleInfos?.cellHeight||mazeInfos.cellHeight;CIRCLE_INFO.rows=mazeCircleInfos?.rows||MAZE_INFO.rows*2;CIRCLE_INFO.columns=mazeCircleInfos?.columns||MAZE_INFO.columns*2;const center=(CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2)/2;CIRCLE_INFO.center={x:center,y:center};};const getMazeSize=()=>{let{ySide,xSide,shouldIntercalate,hasInverted,polySide}=getMazePolyInfo();let height=MAZE_INFO.rows*mazeInfos.cellHeight;let width=MAZE_INFO.columns*(xSide*2);if(MAZE_INFO.isCircle)height=width=CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2;else{if(hasInverted)width=(MAZE_INFO.columns*polySide)/2+polySide/2+2;if(shouldIntercalate){height+=ySide;width=width*0.8;}}return{height,width};};const setIsCircle=(isCircle)=>{MAZE_INFO.isCircle=isCircle;if(MAZE_INFO.isCircle)RENDER_INFO.currentPoly=KNOWN_POLYGONS.SQUARE;};initMaze();return{getMazeSize,mazeMove,buildMaze,solveMaze,isMazeSolved,setIsCircle,getCirclePoint:()=>CIRCLE_INFO.center,iterateOverMaze,getMazeCell,getCurrentMazeCell:()=>MAZE_INFO.currentCell,getLastMazeCell,getMazePolyInfo,};};(()=>{const KEY_MOVEMENT_MAP={["KeyW"]:MOVEMENT.UP,["KeyA"]:MOVEMENT.LEFT,["KeyS"]:MOVEMENT.DOWN,["KeyD"]:MOVEMENT.RIGHT,};const ARROW_MOVEMENT_MAP={["ArrowUp"]:MOVEMENT.UP,["ArrowLeft"]:MOVEMENT.LEFT,["ArrowDown"]:MOVEMENT.DOWN,["ArrowRight"]:MOVEMENT.RIGHT,};let selectedToolbarIndex=1;const TOOLBAR_ACTIONS=[undefined,document.getElementById("toolbar-dig"),document.getElementById("toolbar-place"),document.getElementById("toolbar-fishing"),document.getElementById("toolbar-boat"),document.getElementById("toolbar-gun"),document.getElementById("toolbar-map"),];const MOVEMENT_KEYS=Object.keys(KEY_MOVEMENT_MAP);const menuToggle=(document.getElementById("menuToggle"));const closeDebugMenu=()=>(menuToggle.checked=false);document.onkeydown=(e)=>{e=e||(window.event);const targetElement=(e.target);if(targetElement.tagName==="INPUT"&&targetElement.id!=="menuToggle")return;if(e.code==="KeyR")movePlaceBlocks(e.altKey?-1:1);if(e.code.startsWith("Arrow"))return moveBaseOnCode(ARROW_MOVEMENT_MAP[e.code],e.altKey);if(e.code.startsWith("Digit")||e.code.startsWith("Numpad"))return updateToolbarSelected(+e.code.replace(/Numpad|Digit/gi,""));if(MOVEMENT_KEYS.includes(e.code))return changeSelectedOnCode(KEY_MOVEMENT_MAP[e.code],e.altKey);if(e.code==="KeyQ")return rotate(-1);if(e.code==="KeyE")return rotate(1);if(e.code==="KeyF")return TOOLBAR_ACTIONS[selectedToolbarIndex].onclick(null);if(e.code.includes("Shift"))return changePolySides();if(e.code==="Space")return move();if(e.code==="Escape"){closeDebugMenu();useMap(false);}};document.onkeyup=()=>{stopMoving();};const updateToolbarSelected=(keyIndex)=>{const element=TOOLBAR_ACTIONS[keyIndex];if(!element)return;TOOLBAR_ACTIONS[selectedToolbarIndex].classList.remove("toolbar-selected");selectedToolbarIndex=keyIndex;element.classList.add("toolbar-selected");};document.onwheel=(e)=>{e=e||(window.event);updateToolbarSelected(e.deltaY<0?selectedToolbarIndex-1:selectedToolbarIndex+1);};updateToolbarSelected(selectedToolbarIndex);TOOLBAR_ACTIONS[1].onclick=()=>dig();const toolbarPlace=document.getElementById("toolbar-place");TOOLBAR_ACTIONS[2].onclick=(e)=>{if(e){const{top}=toolbarPlace.getBoundingClientRect();const y=e.clientY-top;if(y<0)return movePlaceBlocks(-1);if(y>toolbarPlace.offsetHeight)return movePlaceBlocks(1);}place();};TOOLBAR_ACTIONS[3].onclick=()=>useFishingRod();TOOLBAR_ACTIONS[4].onclick=()=>useBoat();TOOLBAR_ACTIONS[5].onclick=()=>useGun();TOOLBAR_ACTIONS[6].onclick=()=>useMap();canvasContainer.onclick=(e)=>{e=e||(window.event);if(MENU_CONFIG.debugMode){const{left,top}=canvasContainer.getBoundingClientRect();const x=e.clientX-left;const y=e.clientY-top;addDebugBlockToPoint({x,y});}closeDebugMenu();stopFishing();};})();start();window.onresize=()=>{resetSize();};const PERLIN_VECTORS={BIOME:Symbol("BIOME"),BLOCK:Symbol("BLOCK"),};const getValue=(()=>{const PERLIN_CONFIG={noiseResolutionBiome:75,noiseResolution:10,};const getSizeFromNoise=(size,resolution)=>{const numVectorsX=Math.floor(size/resolution)+1;const extraVectorX=size%resolution==0?0:1;return numVectorsX+extraVectorX;};const initializeVector=(vector)=>{return{width:getSizeFromNoise(vector.width,vector.resolution),height:getSizeFromNoise(vector.height,vector.resolution),vectors:[],resolution:vector.resolution,};};const vectors=({[PERLIN_VECTORS.BIOME]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolutionBiome,}),[PERLIN_VECTORS.BLOCK]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolution,}),});const updateVector=(i,j,vector)=>{const offsetPos=getChunkStart({i,j},vector.height,vector.width);for(let i=0;i<=vector.height-1;i++){const nI=i+offsetPos.i;vector.vectors[nI]=vector.vectors[nI]||[];for(let j=0;j<=vector.width-1;j++){const nJ=j+offsetPos.j;vector.vectors[nI][nJ]=getRandUnitVect();}}};const getRandUnitVect=()=>{const theta=Math.random()*2*Math.PI;return{x:Math.cos(theta),y:Math.sin(theta)};};const dotProduct=(vector,x,y,vx,vy)=>{if(!vector.vectors[vy]?.[vx])updateVector(vy,vx,vector);return dot({x:x-vx,y:y-vy},vector.vectors[vy][vx]);};const dot=(v1,v2)=>v1.x*v2.x+v1.y*v2.y;const lerp=(a,b,c)=>a+smootherstep(c)*(b-a);const smootherstep=(x)=>6*x**5-15*x**4+10*x**3;return(i,j,vectorType)=>{const vector=vectors[vectorType];const offset=0.5/vector.resolution;const x=i/vector.resolution+offset;const y=j/vector.resolution+offset;const xF=Math.floor(x);const yF=Math.floor(y);const tlv=dotProduct(vector,x,y,xF,yF);const trv=dotProduct(vector,x,y,xF+1,yF);const blv=dotProduct(vector,x,y,xF,yF+1);const brv=dotProduct(vector,x,y,xF+1,yF+1);const lerpTop=lerp(tlv,trv,x-xF);const lerpBottom=lerp(blv,brv,x-xF);const value=lerp(lerpTop,lerpBottom,y-yF);return value;};})();const DRAW_CONFIG={lightDepth:2,maxLayer:2,fluidSpeed:500,};const RENDER_CONFIG={selectedBorderColor:"white",borderColor:"black",emptyColor:"black",lineWidth:1,wallDarkness:0.5,};const PERLIN_VECTORS={BIOME:Symbol("BIOME"),BLOCK:Symbol("BLOCK"),};const getValue=(()=>{const PERLIN_CONFIG={noiseResolutionBiome:75,noiseResolution:10,};const getSizeFromNoise=(size,resolution)=>{const numVectorsX=Math.floor(size/resolution)+1;const extraVectorX=size%resolution==0?0:1;return numVectorsX+extraVectorX;};const initializeVector=(vector)=>{return{width:getSizeFromNoise(vector.width,vector.resolution),height:getSizeFromNoise(vector.height,vector.resolution),vectors:[],resolution:vector.resolution,};};const vectors=({[PERLIN_VECTORS.BIOME]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolutionBiome,}),[PERLIN_VECTORS.BLOCK]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolution,}),});const updateVector=(i,j,vector)=>{const offsetPos=getChunkStart({i,j},vector.height,vector.width);for(let i=0;i<=vector.height-1;i++){const nI=i+offsetPos.i;vector.vectors[nI]=vector.vectors[nI]||[];for(let j=0;j<=vector.width-1;j++){const nJ=j+offsetPos.j;vector.vectors[nI][nJ]=getRandUnitVect();}}};const getRandUnitVect=()=>{const theta=Math.random()*2*Math.PI;return{x:Math.cos(theta),y:Math.sin(theta)};};const dotProduct=(vector,x,y,vx,vy)=>{if(!vector.vectors[vy]?.[vx])updateVector(vy,vx,vector);return dot({x:x-vx,y:y-vy},vector.vectors[vy][vx]);};const dot=(v1,v2)=>v1.x*v2.x+v1.y*v2.y;const lerp=(a,b,c)=>a+smootherstep(c)*(b-a);const smootherstep=(x)=>6*x**5-15*x**4+10*x**3;return(i,j,vectorType)=>{const vector=vectors[vectorType];const offset=0.5/vector.resolution;const x=i/vector.resolution+offset;const y=j/vector.resolution+offset;const xF=Math.floor(x);const yF=Math.floor(y);const tlv=dotProduct(vector,x,y,xF,yF);const trv=dotProduct(vector,x,y,xF+1,yF);const blv=dotProduct(vector,x,y,xF,yF+1);const brv=dotProduct(vector,x,y,xF+1,yF+1);const lerpTop=lerp(tlv,trv,x-xF);const lerpBottom=lerp(blv,brv,x-xF);const value=lerp(lerpTop,lerpBottom,y-yF);return value;};})();const blockToWall=(block,point,wallParams={},polyInfo)=>{polyInfo=polyInfo||getPolyInfo();const points=wallParams.isInverted?polyInfo.invertedPoints:polyInfo.points;const layer=wallParams.layer||0;const wallLayer=layer+1;const wallPoints=wallParams.isInverted?polyInfo.wallInvertedPoints:polyInfo.wallPoints;const commonInfos={color:block.color,pos:wallParams.pos,isInverted:wallParams.isInverted,isSelectedCell:wallParams.isSelectedCell,};return{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*layer},points:wallPoints,topInfo:{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*wallLayer},points,modifier:wallParams.modifier,},borderMap:wallParams.borderMap,modifier:wallParams.modifier*RENDER_CONFIG.wallDarkness,};};const DRAW_CONFIG={lightDepth:2,maxLayer:2,fluidSpeed:500,};const RENDER_CONFIG={selectedBorderColor:"white",borderColor:"black",emptyColor:"black",lineWidth:1,wallDarkness:0.5,};const drawContainer=document.getElementById("draw-container");const canvasContainer=document.getElementById("canvas-container");const blockToWall=(block,point,wallParams={},polyInfo)=>{polyInfo=polyInfo||getPolyInfo();const points=wallParams.isInverted?polyInfo.invertedPoints:polyInfo.points;const layer=wallParams.layer||0;const wallLayer=layer+1;const wallPoints=wallParams.isInverted?polyInfo.wallInvertedPoints:polyInfo.wallPoints;const commonInfos={color:block.color,pos:wallParams.pos,isInverted:wallParams.isInverted,isSelectedCell:wallParams.isSelectedCell,};return{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*layer},points:wallPoints,topInfo:{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*wallLayer},points,modifier:wallParams.modifier,},borderMap:wallParams.borderMap,modifier:wallParams.modifier*RENDER_CONFIG.wallDarkness,};};const drawContainer=document.getElementById("draw-container");const canvasContainer=document.getElementById("canvas-container");const resetCanvas=()=>{const polyInfo=getPolyInfo();setCanvasSize(polyInfo.canvasHeight,polyInfo.canvasWidth);setFavicon();};const updateCanvasCss=()=>{updateConfigs();updateWeather();updateWidgets();};let filledThisRound=(new Set());let tracksCount=({});const addToTrackCount=(block)=>{if(block?.trackType)tracksCount[block.trackType]=(tracksCount[block.trackType]||0)+1;};const getAjacentCells=(cell,depth=1)=>{const result=[[cell]];for(let index=0;index<depth;index++){const cells=([]);const current=result[index];for(const element of current){if(!element)continue;const aCells=element.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);cells.push(...aCells.filter((c)=>!current.includes(c)&&!cells.includes(c)&&c!==cell));}result.push(cells);}return result;};const drawEveryCell=(baseEntity)=>{wallLayers=[];fluids=[];filledThisRound=new Set();tracksCount={};const offsetCell=baseEntity.cell.pos.j%2;const{rows,columns,shouldIntercalate}=getPolyInfo();const size=rows+columns;const adjacentCells=getAjacentCells(baseEntity.cell,DRAW_CONFIG.lightDepth);const selectedCell=getSelectedCell(baseEntity);for(let i=-columns;i<size;i++){const baseI=i+RENDER_INFO.iOffset;for(let j=-rows;j<size;j++){let nI=baseI;const nJ=j+RENDER_INFO.jOffset;const pos={i:nI,j:nJ};if(shouldIntercalate&&offsetCell&&nJ%2===0)nI=nI+1;drawCell(loadAndGetCell(pos),contextsLayers[0],baseEntity,adjacentCells,selectedCell);}}drawWalls();updateEntities();tweakFluids();updateBiomeMap();updateTracks(tracksCount);};let wallLayers=([]);const drawWalls=()=>{for(let i=1;i<DRAW_CONFIG.maxLayer;i++){const walls=wallLayers[i];clearCanvas(canvasLayers[i]);if(!walls)continue;walls.forEach((w)=>drawWall(w,contextsLayers[i]));walls.forEach((w)=>drawWallTop(w,contextsLayers[i]));}wallLayers=[];};let fluidInterval=null;let fluids=([]);const tweakFluids=debounce(()=>{clearInterval(fluidInterval);if(!fluids.length)return;const context=contextsLayers[0];fluidInterval=setInterval(()=>{fluids.forEach((fluid)=>{drawItem(context,{...fluid,color:tweakColor(fluid.color),});});},DRAW_CONFIG.fluidSpeed);},DRAW_CONFIG.fluidSpeed);const drawCell=(cell,context,baseEntity,adjacentCells,selectedCell)=>{const polyInfo=getPolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const point=calculatePointBasedOnPos(cell.pos,isInverted,baseEntity.cell);if(isPointOutside(point,polyInfo.canvasHeight,polyInfo.canvasWidth))return;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const aCells=cell.adjacentPos[RENDER_INFO.currentPoly].map(getCell);const isSelectedCell=MENU_CONFIG.showSelectedCell&&cell===selectedCell;cell.modifier=getStyleModifier(adjacentCells.findIndex((c)=>c.includes(cell)));addToTrackCount(cell.wall?.block||cell.block);if(cell.wall){const wallLayer=cell.layer+1;const shouldOffset=polyInfo.hasInverted&&!cell.isInverted;if(!wallLayers[wallLayer])wallLayers[wallLayer]=[];wallLayers[wallLayer].push(blockToWall(cell.wall,point,{layer:cell.layer,isInverted,modifier:cell.modifier,isSelectedCell,pos:cell.pos,borderMap:aCells.reduce((acc,c,i)=>{let index=i-RENDER_INFO.rotationTurns;if(shouldOffset)index=RENDER_INFO.currentPoly-1-index;acc[getMod(index,RENDER_INFO.currentPoly)]=!c?.wall;return acc;},[]),}));return;}if(!cell.block){const aFluid=aCells.find((c)=>c?.block?.isFluid);if(aFluid&&!filledThisRound.has(aFluid.pos)){filledThisRound.add(cell.pos);cell.block=aFluid.block;cell.color=aFluid.color;}}const drawable=({point,points,isInverted,pos:cell.pos,color:cell.color,modifier:cell.modifier,isSelectedCell,});if(cell.block?.isFluid)fluids.push(drawable);drawItem(context,drawable);if(cell.block===MINE_BLOCKS.MINES_LOW){const aCellsCorner=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);showMineValue(context,aCellsCorner.reduce((acc,c)=>(c.hasBomb?acc+1:acc),0),point,isInverted,polyInfo.ySide);}};const drawCircleOnCell=(cell,baseEntity)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(cell.pos,hasInverted&&cell.isInverted,baseEntity.cell);drawCircle(contextsLayers[0],point,ySide/4);};const resetCanvas=()=>{const polyInfo=getPolyInfo();setCanvasSize(polyInfo.canvasHeight,polyInfo.canvasWidth);setFavicon();};const updateCanvasCss=()=>{updateConfigs();updateWeather();updateWidgets();};let filledThisRound=(new Set());let tracksCount=({});const addToTrackCount=(block)=>{if(block?.trackType)tracksCount[block.trackType]=(tracksCount[block.trackType]||0)+1;};const getAjacentCells=(cell,depth=1)=>{const result=[[cell]];for(let index=0;index<depth;index++){const cells=([]);const current=result[index];for(const element of current){if(!element)continue;const aCells=element.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);cells.push(...aCells.filter((c)=>!current.includes(c)&&!cells.includes(c)&&c!==cell));}result.push(cells);}return result;};const drawEveryCell=(baseEntity)=>{wallLayers=[];fluids=[];filledThisRound=new Set();tracksCount={};const offsetCell=baseEntity.cell.pos.j%2;const{rows,columns,shouldIntercalate}=getPolyInfo();const size=rows+columns;const adjacentCells=getAjacentCells(baseEntity.cell,DRAW_CONFIG.lightDepth);const selectedCell=getSelectedCell(baseEntity);for(let i=-columns;i<size;i++){const baseI=i+RENDER_INFO.iOffset;for(let j=-rows;j<size;j++){let nI=baseI;const nJ=j+RENDER_INFO.jOffset;const pos={i:nI,j:nJ};if(shouldIntercalate&&offsetCell&&nJ%2===0)nI=nI+1;drawCell(loadAndGetCell(pos),contextsLayers[0],baseEntity,adjacentCells,selectedCell);}}drawWalls();updateEntities();tweakFluids();updateBiomeMap();updateTracks(tracksCount);};let wallLayers=([]);const drawWalls=()=>{for(let i=1;i<DRAW_CONFIG.maxLayer;i++){const walls=wallLayers[i];clearCanvas(canvasLayers[i]);if(!walls)continue;walls.forEach((w)=>drawWall(w,contextsLayers[i]));walls.forEach((w)=>drawWallTop(w,contextsLayers[i]));}wallLayers=[];};let fluidInterval=null;let fluids=([]);const tweakFluids=debounce(()=>{clearInterval(fluidInterval);if(!fluids.length)return;const context=contextsLayers[0];fluidInterval=setInterval(()=>{fluids.forEach((fluid)=>{drawItem(context,{...fluid,color:tweakColor(fluid.color),});});},DRAW_CONFIG.fluidSpeed);},DRAW_CONFIG.fluidSpeed);const drawCell=(cell,context,baseEntity,adjacentCells,selectedCell)=>{const polyInfo=getPolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const point=calculatePointBasedOnPos(cell.pos,isInverted,baseEntity.cell);if(isPointOutside(point,polyInfo.canvasHeight,polyInfo.canvasWidth))return;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const aCells=cell.adjacentPos[RENDER_INFO.currentPoly].map(getCell);const isSelectedCell=MENU_CONFIG.showSelectedCell&&cell===selectedCell;cell.modifier=getStyleModifier(adjacentCells.findIndex((c)=>c.includes(cell)));addToTrackCount(cell.wall?.block||cell.block);if(cell.wall){const wallLayer=cell.layer+1;const shouldOffset=polyInfo.hasInverted&&!cell.isInverted;if(!wallLayers[wallLayer])wallLayers[wallLayer]=[];wallLayers[wallLayer].push(blockToWall(cell.wall,point,{layer:cell.layer,isInverted,modifier:cell.modifier,isSelectedCell,pos:cell.pos,borderMap:aCells.reduce((acc,c,i)=>{let index=i-RENDER_INFO.rotationTurns;if(shouldOffset)index=RENDER_INFO.currentPoly-1-index;acc[getMod(index,RENDER_INFO.currentPoly)]=!c?.wall;return acc;},[]),}));return;}if(!cell.block){const aFluid=aCells.find((c)=>c?.block?.isFluid);if(aFluid&&!filledThisRound.has(aFluid.pos)){filledThisRound.add(cell.pos);cell.block=aFluid.block;cell.color=aFluid.color;}}const drawable=({point,points,isInverted,pos:cell.pos,color:cell.color,modifier:cell.modifier,isSelectedCell,});if(cell.block?.isFluid)fluids.push(drawable);drawItem(context,drawable);if(cell.block===MINE_BLOCKS.MINES_LOW){const aCellsCorner=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);showMineValue(context,aCellsCorner.reduce((acc,c)=>(c.hasBomb?acc+1:acc),0),point,isInverted,polyInfo.ySide);}};const drawCircleOnCell=(cell,baseEntity)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(cell.pos,hasInverted&&cell.isInverted,baseEntity.cell);drawCircle(contextsLayers[0],point,ySide/4);};const MAZE_CANVAS_CONFIG={defaultColor:"#cdcdcd",};const drawMaze=(context,mazeObj)=>{for(const pos of mazeObj.iterateOverMaze()){drawCellMaze(context,mazeObj,mazeObj.getMazeCell(pos));}};const drawCellMaze=(context,mazeObj,cell,color)=>{context.fillStyle=color?getFillStyle(color):MAZE_CANVAS_CONFIG.defaultColor;if(cell.circleProps)drawCellMazeCircle(context,cell,mazeObj.getCirclePoint());else drawCellMazePolygon(context,mazeObj,cell);};const drawCellMazePolygon=(context,mazeObj,cell)=>{const polyInfo=mazeObj.getMazePolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const borders=polyInfo.hasInverted&&!cell.isInverted?cell.invertedBorders:cell.borders;fillPolygon(context,cell.point,points);applyBorders(context,cell.point,points,borders);if(MENU_CONFIG.showPos&&cell.pos)showPos(context,cell.pos,cell.point,isInverted,polyInfo.ySide);};const drawCellMazeCircle=(context,cell,circlePoint)=>{const{topRadius,bottomRadius,topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,}=cell.circleProps;context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.closePath();context.fill();if(cell.borders[0]){context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.stroke();}if(cell.borders[1]){context.beginPath();context.moveTo(topRightPoint.x,topRightPoint.y);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.stroke();}if(cell.borders[2]){context.beginPath();context.moveTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.stroke();}if(cell.borders[3]){context.beginPath();context.moveTo(bottomLeftPoint.x,bottomLeftPoint.y);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.stroke();}};const MAZE_CANVAS_CONFIG={defaultColor:"#cdcdcd",};const drawMaze=(context,mazeObj)=>{for(const pos of mazeObj.iterateOverMaze()){drawCellMaze(context,mazeObj,mazeObj.getMazeCell(pos));}};const drawCellMaze=(context,mazeObj,cell,color)=>{context.fillStyle=color?getFillStyle(color):MAZE_CANVAS_CONFIG.defaultColor;if(cell.circleProps)drawCellMazeCircle(context,cell,mazeObj.getCirclePoint());else drawCellMazePolygon(context,mazeObj,cell);};const drawCellMazePolygon=(context,mazeObj,cell)=>{const polyInfo=mazeObj.getMazePolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const borders=polyInfo.hasInverted&&!cell.isInverted?cell.invertedBorders:cell.borders;fillPolygon(context,cell.point,points);applyBorders(context,cell.point,points,borders);if(MENU_CONFIG.showPos&&cell.pos)showPos(context,cell.pos,cell.point,isInverted,polyInfo.ySide);};const drawCellMazeCircle=(context,cell,circlePoint)=>{const{topRadius,bottomRadius,topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,}=cell.circleProps;context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.closePath();context.fill();if(cell.borders[0]){context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.stroke();}if(cell.borders[1]){context.beginPath();context.moveTo(topRightPoint.x,topRightPoint.y);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.stroke();}if(cell.borders[2]){context.beginPath();context.moveTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.stroke();}if(cell.borders[3]){context.beginPath();context.moveTo(bottomLeftPoint.x,bottomLeftPoint.y);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.stroke();}};const canvasLayers =([]);const contextsLayers =([]);for (let i =0;i <DRAW_CONFIG.maxLayer;i++){const canvas =document.createElement("canvas");canvasContainer.appendChild(canvas);canvasLayers.push(canvas);contextsLayers.push(canvas.getContext("2d"));}const setCanvasSize =(height,width)=>{drawContainer.style.setProperty("--canvas-height",`${height}px`);canvasLayers.forEach((canvas)=>(canvas.height =height));drawContainer.style.setProperty("--canvas-width",`${width}px`);canvasLayers.forEach((canvas)=>(canvas.width =width));};const setFavicon =()=>{const link =(document.querySelector("link[rel~='icon']"));link.href=POLYGONS_IMAGES[RENDER_INFO.currentPoly];};const updateConfigs=()=>{canvasContainer.classList[MENU_CONFIG.usePerspective?"add":"remove"]("perspective");};const clearCanvas=(canvas)=>{canvas.width=canvas.width;};const drawWall=(wall,context)=>{if(!wall.borderMap||wall.borderMap.find((b)=>!!b))drawItem(context,wall);};const drawWallTop=(wall,context)=>{drawItem(context,wall.topInfo);context.strokeStyle=wall.isSelectedCell?RENDER_CONFIG.selectedBorderColor:RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,wall.topInfo.point,wall.topInfo.points,wall.borderMap);};const drawItem=(context,{point,points,pos,isInverted,color,modifier,isSelectedCell})=>{context.fillStyle=color?getFillStyle(color,modifier):RENDER_CONFIG.emptyColor;fillPolygon(context,point,points);if(MENU_CONFIG.showPos&&pos)showPos(context,pos,point,isInverted,getPolyInfo().ySide);if(isSelectedCell){context.strokeStyle=RENDER_CONFIG.selectedBorderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}else if(MENU_CONFIG.showChunks&&pos)showChunks(context,pos,point,points);};const getFillStyle=(color,modifier=1)=>color===EMPTY_BLOCK.color?"transparent":`rgb(`+`${color.r *modifier},`+`${color.g *modifier},`+`${color.b *modifier})`;const getStyleModifier=(intensity)=>{if(!ENTITY_INFO.timeOfDay)return 1;let modifier=1-ENTITY_INFO.timeOfDay/100;if(intensity>=0)modifier=(1-modifier)/(intensity||1)+modifier;return modifier;};const fillPolygon=(context,{x,y},points)=>{context.beginPath();for(const point of points){context.lineTo(x+point.x,y+point.y);}context.closePath();context.fill();};const applyBorders=(context,{x,y},points,map,ignoreLast)=>{for(let i=0;i<points.length;i++){if(!map?.length||map[i]){const point=points[i];let nextPoint=points[i+1];if(!nextPoint){if(ignoreLast)return;nextPoint=points[0];}const pointA={x:x+point.x,y:y+point.y};const pointB={x:x+nextPoint.x,y:y+nextPoint.y};drawLine(context,pointA,pointB);}}};const drawLine=(context,pointA,pointB)=>{context.beginPath();context.moveTo(pointA.x,pointA.y);context.lineTo(pointB.x,pointB.y);context.stroke();};const showPos=(context,pos,point,isInverted,ySide)=>{context.fillStyle="black";context.font=`bold ${ySide /2}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${pos.i},${pos.j}`,point.x,isInverted?point.y+ySide/2:point.y);};const showChunks=(context,pos,point,points)=>{if(pos.i%GENERATION_CONFIG.chunkSize===0||pos.j%GENERATION_CONFIG.chunkSize===0){context.strokeStyle=RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}};const mineValueColors=["blue","green","red","darkblue","brown","darkred","black","grey",];const showMineValue=(context,value,point,isInverted,ySide)=>{if(value){context.fillStyle=mineValueColors[value-1];context.font=`bold ${ySide}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${value}`,point.x,isInverted?point.y+ySide/2:point.y);}};const drawCircle=(context,point,radius)=>{context.beginPath();context.arc(point.x,point.y,radius,0,2*Math.PI);context.fillStyle="black";context.fill();};const canvasLayers =([]);const contextsLayers =([]);for (let i =0;i <DRAW_CONFIG.maxLayer;i++){const canvas =document.createElement("canvas");canvasContainer.appendChild(canvas);canvasLayers.push(canvas);contextsLayers.push(canvas.getContext("2d"));}const setCanvasSize =(height,width)=>{drawContainer.style.setProperty("--canvas-height",`${height}px`);canvasLayers.forEach((canvas)=>(canvas.height =height));drawContainer.style.setProperty("--canvas-width",`${width}px`);canvasLayers.forEach((canvas)=>(canvas.width =width));};const setFavicon =()=>{const link =(document.querySelector("link[rel~='icon']"));link.href=POLYGONS_IMAGES[RENDER_INFO.currentPoly];};const updateConfigs=()=>{canvasContainer.classList[MENU_CONFIG.usePerspective?"add":"remove"]("perspective");};const clearCanvas=(canvas)=>{canvas.width=canvas.width;};const drawWall=(wall,context)=>{if(!wall.borderMap||wall.borderMap.find((b)=>!!b))drawItem(context,wall);};const drawWallTop=(wall,context)=>{drawItem(context,wall.topInfo);context.strokeStyle=wall.isSelectedCell?RENDER_CONFIG.selectedBorderColor:RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,wall.topInfo.point,wall.topInfo.points,wall.borderMap);};const drawItem=(context,{point,points,pos,isInverted,color,modifier,isSelectedCell})=>{context.fillStyle=color?getFillStyle(color,modifier):RENDER_CONFIG.emptyColor;fillPolygon(context,point,points);if(MENU_CONFIG.showPos&&pos)showPos(context,pos,point,isInverted,getPolyInfo().ySide);if(isSelectedCell){context.strokeStyle=RENDER_CONFIG.selectedBorderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}else if(MENU_CONFIG.showChunks&&pos)showChunks(context,pos,point,points);};const getFillStyle=(color,modifier=1)=>color===EMPTY_BLOCK.color?"transparent":`rgb(`+`${color.r *modifier},`+`${color.g *modifier},`+`${color.b *modifier})`;const getStyleModifier=(intensity)=>{if(!ENTITY_INFO.timeOfDay)return 1;let modifier=1-ENTITY_INFO.timeOfDay/100;if(intensity>=0)modifier=(1-modifier)/(intensity||1)+modifier;return modifier;};const fillPolygon=(context,{x,y},points)=>{context.beginPath();for(const point of points){context.lineTo(x+point.x,y+point.y);}context.closePath();context.fill();};const applyBorders=(context,{x,y},points,map,ignoreLast)=>{for(let i=0;i<points.length;i++){if(!map?.length||map[i]){const point=points[i];let nextPoint=points[i+1];if(!nextPoint){if(ignoreLast)return;nextPoint=points[0];}const pointA={x:x+point.x,y:y+point.y};const pointB={x:x+nextPoint.x,y:y+nextPoint.y};drawLine(context,pointA,pointB);}}};const drawLine=(context,pointA,pointB)=>{context.beginPath();context.moveTo(pointA.x,pointA.y);context.lineTo(pointB.x,pointB.y);context.stroke();};const showPos=(context,pos,point,isInverted,ySide)=>{context.fillStyle="black";context.font=`bold ${ySide /2}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${pos.i},${pos.j}`,point.x,isInverted?point.y+ySide/2:point.y);};const showChunks=(context,pos,point,points)=>{if(pos.i%GENERATION_CONFIG.chunkSize===0||pos.j%GENERATION_CONFIG.chunkSize===0){context.strokeStyle=RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}};const mineValueColors=["blue","green","red","darkblue","brown","darkred","black","grey",];const showMineValue=(context,value,point,isInverted,ySide)=>{if(value){context.fillStyle=mineValueColors[value-1];context.font=`bold ${ySide}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${value}`,point.x,isInverted?point.y+ySide/2:point.y);}};const drawCircle=(context,point,radius)=>{context.beginPath();context.arc(point.x,point.y,radius,0,2*Math.PI);context.fillStyle="black";context.fill();};const audios=({});let MUSIC_VOLUME=1;const TRACK_FILES={[TRACK_TYPES.TRACK1]:"sounds/blocks/track1.wav",[TRACK_TYPES.TRACK2]:"sounds/blocks/track2.wav",[TRACK_TYPES.TRACK3]:"sounds/blocks/track3.wav",[TRACK_TYPES.TRACK4]:"sounds/blocks/track4.wav",[TRACK_TYPES.TRACK5]:"sounds/blocks/track5.wav",[TRACK_TYPES.TRACK6]:"sounds/blocks/track6.wav",[TRACK_TYPES.TRACK7]:"sounds/blocks/track7.wav",[TRACK_TYPES.TRACK8]:"sounds/blocks/track8.wav",[TRACK_TYPES.TRACK11]:"sounds/blocks/track11.wav",[TRACK_TYPES.TRACK14]:"sounds/blocks/track14.wav",[TRACK_TYPES.TRACK15]:"sounds/blocks/track15.wav",[TRACK_TYPES.TRACK16]:"sounds/blocks/track16.wav",};Object.entries(TRACK_FILES).forEach(([track,path])=>{const pan=+track.replace("TRACK","")%2?-1:1;const ctx=new AudioContext();const srcNode=ctx.createBufferSource();const gainNode=ctx.createGain();gainNode.gain.value=0;gainNode.connect(ctx.destination);const ambientPan=ctx.createStereoPanner();ambientPan.pan.value=pan;ambientPan.connect(gainNode);audios[track]={srcNode,gainNode,volume:0};fetch(path,{mode:"cors"}).then((resp)=>resp.arrayBuffer()).then((buffer)=>ctx.decodeAudioData(buffer,(abuffer)=>{srcNode.buffer=abuffer;srcNode.connect(ambientPan);srcNode.loop=true;srcNode.loopEnd=35.99;}));});const audiosList=Object.values(audios);const TRACK_LIST=Object.keys(TRACK_FILES);let audioStarted=false;const updateTracks=(tracksCount)=>{if(MENU_CONFIG.music){const polyInfo=getPolyInfo();const max=polyInfo.rows*polyInfo.columns*1.2;TRACK_LIST.forEach((track)=>{const audio=audios[track];audio.volume=(tracksCount[track]||0)/max;updateTrackVolume(audio);if(!audioStarted)audio.srcNode.start();});audioStarted=true;}else{audiosList.forEach((a)=>(a.gainNode.gain.value=0));}};const setMusicVolume=(volume)=>{MUSIC_VOLUME=volume;TRACK_LIST.forEach((track)=>updateTrackVolume(audios[track]));};const updateTrackVolume=(audio)=>{const{gainNode,volume}=audio;gainNode.gain.value=(MUSIC_VOLUME*volume)/100;};const audios=({});let MUSIC_VOLUME=1;const TRACK_FILES={[TRACK_TYPES.TRACK1]:"sounds/blocks/track1.wav",[TRACK_TYPES.TRACK2]:"sounds/blocks/track2.wav",[TRACK_TYPES.TRACK3]:"sounds/blocks/track3.wav",[TRACK_TYPES.TRACK4]:"sounds/blocks/track4.wav",[TRACK_TYPES.TRACK5]:"sounds/blocks/track5.wav",[TRACK_TYPES.TRACK6]:"sounds/blocks/track6.wav",[TRACK_TYPES.TRACK7]:"sounds/blocks/track7.wav",[TRACK_TYPES.TRACK8]:"sounds/blocks/track8.wav",[TRACK_TYPES.TRACK11]:"sounds/blocks/track11.wav",[TRACK_TYPES.TRACK14]:"sounds/blocks/track14.wav",[TRACK_TYPES.TRACK15]:"sounds/blocks/track15.wav",[TRACK_TYPES.TRACK16]:"sounds/blocks/track16.wav",};Object.entries(TRACK_FILES).forEach(([track,path])=>{const pan=+track.replace("TRACK","")%2?-1:1;const ctx=new AudioContext();const srcNode=ctx.createBufferSource();const gainNode=ctx.createGain();gainNode.gain.value=0;gainNode.connect(ctx.destination);const ambientPan=ctx.createStereoPanner();ambientPan.pan.value=pan;ambientPan.connect(gainNode);audios[track]={srcNode,gainNode,volume:0};fetch(path,{mode:"cors"}).then((resp)=>resp.arrayBuffer()).then((buffer)=>ctx.decodeAudioData(buffer,(abuffer)=>{srcNode.buffer=abuffer;srcNode.connect(ambientPan);srcNode.loop=true;srcNode.loopEnd=35.99;}));});const audiosList=Object.values(audios);const TRACK_LIST=Object.keys(TRACK_FILES);let audioStarted=false;const updateTracks=(tracksCount)=>{if(MENU_CONFIG.music){const polyInfo=getPolyInfo();const max=polyInfo.rows*polyInfo.columns*1.2;TRACK_LIST.forEach((track)=>{const audio=audios[track];audio.volume=(tracksCount[track]||0)/max;updateTrackVolume(audio);if(!audioStarted)audio.srcNode.start();});audioStarted=true;}else{audiosList.forEach((a)=>(a.gainNode.gain.value=0));}};const setMusicVolume=(volume)=>{MUSIC_VOLUME=volume;TRACK_LIST.forEach((track)=>updateTrackVolume(audios[track]));};const updateTrackVolume=(audio)=>{const{gainNode,volume}=audio;gainNode.gain.value=(MUSIC_VOLUME*volume)/100;};const createMazeObj=(mazeInfos,mazeCircleInfos)=>{let MAZE_GRID=([]);const MAZE_POLYS_INFO=({});const getMazePolyInfo=()=>MAZE_POLYS_INFO[RENDER_INFO.currentPoly];const CIRCLE_INFO=({cellHeight:0,center:null,rows:0,columns:0,});const MAZE_INFO=({rows:0,columns:0,isCircle:false,currentCell:null,queue:[],});const getMazeCell=({i,j})=>MAZE_GRID[i]?.[j];function*iterateOverMaze(){const rows=getMazeRows();for(let i=0;i<rows;i++){const numCells=getNumCellsPerMazeRow(i);for(let j=0;j<numCells;j++){yield{i,j};}}}const createMazeGrid=()=>{MAZE_GRID=[];for(const{i,j}of iterateOverMaze()){MAZE_GRID[i]=MAZE_GRID[i]||[];MAZE_GRID[i][j]=createCellMaze({i,j});}};const createCellMaze=(pos)=>{const cell=(createCellProps(pos));cell.visited=false;cell.solved=false;cell.path=false;cell.borders=[...new Array(RENDER_INFO.currentPoly)].map(()=>true);if(MAZE_INFO.isCircle)createCircleCellMaze(cell);else cell.point=calculateMazePoint(pos);return cell;};const calculateMazePoint=({i,j})=>{const{calcX,calcY,ySide,shouldIntercalate}=getMazePolyInfo();const x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=ySide;return{x,y};};const getMazeRows=()=>MAZE_INFO.isCircle?CIRCLE_INFO.rows:MAZE_INFO.rows;const getNumCellsPerMazeRow=(rowIndex)=>MAZE_INFO.isCircle?CIRCLE_INFO.columns-Math.floor((rowIndex+1)/2):MAZE_INFO.columns;const createCircleCellMaze=(cell)=>{const{i,j}=cell.pos;const topRadius=(CIRCLE_INFO.rows-i)*CIRCLE_INFO.cellHeight;const bottomRadius=topRadius-CIRCLE_INFO.cellHeight;const topAngle=Math.atan2(-topRadius,0);const bottomAngle=bottomRadius?topAngle:0;const numCells=getNumCellsPerMazeRow(i);const parts=(Math.PI*1.5-topAngle)/numCells;const leftBorder=j*parts;const rightBorder=(j+1)*parts;const topLeftAngle=topAngle+leftBorder;const topRightAngle=topAngle+rightBorder;const bottomLeftAngle=bottomAngle+leftBorder;const bottomRightAngle=bottomAngle+rightBorder;const topLeftPoint=getMazePoint(topRadius,topLeftAngle);const topRightPoint=getMazePoint(topRadius,topRightAngle);const bottomLeftPoint=getMazePoint(bottomRadius,bottomLeftAngle);const bottomRightPoint=getMazePoint(bottomRadius,bottomRightAngle);const points=[getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topLeftAngle),getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topRightAngle),];const x=points.reduce((acc,p)=>acc+p.x,0)/points.length;const y=points.reduce((acc,p)=>acc+p.y,0)/points.length;cell.point={x,y};cell.circleProps={topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topRadius,bottomRadius,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,adjacentPos:cell.adjacentPos[KNOWN_POLYGONS.SQUARE].map((aPos)=>({i:aPos.i,j:aPos.j<0?numCells-1:aPos.j>=numCells?0:aPos.j,})),};};const getMazePoint=(radius,angle)=>({x:CIRCLE_INFO.center.x+Math.cos(angle)*radius,y:CIRCLE_INFO.center.y+Math.sin(angle)*radius,});const buildMaze=()=>{createMazeGrid();MAZE_INFO.queue=[];MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);const lastCell=getLastMazeCell();while(MAZE_INFO.currentCell)MAZE_INFO.currentCell=buildCellMaze(MAZE_INFO.currentCell,lastCell);if(!MAZE_INFO.isCircle&&lastCell){openBorderForCellMaze(lastCell,getMazeCell(getAdjPos(lastCell)[0]));lastCell.visited=true;}if(!MAZE_INFO.isCircle&&getMazePolyInfo().hasInverted){for(const pos of iterateOverMaze()){const cell=getMazeCell(pos);cell.invertedBorders=[...cell.borders].reverse();}}MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const openBorderForCellMaze=(cell,nextCell)=>{const adjacentIndex=getNextCellMazeAdjacentIndex(cell,nextCell);const nextAdjacentIndex=getNextCellMazeAdjacentIndex(nextCell,cell);cell.borders[adjacentIndex]=false;nextCell.borders[nextAdjacentIndex]=false;};const buildCellMaze=(cell,lastCell)=>{cell.visited=true;const nextCell=getNextCellMaze(cell,(c)=>!!c&&!c.visited&&c!==lastCell,true);if(!nextCell)return null;openBorderForCellMaze(cell,nextCell);return nextCell;};const getLastMazeCell=()=>getMazeCell({i:MAZE_INFO.rows-1,j:MAZE_INFO.columns-1});const isMazeSolved=()=>!MAZE_INFO.currentCell||(MAZE_INFO.isCircle?MAZE_INFO.currentCell.pos.i===CIRCLE_INFO.rows-1:MAZE_INFO.currentCell===getLastMazeCell());const solveMaze=()=>{while(!isMazeSolved())MAZE_INFO.currentCell=solveCellMaze(MAZE_INFO.currentCell);solveCellMaze(MAZE_INFO.currentCell);MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const solveCellMaze=(cell)=>{if(!cell)return;cell.solved=true;cell.path=true;const prevLength=MAZE_INFO.queue.length;const nextCell=getNextCellMaze(cell,(c)=>{if(!c||c.solved)return false;const nextIndex=getNextCellMazeAdjacentIndex(cell,c);return!cell.borders[nextIndex];});if(prevLength>MAZE_INFO.queue.length)cell.path=false;return nextCell;};const getAdjPos=(cell)=>cell.circleProps?.adjacentPos||cell.adjacentPos[RENDER_INFO.currentPoly];const getNextCellMaze=(cell,cellFilter,isRandom=false)=>{const adjacentPos=getAdjPos(cell);const aCells=adjacentPos.map(getMazeCell).filter(cellFilter);if(!aCells.length){if(!MAZE_INFO.queue.length)return null;const prevPos=MAZE_INFO.queue.pop();return getMazeCell(prevPos);}MAZE_INFO.queue.push(cell.pos);return aCells[isRandom?getRandomInt(aCells.length):aCells.length-1];};const getNextCellMazeAdjacentIndex=(cell,nextCell)=>{let nextIndex=0;const adjacentPos=getAdjPos(cell);while(nextIndex<adjacentPos.length){const{i,j}=adjacentPos[nextIndex];if(nextCell.pos.i===i&&nextCell.pos.j===j)break;nextIndex++;}return nextIndex;};const mazeMove=(posIndex)=>{if(posIndex===undefined||MAZE_INFO.currentCell.borders[posIndex])return;const nextPos=getAdjPos(MAZE_INFO.currentCell)[posIndex];if(!nextPos)return;const nextCell=getMazeCell(nextPos);if(!nextCell)return;const oldCell=MAZE_INFO.currentCell;MAZE_INFO.currentCell=nextCell;const prevCell=MAZE_INFO.queue[MAZE_INFO.queue.length-1];if(nextCell.pos===prevCell){oldCell.path=false;MAZE_INFO.queue.pop();}else{oldCell.path=true;MAZE_INFO.queue.push(oldCell.pos);}return MAZE_INFO.currentCell;};const initMaze=()=>{for(const p of KNOWN_POLYGONS_VALUES){MAZE_POLYS_INFO[p]=configPoly(p,mazeInfos.cellHeight);}MAZE_INFO.rows=mazeInfos.rows;MAZE_INFO.columns=mazeInfos.columns;CIRCLE_INFO.cellHeight=mazeCircleInfos?.cellHeight||mazeInfos.cellHeight;CIRCLE_INFO.rows=mazeCircleInfos?.rows||MAZE_INFO.rows*2;CIRCLE_INFO.columns=mazeCircleInfos?.columns||MAZE_INFO.columns*2;const center=(CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2)/2;CIRCLE_INFO.center={x:center,y:center};};const getMazeSize=()=>{let{ySide,xSide,shouldIntercalate,hasInverted,polySide}=getMazePolyInfo();let height=MAZE_INFO.rows*mazeInfos.cellHeight;let width=MAZE_INFO.columns*(xSide*2);if(MAZE_INFO.isCircle)height=width=CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2;else{if(hasInverted)width=(MAZE_INFO.columns*polySide)/2+polySide/2+2;if(shouldIntercalate){height+=ySide;width=width*0.8;}}return{height,width};};const setIsCircle=(isCircle)=>{MAZE_INFO.isCircle=isCircle;if(MAZE_INFO.isCircle)RENDER_INFO.currentPoly=KNOWN_POLYGONS.SQUARE;};initMaze();return{getMazeSize,mazeMove,buildMaze,solveMaze,isMazeSolved,setIsCircle,getCirclePoint:()=>CIRCLE_INFO.center,iterateOverMaze,getMazeCell,getCurrentMazeCell:()=>MAZE_INFO.currentCell,getLastMazeCell,getMazePolyInfo,};};const fishingCanvas=(document.getElementById("fishing-canvas"));const fishingContext=fishingCanvas.getContext("2d");const fishingLineCanvas=(document.getElementById("fishing-line-canvas"));const fishingLineContext=fishingLineCanvas.getContext("2d");fishingLineContext.strokeStyle="black";const fishingContainer=document.getElementById("fishing-container");const fishingRodImg=(document.getElementById("fishing-rod"));const fishingRodPos=({i:8,j:0});const fishingFishImg=(document.getElementById("fishing-fish"));const fishingFishPos=({i:2,j:1});const FISHING_CONFIG={mazeSize:7,cellHeight:45,circleMazeSize:5,circleCellHeight:30,isCircleProbability:0.05,secondsToFish:20,timerDelay:100,timer:null,};let fishingMazeObj=(null);let IS_FISHING_ACTIVE=false;let FISHING_IS_CIRCLE=false;const setFishingCanvasSize=({height,width})=>{fishingLineCanvas.height=fishingCanvas.height=height;fishingLineCanvas.width=fishingCanvas.width=width;};const getFishingRodPoint=()=>FISHING_IS_CIRCLE?fishingMazeObj.getCirclePoint():fishingMazeObj.getLastMazeCell().point;const drawFishingLine=()=>{fishingLineCanvas.height=fishingLineCanvas.height;const fishPoint=fishingMazeObj.getCurrentMazeCell().point;const rodPoint=getFishingRodPoint();fishingLineContext.moveTo(fishPoint.x,fishPoint.y);fishingLineContext.lineTo(rodPoint.x,rodPoint.y);fishingLineContext.stroke();};const initFishingImages=()=>{const{ySide}=fishingMazeObj.getMazePolyInfo();setImagePos(fishingRodImg,fishingRodPos);setEntityImageSize(fishingRodImg,ySide);setImagePoint(fishingRodImg,getFishingRodPoint(),true,ySide);setImagePos(fishingFishImg,fishingFishPos);setEntityImageSize(fishingFishImg,ySide);setImagePoint(fishingFishImg,fishingMazeObj.getCurrentMazeCell().point,true,ySide);drawFishingLine();};const stopFishing=()=>{clearInterval(FISHING_CONFIG.timer);fishingContainer.classList.add("hide");IS_FISHING_ACTIVE=false;};const initFishingMazeObj=()=>{if(!fishingMazeObj)fishingMazeObj=createMazeObj({cellHeight:FISHING_CONFIG.cellHeight,rows:FISHING_CONFIG.mazeSize,columns:FISHING_CONFIG.mazeSize,},{cellHeight:FISHING_CONFIG.circleCellHeight,rows:FISHING_CONFIG.circleMazeSize,columns:FISHING_CONFIG.circleMazeSize,});fishingMazeObj.setIsCircle(FISHING_IS_CIRCLE);fishingMazeObj.buildMaze();};const initFishingTimer=(height)=>{fishingContainer.style.setProperty("--fishing-progress-bar-init-height",`${height}px`);fishingContainer.style.setProperty("--fishing-progress-bar-height",`${height}px`);let currentHeight=height;const timerSteps=height/((FISHING_CONFIG.secondsToFish*1000)/FISHING_CONFIG.timerDelay);FISHING_CONFIG.timer=setInterval(()=>{currentHeight-=timerSteps;fishingContainer.style.setProperty("--fishing-progress-bar-height",`${currentHeight}px`);if(currentHeight<=0){stopFishing();hurtEntity(PLAYER_ENTITY,1);}},FISHING_CONFIG.timerDelay);};let fishingFluidInterval=null;const initFishingDraw=(mazeObj)=>{clearInterval(fishingFluidInterval);const cells=([]);for(const pos of mazeObj.iterateOverMaze()){const cell=mazeObj.getMazeCell(pos);cells.push(cell);drawCellMaze(fishingContext,mazeObj,cell,tweakColor(BLOCKS.WATER.color));}if(!cells.length)return;fishingFluidInterval=setInterval(()=>{cells.forEach((c)=>drawCellMaze(fishingContext,mazeObj,c,tweakColor(BLOCKS.WATER.color)));},DRAW_CONFIG.fluidSpeed);};const startFishing=()=>{if(IS_FISHING_ACTIVE)return stopFishing();IS_FISHING_ACTIVE=true;FISHING_IS_CIRCLE=Math.random()<FISHING_CONFIG.isCircleProbability;initFishingMazeObj();const size=fishingMazeObj.getMazeSize();size.height+=FISHING_CONFIG.cellHeight/9;setFishingCanvasSize(size);initFishingImages();fishingContainer.classList.remove("hide");initFishingTimer(size.height);initFishingDraw(fishingMazeObj);};let canMoveFishing=true;const moveFishing=(code,useDiagonal)=>{if(canMoveFishing){const{ySide,hasInverted,polySides}=fishingMazeObj.getMazePolyInfo();const currentCell=fishingMazeObj.getCurrentMazeCell();const aIndex=getMovementMap(currentCell,useDiagonal,0,polySides,!FISHING_IS_CIRCLE&&hasInverted)[code];const nextCell=fishingMazeObj.mazeMove(aIndex);if(!nextCell)return;if(fishingMazeObj.isMazeSolved()){stopFishing();giveItemToEntity(PLAYER_ENTITY,{imgPos:fishingFishPos,health:1});return;}setImagePoint(fishingFishImg,nextCell.point,true,ySide);drawFishingLine();canMoveFishing=false;setTimeout(()=>{canMoveFishing=true;},100);}};const fishingCanvas=(document.getElementById("fishing-canvas"));const fishingContext=fishingCanvas.getContext("2d");const fishingLineCanvas=(document.getElementById("fishing-line-canvas"));const fishingLineContext=fishingLineCanvas.getContext("2d");fishingLineContext.strokeStyle="black";const fishingContainer=document.getElementById("fishing-container");const fishingRodImg=(document.getElementById("fishing-rod"));const fishingRodPos=({i:8,j:0});const fishingFishImg=(document.getElementById("fishing-fish"));const fishingFishPos=({i:2,j:1});const FISHING_CONFIG={mazeSize:7,cellHeight:45,circleMazeSize:5,circleCellHeight:30,isCircleProbability:0.05,secondsToFish:20,timerDelay:100,timer:null,};let fishingMazeObj=(null);let IS_FISHING_ACTIVE=false;let FISHING_IS_CIRCLE=false;const setFishingCanvasSize=({height,width})=>{fishingLineCanvas.height=fishingCanvas.height=height;fishingLineCanvas.width=fishingCanvas.width=width;};const getFishingRodPoint=()=>FISHING_IS_CIRCLE?fishingMazeObj.getCirclePoint():fishingMazeObj.getLastMazeCell().point;const drawFishingLine=()=>{fishingLineCanvas.height=fishingLineCanvas.height;const fishPoint=fishingMazeObj.getCurrentMazeCell().point;const rodPoint=getFishingRodPoint();fishingLineContext.moveTo(fishPoint.x,fishPoint.y);fishingLineContext.lineTo(rodPoint.x,rodPoint.y);fishingLineContext.stroke();};const initFishingImages=()=>{const{ySide}=fishingMazeObj.getMazePolyInfo();setImagePos(fishingRodImg,fishingRodPos);setEntityImageSize(fishingRodImg,ySide);setImagePoint(fishingRodImg,getFishingRodPoint(),true,ySide);setImagePos(fishingFishImg,fishingFishPos);setEntityImageSize(fishingFishImg,ySide);setImagePoint(fishingFishImg,fishingMazeObj.getCurrentMazeCell().point,true,ySide);drawFishingLine();};const stopFishing=()=>{clearInterval(FISHING_CONFIG.timer);fishingContainer.classList.add("hide");IS_FISHING_ACTIVE=false;};const initFishingMazeObj=()=>{if(!fishingMazeObj)fishingMazeObj=createMazeObj({cellHeight:FISHING_CONFIG.cellHeight,rows:FISHING_CONFIG.mazeSize,columns:FISHING_CONFIG.mazeSize,},{cellHeight:FISHING_CONFIG.circleCellHeight,rows:FISHING_CONFIG.circleMazeSize,columns:FISHING_CONFIG.circleMazeSize,});fishingMazeObj.setIsCircle(FISHING_IS_CIRCLE);fishingMazeObj.buildMaze();};const initFishingTimer=(height)=>{fishingContainer.style.setProperty("--fishing-progress-bar-init-height",`${height}px`);fishingContainer.style.setProperty("--fishing-progress-bar-height",`${height}px`);let currentHeight=height;const timerSteps=height/((FISHING_CONFIG.secondsToFish*1000)/FISHING_CONFIG.timerDelay);FISHING_CONFIG.timer=setInterval(()=>{currentHeight-=timerSteps;fishingContainer.style.setProperty("--fishing-progress-bar-height",`${currentHeight}px`);if(currentHeight<=0){stopFishing();hurtEntity(PLAYER_ENTITY,1);}},FISHING_CONFIG.timerDelay);};let fishingFluidInterval=null;const initFishingDraw=(mazeObj)=>{clearInterval(fishingFluidInterval);const cells=([]);for(const pos of mazeObj.iterateOverMaze()){const cell=mazeObj.getMazeCell(pos);cells.push(cell);drawCellMaze(fishingContext,mazeObj,cell,tweakColor(BLOCKS.WATER.color));}if(!cells.length)return;fishingFluidInterval=setInterval(()=>{cells.forEach((c)=>drawCellMaze(fishingContext,mazeObj,c,tweakColor(BLOCKS.WATER.color)));},DRAW_CONFIG.fluidSpeed);};const startFishing=()=>{if(IS_FISHING_ACTIVE)return stopFishing();IS_FISHING_ACTIVE=true;FISHING_IS_CIRCLE=Math.random()<FISHING_CONFIG.isCircleProbability;initFishingMazeObj();const size=fishingMazeObj.getMazeSize();size.height+=FISHING_CONFIG.cellHeight/9;setFishingCanvasSize(size);initFishingImages();fishingContainer.classList.remove("hide");initFishingTimer(size.height);initFishingDraw(fishingMazeObj);};let canMoveFishing=true;const moveFishing=(code,useDiagonal)=>{if(canMoveFishing){const{ySide,hasInverted,polySides}=fishingMazeObj.getMazePolyInfo();const currentCell=fishingMazeObj.getCurrentMazeCell();const aIndex=getMovementMap(currentCell,useDiagonal,0,polySides,!FISHING_IS_CIRCLE&&hasInverted)[code];const nextCell=fishingMazeObj.mazeMove(aIndex);if(!nextCell)return;if(fishingMazeObj.isMazeSolved()){stopFishing();giveItemToEntity(PLAYER_ENTITY,{imgPos:fishingFishPos,health:1});return;}setImagePoint(fishingFishImg,nextCell.point,true,ySide);drawFishingLine();canMoveFishing=false;setTimeout(()=>{canMoveFishing=true;},100);}};const MAP_CONFIG={currentPosRatio:5,posRatio:5,fullScreenPosRatio:50,playerColor:({r:212,g:172,b:156,}),xRatio:0,yRatio:0,};const mapCanvas=(document.getElementById("map-canvas"));const mapContext=mapCanvas.getContext("2d");const resetBiomeMap=()=>{let size=0;if(fullMap){size=Math.min(window.innerWidth,window.innerHeight)*0.96;MAP_CONFIG.currentPosRatio=MAP_CONFIG.fullScreenPosRatio;}else{size=mapCanvas.parentElement.offsetWidth;MAP_CONFIG.currentPosRatio=MAP_CONFIG.posRatio;}mapCanvas.width=size;mapCanvas.height=size;MAP_CONFIG.xRatio=mapCanvas.width/(MAP_CONFIG.currentPosRatio*2+1);MAP_CONFIG.yRatio=mapCanvas.height/(MAP_CONFIG.currentPosRatio*2+1);};const updateBiomeMap=()=>{clearCanvas(mapCanvas);const biomes=getBiomeMap();const iOffset=Math.round(RENDER_INFO.iOffset/GENERATION_CONFIG.chunkSize);const jOffset=Math.round(RENDER_INFO.jOffset/GENERATION_CONFIG.chunkSize);const iNegLimit=iOffset-MAP_CONFIG.currentPosRatio;const iPosLimit=iOffset+MAP_CONFIG.currentPosRatio+1;const jNegLimit=jOffset-MAP_CONFIG.currentPosRatio;const jPosLimit=jOffset+MAP_CONFIG.currentPosRatio+1;for(let i=iNegLimit;i<=iPosLimit;i++){const nI=i-iOffset;for(let j=jNegLimit;j<=jPosLimit;j++){const nJ=j-jOffset;const biome=biomes[i]?.[j];if(!biome)continue;createRect({i:nI,j:nJ},biome.mapColor);}}createRect({i:0,j:0},MAP_CONFIG.playerColor);};let fullMap=false;const toggleFullMap=(toggle=!fullMap)=>{fullMap=toggle;if(toggle){mapCanvas.classList.add("full-screen");resetBiomeMap();updateBiomeMap();}else{mapCanvas.classList.remove("full-screen");resetBiomeMap();updateBiomeMap();}};const createRect=(pos,color)=>{mapContext.fillStyle=getFillStyle(color);mapContext.fillRect((MAP_CONFIG.currentPosRatio+pos.j)*MAP_CONFIG.xRatio,(MAP_CONFIG.currentPosRatio+pos.i)*MAP_CONFIG.yRatio,MAP_CONFIG.xRatio,MAP_CONFIG.yRatio);};const MAP_CONFIG={currentPosRatio:5,posRatio:5,fullScreenPosRatio:50,playerColor:({r:212,g:172,b:156,}),xRatio:0,yRatio:0,};const mapCanvas=(document.getElementById("map-canvas"));const mapContext=mapCanvas.getContext("2d");const resetBiomeMap=()=>{let size=0;if(fullMap){size=Math.min(window.innerWidth,window.innerHeight)*0.96;MAP_CONFIG.currentPosRatio=MAP_CONFIG.fullScreenPosRatio;}else{size=mapCanvas.parentElement.offsetWidth;MAP_CONFIG.currentPosRatio=MAP_CONFIG.posRatio;}mapCanvas.width=size;mapCanvas.height=size;MAP_CONFIG.xRatio=mapCanvas.width/(MAP_CONFIG.currentPosRatio*2+1);MAP_CONFIG.yRatio=mapCanvas.height/(MAP_CONFIG.currentPosRatio*2+1);};const updateBiomeMap=()=>{clearCanvas(mapCanvas);const biomes=getBiomeMap();const iOffset=Math.round(RENDER_INFO.iOffset/GENERATION_CONFIG.chunkSize);const jOffset=Math.round(RENDER_INFO.jOffset/GENERATION_CONFIG.chunkSize);const iNegLimit=iOffset-MAP_CONFIG.currentPosRatio;const iPosLimit=iOffset+MAP_CONFIG.currentPosRatio+1;const jNegLimit=jOffset-MAP_CONFIG.currentPosRatio;const jPosLimit=jOffset+MAP_CONFIG.currentPosRatio+1;for(let i=iNegLimit;i<=iPosLimit;i++){const nI=i-iOffset;for(let j=jNegLimit;j<=jPosLimit;j++){const nJ=j-jOffset;const biome=biomes[i]?.[j];if(!biome)continue;createRect({i:nI,j:nJ},biome.mapColor);}}createRect({i:0,j:0},MAP_CONFIG.playerColor);};let fullMap=false;const toggleFullMap=(toggle=!fullMap)=>{fullMap=toggle;if(toggle){mapCanvas.classList.add("full-screen");resetBiomeMap();updateBiomeMap();}else{mapCanvas.classList.remove("full-screen");resetBiomeMap();updateBiomeMap();}};const createRect=(pos,color)=>{mapContext.fillStyle=getFillStyle(color);mapContext.fillRect((MAP_CONFIG.currentPosRatio+pos.j)*MAP_CONFIG.xRatio,(MAP_CONFIG.currentPosRatio+pos.i)*MAP_CONFIG.yRatio,MAP_CONFIG.xRatio,MAP_CONFIG.yRatio);};const areColorsEqual=(color1,color2)=>color1.r===color2.r&&color1.g===color2.g&&color1.b===color2.b;const PLACE_CONFIG={cellHeight:24,canvasNum:7,};const BLOCKS_LISTS=Object.values(BLOCKS).filter((b)=>!b.isFluid).filter((b,i,a)=>!a.find((b2,i2)=>areColorsEqual(b.color,b2.color)&&i<i2));PLACE_CONFIG.steps=360/PLACE_CONFIG.canvasNum;let PLACE_POLYS_INFO=(null);const placeContainer=document.getElementById("place-canvas-container");const placeCanvas=([]);const placeContexts=([]);for(let i=0;i<PLACE_CONFIG.canvasNum;i++){const canvas=document.createElement("canvas");canvas.style.setProperty("--place-rotate-canvas",`${PLACE_CONFIG.steps *i}deg`);placeContainer.appendChild(canvas);placeCanvas.push(canvas);placeContexts.push(canvas.getContext("2d"));}placeContainer.ontouchend=()=>{};const getSelectedBlockToPlace=()=>{const block=BLOCKS_LISTS[getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length)];return{block,color:block.color};};const resetPlace=()=>{placeCanvas.forEach((p)=>{p.width=placeContainer.parentElement.offsetWidth;p.height=placeContainer.parentElement.offsetHeight;});showSelectedPlaceBlocks();};const drawPlaceBlock=(context,block)=>{if(!PLACE_POLYS_INFO){PLACE_POLYS_INFO={};for(const p of KNOWN_POLYGONS_VALUES){PLACE_POLYS_INFO[p]=configPoly(p,PLACE_CONFIG.cellHeight);}}const polyInfo=PLACE_POLYS_INFO[RENDER_INFO.currentPoly];const wall=blockToWall({block,color:block.color},{x:placeContainer.parentElement.offsetWidth/2,y:placeContainer.parentElement.offsetHeight/1.75,},{isInverted:polyInfo.hasInverted},polyInfo);drawWall(wall,context);applyBorders(context,wall.point,wall.points,[],true);drawWallTop(wall,context);};let SELECTED_PLACE_BLOCKS=0;let PLACE_BLOCKS_DEG=0;const movePlaceBlocks=(orientation)=>{SELECTED_PLACE_BLOCKS=SELECTED_PLACE_BLOCKS+orientation;PLACE_BLOCKS_DEG+=orientation>0?PLACE_CONFIG.steps:-PLACE_CONFIG.steps;placeContainer.style.setProperty("--place-rotate-container",`${-PLACE_BLOCKS_DEG}deg`);showSelectedPlaceBlocks();};const showSelectedPlaceBlocks=()=>{const showIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS+1,PLACE_CONFIG.canvasNum),];const drawIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS+1,BLOCKS_LISTS.length),];placeCanvas.forEach((p,i)=>{p.classList[showIndexes.includes(i)?"add":"remove"]("active");});showIndexes.forEach((index,i)=>{clearCanvas(placeCanvas[index]);drawPlaceBlock(placeContexts[index],BLOCKS_LISTS[drawIndexes[i]]);});};const resetToolbar=()=>{resetBiomeMap();resetPlace();};const areColorsEqual=(color1,color2)=>color1.r===color2.r&&color1.g===color2.g&&color1.b===color2.b;const PLACE_CONFIG={cellHeight:24,canvasNum:7,};const BLOCKS_LISTS=Object.values(BLOCKS).filter((b)=>!b.isFluid).filter((b,i,a)=>!a.find((b2,i2)=>areColorsEqual(b.color,b2.color)&&i<i2));PLACE_CONFIG.steps=360/PLACE_CONFIG.canvasNum;let PLACE_POLYS_INFO=(null);const placeContainer=document.getElementById("place-canvas-container");const placeCanvas=([]);const placeContexts=([]);for(let i=0;i<PLACE_CONFIG.canvasNum;i++){const canvas=document.createElement("canvas");canvas.style.setProperty("--place-rotate-canvas",`${PLACE_CONFIG.steps *i}deg`);placeContainer.appendChild(canvas);placeCanvas.push(canvas);placeContexts.push(canvas.getContext("2d"));}placeContainer.ontouchend=()=>{};const getSelectedBlockToPlace=()=>{const block=BLOCKS_LISTS[getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length)];return{block,color:block.color};};const resetPlace=()=>{placeCanvas.forEach((p)=>{p.width=placeContainer.parentElement.offsetWidth;p.height=placeContainer.parentElement.offsetHeight;});showSelectedPlaceBlocks();};const drawPlaceBlock=(context,block)=>{if(!PLACE_POLYS_INFO){PLACE_POLYS_INFO={};for(const p of KNOWN_POLYGONS_VALUES){PLACE_POLYS_INFO[p]=configPoly(p,PLACE_CONFIG.cellHeight);}}const polyInfo=PLACE_POLYS_INFO[RENDER_INFO.currentPoly];const wall=blockToWall({block,color:block.color},{x:placeContainer.parentElement.offsetWidth/2,y:placeContainer.parentElement.offsetHeight/1.75,},{isInverted:polyInfo.hasInverted},polyInfo);drawWall(wall,context);applyBorders(context,wall.point,wall.points,[],true);drawWallTop(wall,context);};let SELECTED_PLACE_BLOCKS=0;let PLACE_BLOCKS_DEG=0;const movePlaceBlocks=(orientation)=>{SELECTED_PLACE_BLOCKS=SELECTED_PLACE_BLOCKS+orientation;PLACE_BLOCKS_DEG+=orientation>0?PLACE_CONFIG.steps:-PLACE_CONFIG.steps;placeContainer.style.setProperty("--place-rotate-container",`${-PLACE_BLOCKS_DEG}deg`);showSelectedPlaceBlocks();};const showSelectedPlaceBlocks=()=>{const showIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS+1,PLACE_CONFIG.canvasNum),];const drawIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS+1,BLOCKS_LISTS.length),];placeCanvas.forEach((p,i)=>{p.classList[showIndexes.includes(i)?"add":"remove"]("active");});showIndexes.forEach((index,i)=>{clearCanvas(placeCanvas[index]);drawPlaceBlock(placeContexts[index],BLOCKS_LISTS[drawIndexes[i]]);});};const PERLIN_VECTORS={BIOME:Symbol("BIOME"),BLOCK:Symbol("BLOCK"),};const getValue=(()=>{const PERLIN_CONFIG={noiseResolutionBiome:75,noiseResolution:10,};const getSizeFromNoise=(size,resolution)=>{const numVectorsX=Math.floor(size/resolution)+1;const extraVectorX=size%resolution==0?0:1;return numVectorsX+extraVectorX;};const initializeVector=(vector)=>{return{width:getSizeFromNoise(vector.width,vector.resolution),height:getSizeFromNoise(vector.height,vector.resolution),vectors:[],resolution:vector.resolution,};};const vectors=({[PERLIN_VECTORS.BIOME]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolutionBiome,}),[PERLIN_VECTORS.BLOCK]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolution,}),});const updateVector=(i,j,vector)=>{const offsetPos=getChunkStart({i,j},vector.height,vector.width);for(let i=0;i<=vector.height-1;i++){const nI=i+offsetPos.i;vector.vectors[nI]=vector.vectors[nI]||[];for(let j=0;j<=vector.width-1;j++){const nJ=j+offsetPos.j;vector.vectors[nI][nJ]=getRandUnitVect();}}};const getRandUnitVect=()=>{const theta=Math.random()*2*Math.PI;return{x:Math.cos(theta),y:Math.sin(theta)};};const dotProduct=(vector,x,y,vx,vy)=>{if(!vector.vectors[vy]?.[vx])updateVector(vy,vx,vector);return dot({x:x-vx,y:y-vy},vector.vectors[vy][vx]);};const dot=(v1,v2)=>v1.x*v2.x+v1.y*v2.y;const lerp=(a,b,c)=>a+smootherstep(c)*(b-a);const smootherstep=(x)=>6*x**5-15*x**4+10*x**3;return(i,j,vectorType)=>{const vector=vectors[vectorType];const offset=0.5/vector.resolution;const x=i/vector.resolution+offset;const y=j/vector.resolution+offset;const xF=Math.floor(x);const yF=Math.floor(y);const tlv=dotProduct(vector,x,y,xF,yF);const trv=dotProduct(vector,x,y,xF+1,yF);const blv=dotProduct(vector,x,y,xF,yF+1);const brv=dotProduct(vector,x,y,xF+1,yF+1);const lerpTop=lerp(tlv,trv,x-xF);const lerpBottom=lerp(blv,brv,x-xF);const value=lerp(lerpTop,lerpBottom,y-yF);return value;};})();const resetToolbar=()=>{resetBiomeMap();resetPlace();};const CLOUDS_CONFIG={num:4,rows:3,columns:3,durationMult:30,offsetSize:6,offset:0,};const CLOUDS_DIRECTION_MAP={[MOVEMENT.RIGHT]:-CLOUDS_CONFIG.offsetSize,[MOVEMENT.LEFT]:CLOUDS_CONFIG.offsetSize,};const cloudsContainer=document.getElementById("clouds-container");let clouds=([]);const updateClouds=(direction)=>{if(MENU_CONFIG.clouds){if(!clouds.length){createClouds();offsetClouds(MOVEMENT.RIGHT);}setCloudShape();offsetClouds(direction);}else{cloudsContainer.classList.add("off");}};const setCloudShape=()=>{const{currentPoly,cellHeight}=RENDER_INFO;const size=Math.min(cellHeight*4,cloudsContainer.offsetWidth/(CLOUDS_CONFIG.num*CLOUDS_CONFIG.columns*1.5));cloudsContainer.className=`p${currentPoly}`;cloudsContainer.style.setProperty("--clouds-default-size",`${size}px`);};const offsetClouds=(direction)=>{const offsetSize=CLOUDS_DIRECTION_MAP[direction];if(!offsetSize)return;CLOUDS_CONFIG.offset+=offsetSize;const offsetLeft=getMod(CLOUDS_CONFIG.offset,cloudsContainer.offsetWidth);const width=cloudsContainer.offsetWidth/CLOUDS_CONFIG.num;const defaultOffsetLeft=cloudsContainer.offsetWidth/4;cloudsContainer.style.setProperty("--clouds-offset-left",`${getMod(CLOUDS_CONFIG.offset,width)-defaultOffsetLeft}px`);const offset=Math.floor(offsetLeft/width);for(let index=0;index<clouds.length;index++){clouds[index].style.setProperty("--clouds-order",`${getMod(index +offset,CLOUDS_CONFIG.num)+1}`);}};const createClouds=()=>{const min=1-CLOUDS_CONFIG.num/10;const max=Math.min(min+0.5,1);for(let i=0;i<CLOUDS_CONFIG.num;i++){const cloud=document.createElement("div");cloud.className="cloud";const scale=correctRoundError(getRandomFloat(min,max),2);const duration=Math.round(scale*CLOUDS_CONFIG.durationMult);cloud.style.setProperty("--clouds-scale",`${scale}`);cloud.style.setProperty("--clouds-animation-duration",`${duration}s`);cloudsContainer.appendChild(cloud);clouds.push(cloud);for(let j=0;j<CLOUDS_CONFIG.rows;j++){const cloudRow=document.createElement("div");cloudRow.className="cloud-row";cloud.appendChild(cloudRow);for(let z=0;z<CLOUDS_CONFIG.columns;z++){const cloudShape=document.createElement("div");cloudShape.className="cloud-shape";cloudRow.appendChild(cloudShape);}}}};const CLOUDS_CONFIG={num:4,rows:3,columns:3,durationMult:30,offsetSize:6,offset:0,};const CLOUDS_DIRECTION_MAP={[MOVEMENT.RIGHT]:-CLOUDS_CONFIG.offsetSize,[MOVEMENT.LEFT]:CLOUDS_CONFIG.offsetSize,};const cloudsContainer=document.getElementById("clouds-container");let clouds=([]);const updateClouds=(direction)=>{if(MENU_CONFIG.clouds){if(!clouds.length){createClouds();offsetClouds(MOVEMENT.RIGHT);}setCloudShape();offsetClouds(direction);}else{cloudsContainer.classList.add("off");}};const setCloudShape=()=>{const{currentPoly,cellHeight}=RENDER_INFO;const size=Math.min(cellHeight*4,cloudsContainer.offsetWidth/(CLOUDS_CONFIG.num*CLOUDS_CONFIG.columns*1.5));cloudsContainer.className=`p${currentPoly}`;cloudsContainer.style.setProperty("--clouds-default-size",`${size}px`);};const offsetClouds=(direction)=>{const offsetSize=CLOUDS_DIRECTION_MAP[direction];if(!offsetSize)return;CLOUDS_CONFIG.offset+=offsetSize;const offsetLeft=getMod(CLOUDS_CONFIG.offset,cloudsContainer.offsetWidth);const width=cloudsContainer.offsetWidth/CLOUDS_CONFIG.num;const defaultOffsetLeft=cloudsContainer.offsetWidth/4;cloudsContainer.style.setProperty("--clouds-offset-left",`${getMod(CLOUDS_CONFIG.offset,width)-defaultOffsetLeft}px`);const offset=Math.floor(offsetLeft/width);for(let index=0;index<clouds.length;index++){clouds[index].style.setProperty("--clouds-order",`${getMod(index +offset,CLOUDS_CONFIG.num)+1}`);}};const createClouds=()=>{const min=1-CLOUDS_CONFIG.num/10;const max=Math.min(min+0.5,1);for(let i=0;i<CLOUDS_CONFIG.num;i++){const cloud=document.createElement("div");cloud.className="cloud";const scale=correctRoundError(getRandomFloat(min,max),2);const duration=Math.round(scale*CLOUDS_CONFIG.durationMult);cloud.style.setProperty("--clouds-scale",`${scale}`);cloud.style.setProperty("--clouds-animation-duration",`${duration}s`);cloudsContainer.appendChild(cloud);clouds.push(cloud);for(let j=0;j<CLOUDS_CONFIG.rows;j++){const cloudRow=document.createElement("div");cloudRow.className="cloud-row";cloud.appendChild(cloudRow);for(let z=0;z<CLOUDS_CONFIG.columns;z++){const cloudShape=document.createElement("div");cloudShape.className="cloud-shape";cloudRow.appendChild(cloudShape);}}}};const rainContainer =document.getElementById("rain-container");const BIOME_RAIN_MAP ={DEFAULT:"../images/weather/rain.gif",[BIOME_TYPES.SNOW]:"../images/weather/snow.gif",};const rainAudio =new Audio("sounds/weather/rain.mp3");rainAudio.volume =0.25;rainAudio.loop =true;const lightningAudio =new Audio("sounds/weather/lightning.mp3");lightningAudio.volume =0.25;let isRainOn =false;const updateRain =()=>{if (MENU_CONFIG.rain){if (!isRainOn){clearLightning();isRainOn =true;rainAudio.play();rainContainer.classList.remove("hide");const size =RENDER_INFO.cellHeight *10;rainContainer.style.setProperty("--rain-size",`${size}px`);createLightining();}updateRainImg();}else {if (isRainOn){clearLightning();isRainOn =false;rainAudio.pause();rainContainer.classList.add("hide");}}};let lightningInterval =null;const createLightining =()=>{clearTimeout(lightningInterval);const secs =getRandomFloat(10000,30000);lightningInterval =setTimeout(()=>{rainContainer.classList.remove("lightning");rainContainer.offsetHeight;rainContainer.classList.add("lightning");lightningAudio.play();createLightining();},secs);};const clearLightning =()=>{clearTimeout(lightningInterval);rainContainer.classList.remove("lightning");};const updateRainImg =()=>{const gif =`url("${BIOME_RAIN_MAP[PLAYER_ENTITY.cell.block.biomeType]||BIOME_RAIN_MAP.DEFAULT }")`;const currentGif=rainContainer.style.getPropertyValue("--rain-img");if(gif!==currentGif)rainContainer.style.setProperty("--rain-img",gif);};const DRAW_CONFIG={lightDepth:2,maxLayer:2,fluidSpeed:500,};const RENDER_CONFIG={selectedBorderColor:"white",borderColor:"black",emptyColor:"black",lineWidth:1,wallDarkness:0.5,};const updateWeather=(direction)=>{updateRain();updateClouds(direction);};const rainContainer =document.getElementById("rain-container");const BIOME_RAIN_MAP ={DEFAULT:"../images/weather/rain.gif",[BIOME_TYPES.SNOW]:"../images/weather/snow.gif",};const rainAudio =new Audio("sounds/weather/rain.mp3");rainAudio.volume =0.25;rainAudio.loop =true;const lightningAudio =new Audio("sounds/weather/lightning.mp3");lightningAudio.volume =0.25;let isRainOn =false;const updateRain =()=>{if (MENU_CONFIG.rain){if (!isRainOn){clearLightning();isRainOn =true;rainAudio.play();rainContainer.classList.remove("hide");const size =RENDER_INFO.cellHeight *10;rainContainer.style.setProperty("--rain-size",`${size}px`);createLightining();}updateRainImg();}else {if (isRainOn){clearLightning();isRainOn =false;rainAudio.pause();rainContainer.classList.add("hide");}}};let lightningInterval =null;const createLightining =()=>{clearTimeout(lightningInterval);const secs =getRandomFloat(10000,30000);lightningInterval =setTimeout(()=>{rainContainer.classList.remove("lightning");rainContainer.offsetHeight;rainContainer.classList.add("lightning");lightningAudio.play();createLightining();},secs);};const clearLightning =()=>{clearTimeout(lightningInterval);rainContainer.classList.remove("lightning");};const updateRainImg =()=>{const gif =`url("${BIOME_RAIN_MAP[PLAYER_ENTITY.cell.block.biomeType]||BIOME_RAIN_MAP.DEFAULT }")`;const currentGif=rainContainer.style.getPropertyValue("--rain-img");if(gif!==currentGif)rainContainer.style.setProperty("--rain-img",gif);};const updateWeather=(direction)=>{updateRain();updateClouds(direction);};const CLOCK_CONFIG={passHour:0.25,midNightHour:60,};const analogClock=document.getElementById("analog-clock");const digitalClock=document.getElementById("digital-clock");const hourTensSegments=document.querySelectorAll("#digital-clock-hours .digit-tens .segment");const hourUnitsSegments=document.querySelectorAll("#digital-clock-hours .digit-units .segment");const minuteTensSegments=document.querySelectorAll("#digital-clock-minutes .digit-tens .segment");const minuteUnitsSegments=document.querySelectorAll("#digital-clock-minutes .digit-units .segment");const updateClock=()=>{const{hour,hour24,minute}=getTime();if(MENU_CONFIG.digitalClock){digitalClock.classList.remove("hide");analogClock.classList.add("hide");setNumber(hourTensSegments,Math.floor(hour24/10));setNumber(hourUnitsSegments,Math.floor(hour24%10));setNumber(minuteTensSegments,Math.floor(minute/10));setNumber(minuteUnitsSegments,Math.floor(minute%10));}else{analogClock.classList.remove("hide");digitalClock.classList.add("hide");analogClock.style.setProperty("--clock-hour-rotate",`${hour *30 +minute *0.5}deg`);analogClock.style.setProperty("--clock-minute-rotate",`${minute *6}deg`);}};const passTime=()=>{ENTITY_INFO.timeOfDay+=CLOCK_CONFIG.passHour;if(ENTITY_INFO.timeOfDay>=CLOCK_CONFIG.midNightHour||ENTITY_INFO.timeOfDay<=0){CLOCK_CONFIG.passHour=-CLOCK_CONFIG.passHour;}updateClock();};const getTime=()=>{const hourRaw=(12*ENTITY_INFO.timeOfDay)/CLOCK_CONFIG.midNightHour;let hour=Math.floor(hourRaw);let minute=Math.round((hourRaw-hour)*100);minute=Math.floor(minute*0.6);minute=CLOCK_CONFIG.passHour>0?minute:60-minute;minute=getMod(minute,60);if(CLOCK_CONFIG.passHour<0)hour=Math.max((minute?11:12)-hour,0);const hour24=CLOCK_CONFIG.passHour>0?hour+12:hour;return{hour,hour24,minute};};const setNumber=(segments,value)=>{segments.forEach((el)=>{el.classList[el.classList.contains(`n${value}`)?"add":"remove"]("active");});};const blockToWall=(block,point,wallParams={},polyInfo)=>{polyInfo=polyInfo||getPolyInfo();const points=wallParams.isInverted?polyInfo.invertedPoints:polyInfo.points;const layer=wallParams.layer||0;const wallLayer=layer+1;const wallPoints=wallParams.isInverted?polyInfo.wallInvertedPoints:polyInfo.wallPoints;const commonInfos={color:block.color,pos:wallParams.pos,isInverted:wallParams.isInverted,isSelectedCell:wallParams.isSelectedCell,};return{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*layer},points:wallPoints,topInfo:{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*wallLayer},points,modifier:wallParams.modifier,},borderMap:wallParams.borderMap,modifier:wallParams.modifier*RENDER_CONFIG.wallDarkness,};};const compass=document.getElementById("compass");const COMPASS_CONFIG={rotateDelay:750,};const updateCompass=()=>{const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;compass.style.setProperty("--compass-rotate",`${-angle}deg`);};const entitiesContainer=document.getElementById("entities");const rotateCanvas=(deg,rotateDelay)=>{rotateElement(entitiesContainer,-deg,rotateDelay);rotateElement(drawContainer,deg,rotateDelay);};const resetRotateCanvas=()=>{rotateElement(entitiesContainer);rotateElement(drawContainer);};const rotateElement=(element,deg,rotateDelay)=>{if(rotateDelay)element.style.setProperty("--transition-duration",`${rotateDelay}ms`);if(deg)element.style.setProperty("--rotate-deg",`${deg}deg`);element.classList[deg?"add":"remove"]("rotate");element.classList[deg?"add":"remove"]("zoom-in");};const drawContainer=document.getElementById("draw-container");const canvasContainer=document.getElementById("canvas-container");const CLOCK_CONFIG={passHour:0.25,midNightHour:60,};const analogClock=document.getElementById("analog-clock");const digitalClock=document.getElementById("digital-clock");const hourTensSegments=document.querySelectorAll("#digital-clock-hours .digit-tens .segment");const hourUnitsSegments=document.querySelectorAll("#digital-clock-hours .digit-units .segment");const minuteTensSegments=document.querySelectorAll("#digital-clock-minutes .digit-tens .segment");const minuteUnitsSegments=document.querySelectorAll("#digital-clock-minutes .digit-units .segment");const updateClock=()=>{const{hour,hour24,minute}=getTime();if(MENU_CONFIG.digitalClock){digitalClock.classList.remove("hide");analogClock.classList.add("hide");setNumber(hourTensSegments,Math.floor(hour24/10));setNumber(hourUnitsSegments,Math.floor(hour24%10));setNumber(minuteTensSegments,Math.floor(minute/10));setNumber(minuteUnitsSegments,Math.floor(minute%10));}else{analogClock.classList.remove("hide");digitalClock.classList.add("hide");analogClock.style.setProperty("--clock-hour-rotate",`${hour *30 +minute *0.5}deg`);analogClock.style.setProperty("--clock-minute-rotate",`${minute *6}deg`);}};const passTime=()=>{ENTITY_INFO.timeOfDay+=CLOCK_CONFIG.passHour;if(ENTITY_INFO.timeOfDay>=CLOCK_CONFIG.midNightHour||ENTITY_INFO.timeOfDay<=0){CLOCK_CONFIG.passHour=-CLOCK_CONFIG.passHour;}updateClock();};const getTime=()=>{const hourRaw=(12*ENTITY_INFO.timeOfDay)/CLOCK_CONFIG.midNightHour;let hour=Math.floor(hourRaw);let minute=Math.round((hourRaw-hour)*100);minute=Math.floor(minute*0.6);minute=CLOCK_CONFIG.passHour>0?minute:60-minute;minute=getMod(minute,60);if(CLOCK_CONFIG.passHour<0)hour=Math.max((minute?11:12)-hour,0);const hour24=CLOCK_CONFIG.passHour>0?hour+12:hour;return{hour,hour24,minute};};const setNumber=(segments,value)=>{segments.forEach((el)=>{el.classList[el.classList.contains(`n${value}`)?"add":"remove"]("active");});};const updateWidgets=()=>{updateClock();updateCompass();};const compass=document.getElementById("compass");const COMPASS_CONFIG={rotateDelay:750,};const updateCompass=()=>{const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;compass.style.setProperty("--compass-rotate",`${-angle}deg`);};const entitiesContainer=document.getElementById("entities");const rotateCanvas=(deg,rotateDelay)=>{rotateElement(entitiesContainer,-deg,rotateDelay);rotateElement(drawContainer,deg,rotateDelay);};const resetRotateCanvas=()=>{rotateElement(entitiesContainer);rotateElement(drawContainer);};const rotateElement=(element,deg,rotateDelay)=>{if(rotateDelay)element.style.setProperty("--transition-duration",`${rotateDelay}ms`);if(deg)element.style.setProperty("--rotate-deg",`${deg}deg`);element.classList[deg?"add":"remove"]("rotate");element.classList[deg?"add":"remove"]("zoom-in");};const updateWidgets=()=>{updateClock();updateCompass();};const digAudio=new Audio("sounds/actions/dig.mp3");digAudio.volume=0.25;const punchAudio=new Audio("sounds/actions/punch.mp3");punchAudio.volume=0.25;const gunShotAudio=new Audio("sounds/actions/gun-shot.mp3");gunShotAudio.volume=1;const rotateAudio=new Audio("sounds/actions/rotate.mp3");rotateAudio.volume=0.25;let canRotate=true;const canDoActions=()=>PLAYER_ENTITY.health>0;const rotate=(orientation)=>{if(canRotate){canRotate=false;RENDER_INFO.rotationTurns=PLAYER_ENTITY.selectedCellIndex=getMod(RENDER_INFO.rotationTurns+orientation,RENDER_INFO.currentPoly);if(MENU_CONFIG.rotationAnimation){rotateCanvas((360/RENDER_INFO.currentPoly)*-orientation,COMPASS_CONFIG.rotateDelay);rotateAudio.play();}updateCompass();resetDirection();setTimeout(()=>{if(MENU_CONFIG.rotationAnimation)resetRotateCanvas();drawEveryCell(PLAYER_ENTITY);canRotate=true;},COMPASS_CONFIG.rotateDelay);}};const getNextCellIndexBasedOnCode=(code,useDiagonal)=>{const aIndex=getMovementMap(PLAYER_ENTITY.cell,useDiagonal)[code];if(aIndex===undefined)return;return getMod(aIndex,RENDER_INFO.currentPoly);};let isMoving=false;const moveBaseOnCode=(direction,useDiagonal)=>{if(!direction||!canDoActions())return;if(IS_FISHING_ACTIVE){moveFishing(direction,useDiagonal);return;}isMoving=true;makeEntityRun(PLAYER_ENTITY,direction);const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined)return;const nextPos=getPosByIndex(PLAYER_ENTITY.cell,aModI);if(!nextPos)return;const nextCell=getCell(nextPos);if(cellIsBlocked(nextCell,PLAYER_ENTITY))return;move(nextCell);updateWeather(direction);};const MOVEMENT_VALUES=Object.values(MOVEMENT);const stopMoving=()=>{if(!isMoving)return;let lastSelection=PLAYER_ENTITY.currentDirection;const movementMap=getMovementMap(PLAYER_ENTITY.cell);for(const movement of MOVEMENT_VALUES){if(movementMap[movement]===PLAYER_ENTITY.selectedCellIndex){lastSelection=movement;break;}}isMoving=false;updateEntityDirection(PLAYER_ENTITY,lastSelection);};const changeSelectedOnCode=(direction,useDiagonal)=>{if(!direction)return;const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined||aModI===PLAYER_ENTITY.selectedCellIndex)return;PLAYER_ENTITY.selectedCellIndex=aModI;if(MENU_CONFIG.showSelectedCell)drawEveryCell(PLAYER_ENTITY);updateEntityDirection(PLAYER_ENTITY,direction);};const getNextPolygon=()=>KNOWN_POLYGONS_VALUES[(KNOWN_POLYGONS_VALUES.indexOf(RENDER_INFO.currentPoly)+1)%KNOWN_POLYGONS_VALUES.length];const changePolySides=()=>{RENDER_INFO.currentPoly=getNextPolygon();RENDER_INFO.rotationTurns=0;PLAYER_ENTITY.selectedCellIndex=0;updateCompass();resetDirection();resetMap();};const resetDirection=()=>updateEntityDirection(PLAYER_ENTITY,MOVEMENT.UP);const updateAndGetSelectedCell=()=>{updateEntityDirection(PLAYER_ENTITY,PLAYER_ENTITY.currentDirection);return getSelectedCell(PLAYER_ENTITY);};const dig=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(!selectedCell?.block)return;if(selectedCell.entityType){makeEntityUse(PLAYER_ENTITY);const entities=getEntitiesFromCell(selectedCell);entities.forEach((e)=>hurtEntity(e,1));punchAudio.play();move();return;}if(selectedCell.block.isFluid)return;if(selectedCell.wall){if(selectedCell.wall.block.indestructible)return;}else if(selectedCell.block.indestructible)return;makeEntityUse(PLAYER_ENTITY);digAudio.play();if(selectedCell.wall){destroyWall(selectedCell);}else{selectedCell.block=null;selectedCell.color=null;}move();};const place=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.wall||selectedCell.entityType)return;makeEntityUse(PLAYER_ENTITY);placeBlock(selectedCell);move();};const placeBlock=(cell,block,color)=>{if(!cell||!!cell.entityType)return;if(!block){const cellBlock=getSelectedBlockToPlace();if(!cellBlock)return;block=cellBlock.block;color=cellBlock.color;}digAudio.play();if(cell.block&&!cell.block.isFluid){cell.wall={block:block,color:color};}else{cell.block=block;cell.color=color;}};const useBoat=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();const canMove=!selectedCell.wall&&selectedCell.block;if(PLAYER_ENTITY.connectedEntities[ENTITY_TYPES.BOAT]){if(!selectedCell?.block?.isFluid&&canMove){getOutBoat(PLAYER_ENTITY);move(selectedCell);}return;}if(selectedCell.entityType===ENTITY_TYPES.BOAT){getInBoat(PLAYER_ENTITY);move(selectedCell);}else if(canMove){makeEntityUse(PLAYER_ENTITY);addBoat(selectedCell,PLAYER_ENTITY);}};const useGun=()=>{const range=getPolyInfo().hasInverted?1:10;updateAndGetSelectedCell();gunShotAudio.currentTime=0;let{cell,selectedCellIndex}=PLAYER_ENTITY;for(let i=0;i<range;i++){const nextCell=getCell(getPosByIndex(cell,selectedCellIndex));if(nextCell.wall)break;cell=nextCell;drawCircleOnCell(cell,PLAYER_ENTITY);if(cell.entityType){const entities=getEntitiesFromCell(cell);entities.forEach((e)=>hurtEntity(e,1));break;}}gunShotAudio.play();move();};const useMap=(toggle)=>{if(IS_FISHING_ACTIVE||!canDoActions())return;toggleFullMap(toggle);};const useFishingRod=()=>{if(!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.block?.isFluid){makeEntityUse(PLAYER_ENTITY);startFishing();}};const resetMap=()=>{resetPlace();setEntitiesSize();resetCanvas();moveCurrentCell(getCenterCell(),PLAYER_ENTITY.cell);drawEveryCell(PLAYER_ENTITY);updateWeather();};const digAudio=new Audio("sounds/actions/dig.mp3");digAudio.volume=0.25;const punchAudio=new Audio("sounds/actions/punch.mp3");punchAudio.volume=0.25;const gunShotAudio=new Audio("sounds/actions/gun-shot.mp3");gunShotAudio.volume=1;const rotateAudio=new Audio("sounds/actions/rotate.mp3");rotateAudio.volume=0.25;let canRotate=true;const canDoActions=()=>PLAYER_ENTITY.health>0;const rotate=(orientation)=>{if(canRotate){canRotate=false;RENDER_INFO.rotationTurns=PLAYER_ENTITY.selectedCellIndex=getMod(RENDER_INFO.rotationTurns+orientation,RENDER_INFO.currentPoly);if(MENU_CONFIG.rotationAnimation){rotateCanvas((360/RENDER_INFO.currentPoly)*-orientation,COMPASS_CONFIG.rotateDelay);rotateAudio.play();}updateCompass();resetDirection();setTimeout(()=>{if(MENU_CONFIG.rotationAnimation)resetRotateCanvas();drawEveryCell(PLAYER_ENTITY);canRotate=true;},COMPASS_CONFIG.rotateDelay);}};const getNextCellIndexBasedOnCode=(code,useDiagonal)=>{const aIndex=getMovementMap(PLAYER_ENTITY.cell,useDiagonal)[code];if(aIndex===undefined)return;return getMod(aIndex,RENDER_INFO.currentPoly);};let isMoving=false;const moveBaseOnCode=(direction,useDiagonal)=>{if(!direction||!canDoActions())return;if(IS_FISHING_ACTIVE){moveFishing(direction,useDiagonal);return;}isMoving=true;makeEntityRun(PLAYER_ENTITY,direction);const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined)return;const nextPos=getPosByIndex(PLAYER_ENTITY.cell,aModI);if(!nextPos)return;const nextCell=getCell(nextPos);if(cellIsBlocked(nextCell,PLAYER_ENTITY))return;move(nextCell);updateWeather(direction);};const MOVEMENT_VALUES=Object.values(MOVEMENT);const stopMoving=()=>{if(!isMoving)return;let lastSelection=PLAYER_ENTITY.currentDirection;const movementMap=getMovementMap(PLAYER_ENTITY.cell);for(const movement of MOVEMENT_VALUES){if(movementMap[movement]===PLAYER_ENTITY.selectedCellIndex){lastSelection=movement;break;}}isMoving=false;updateEntityDirection(PLAYER_ENTITY,lastSelection);};const changeSelectedOnCode=(direction,useDiagonal)=>{if(!direction)return;const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined||aModI===PLAYER_ENTITY.selectedCellIndex)return;PLAYER_ENTITY.selectedCellIndex=aModI;if(MENU_CONFIG.showSelectedCell)drawEveryCell(PLAYER_ENTITY);updateEntityDirection(PLAYER_ENTITY,direction);};const getNextPolygon=()=>KNOWN_POLYGONS_VALUES[(KNOWN_POLYGONS_VALUES.indexOf(RENDER_INFO.currentPoly)+1)%KNOWN_POLYGONS_VALUES.length];const changePolySides=()=>{RENDER_INFO.currentPoly=getNextPolygon();RENDER_INFO.rotationTurns=0;PLAYER_ENTITY.selectedCellIndex=0;updateCompass();resetDirection();resetMap();};const resetDirection=()=>updateEntityDirection(PLAYER_ENTITY,MOVEMENT.UP);const updateAndGetSelectedCell=()=>{updateEntityDirection(PLAYER_ENTITY,PLAYER_ENTITY.currentDirection);return getSelectedCell(PLAYER_ENTITY);};const dig=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(!selectedCell?.block)return;if(selectedCell.entityType){makeEntityUse(PLAYER_ENTITY);const entities=getEntitiesFromCell(selectedCell);entities.forEach((e)=>hurtEntity(e,1));punchAudio.play();move();return;}if(selectedCell.block.isFluid)return;if(selectedCell.wall){if(selectedCell.wall.block.indestructible)return;}else if(selectedCell.block.indestructible)return;makeEntityUse(PLAYER_ENTITY);digAudio.play();if(selectedCell.wall){destroyWall(selectedCell);}else{selectedCell.block=null;selectedCell.color=null;}move();};const place=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.wall||selectedCell.entityType)return;makeEntityUse(PLAYER_ENTITY);placeBlock(selectedCell);move();};const placeBlock=(cell,block,color)=>{if(!cell||!!cell.entityType)return;if(!block){const cellBlock=getSelectedBlockToPlace();if(!cellBlock)return;block=cellBlock.block;color=cellBlock.color;}digAudio.play();if(cell.block&&!cell.block.isFluid){cell.wall={block:block,color:color};}else{cell.block=block;cell.color=color;}};const useBoat=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();const canMove=!selectedCell.wall&&selectedCell.block;if(PLAYER_ENTITY.connectedEntities[ENTITY_TYPES.BOAT]){if(!selectedCell?.block?.isFluid&&canMove){getOutBoat(PLAYER_ENTITY);move(selectedCell);}return;}if(selectedCell.entityType===ENTITY_TYPES.BOAT){getInBoat(PLAYER_ENTITY);move(selectedCell);}else if(canMove){makeEntityUse(PLAYER_ENTITY);addBoat(selectedCell,PLAYER_ENTITY);}};const useGun=()=>{const range=getPolyInfo().hasInverted?1:10;updateAndGetSelectedCell();gunShotAudio.currentTime=0;let{cell,selectedCellIndex}=PLAYER_ENTITY;for(let i=0;i<range;i++){const nextCell=getCell(getPosByIndex(cell,selectedCellIndex));if(nextCell.wall)break;cell=nextCell;drawCircleOnCell(cell,PLAYER_ENTITY);if(cell.entityType){const entities=getEntitiesFromCell(cell);entities.forEach((e)=>hurtEntity(e,1));break;}}gunShotAudio.play();move();};const useMap=(toggle)=>{if(IS_FISHING_ACTIVE||!canDoActions())return;toggleFullMap(toggle);};const useFishingRod=()=>{if(!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.block?.isFluid){makeEntityUse(PLAYER_ENTITY);startFishing();}};const resetMap=()=>{resetPlace();setEntitiesSize();resetCanvas();moveCurrentCell(getCenterCell(),PLAYER_ENTITY.cell);drawEveryCell(PLAYER_ENTITY);updateWeather();};const MOVEMENT_CONFIG={velocity:10,};const getCleanPos=(pos)=>({i:pos?.i||0,j:pos?.j||0});const moveCurrentCell=(oldCell,nextCell)=>{const oldPos=getCleanPos(oldCell?.pos);const nextPos=getCleanPos(nextCell?.pos);RENDER_INFO.iOffset+=nextPos.i-oldPos.i;RENDER_INFO.jOffset+=nextPos.j-oldPos.j;moveEntityToCell(PLAYER_ENTITY,nextCell);};let canMove=true;const move=(nextCell)=>{if(canMove&&PLAYER_ENTITY.health>0){canMove=false;if(nextCell)moveCurrentCell(PLAYER_ENTITY.cell,nextCell);if(MENU_CONFIG.passTime)passTime();setTimeout(()=>{drawEveryCell(PLAYER_ENTITY);killEntitiesByTimeOfDay();moveEntities(PLAYER_ENTITY.cell);spawnEntities(PLAYER_ENTITY.cell);canMove=true;},1000/MOVEMENT_CONFIG.velocity);}};const findAccessibleCell=(cell,entity)=>{let accessibleCell=cell;while(cellIsBlocked(accessibleCell,entity)){accessibleCell=loadAndGetCell({i:accessibleCell.pos.i+1,j:accessibleCell.pos.j,});}return accessibleCell;};const MOVEMENT_CONFIG={velocity:10,};const getCleanPos=(pos)=>({i:pos?.i||0,j:pos?.j||0});const moveCurrentCell=(oldCell,nextCell)=>{const oldPos=getCleanPos(oldCell?.pos);const nextPos=getCleanPos(nextCell?.pos);RENDER_INFO.iOffset+=nextPos.i-oldPos.i;RENDER_INFO.jOffset+=nextPos.j-oldPos.j;moveEntityToCell(PLAYER_ENTITY,nextCell);};let canMove=true;const move=(nextCell)=>{if(canMove&&PLAYER_ENTITY.health>0){canMove=false;if(nextCell)moveCurrentCell(PLAYER_ENTITY.cell,nextCell);if(MENU_CONFIG.passTime)passTime();setTimeout(()=>{drawEveryCell(PLAYER_ENTITY);killEntitiesByTimeOfDay();moveEntities(PLAYER_ENTITY.cell);spawnEntities(PLAYER_ENTITY.cell);canMove=true;},1000/MOVEMENT_CONFIG.velocity);}};const findAccessibleCell=(cell,entity)=>{let accessibleCell=cell;while(cellIsBlocked(accessibleCell,entity)){accessibleCell=loadAndGetCell({i:accessibleCell.pos.i+1,j:accessibleCell.pos.j,});}return accessibleCell;};const start=()=>{addEntity(PLAYER_ENTITY);configPolys();resetGrid();resetBiomes();removeGeneratedEntities();updateCanvasCss();resetDirection();PLAYER_ENTITY.cell=findAccessibleCell(loadAndGetCell(INITIAL_POS),PLAYER_ENTITY);resetToolbar();resetMap();};const resetSize=debounce((newSize)=>{RENDER_INFO.cellHeight=newSize||RENDER_INFO.cellHeight;configPolys();resetToolbar();resetMap();});const resetCanvas=()=>{const polyInfo=getPolyInfo();setCanvasSize(polyInfo.canvasHeight,polyInfo.canvasWidth);setFavicon();};const updateCanvasCss=()=>{updateConfigs();updateWeather();updateWidgets();};let filledThisRound=(new Set());let tracksCount=({});const addToTrackCount=(block)=>{if(block?.trackType)tracksCount[block.trackType]=(tracksCount[block.trackType]||0)+1;};const getAjacentCells=(cell,depth=1)=>{const result=[[cell]];for(let index=0;index<depth;index++){const cells=([]);const current=result[index];for(const element of current){if(!element)continue;const aCells=element.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);cells.push(...aCells.filter((c)=>!current.includes(c)&&!cells.includes(c)&&c!==cell));}result.push(cells);}return result;};const drawEveryCell=(baseEntity)=>{wallLayers=[];fluids=[];filledThisRound=new Set();tracksCount={};const offsetCell=baseEntity.cell.pos.j%2;const{rows,columns,shouldIntercalate}=getPolyInfo();const size=rows+columns;const adjacentCells=getAjacentCells(baseEntity.cell,DRAW_CONFIG.lightDepth);const selectedCell=getSelectedCell(baseEntity);for(let i=-columns;i<size;i++){const baseI=i+RENDER_INFO.iOffset;for(let j=-rows;j<size;j++){let nI=baseI;const nJ=j+RENDER_INFO.jOffset;const pos={i:nI,j:nJ};if(shouldIntercalate&&offsetCell&&nJ%2===0)nI=nI+1;drawCell(loadAndGetCell(pos),contextsLayers[0],baseEntity,adjacentCells,selectedCell);}}drawWalls();updateEntities();tweakFluids();updateBiomeMap();updateTracks(tracksCount);};let wallLayers=([]);const drawWalls=()=>{for(let i=1;i<DRAW_CONFIG.maxLayer;i++){const walls=wallLayers[i];clearCanvas(canvasLayers[i]);if(!walls)continue;walls.forEach((w)=>drawWall(w,contextsLayers[i]));walls.forEach((w)=>drawWallTop(w,contextsLayers[i]));}wallLayers=[];};let fluidInterval=null;let fluids=([]);const tweakFluids=debounce(()=>{clearInterval(fluidInterval);if(!fluids.length)return;const context=contextsLayers[0];fluidInterval=setInterval(()=>{fluids.forEach((fluid)=>{drawItem(context,{...fluid,color:tweakColor(fluid.color),});});},DRAW_CONFIG.fluidSpeed);},DRAW_CONFIG.fluidSpeed);const drawCell=(cell,context,baseEntity,adjacentCells,selectedCell)=>{const polyInfo=getPolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const point=calculatePointBasedOnPos(cell.pos,isInverted,baseEntity.cell);if(isPointOutside(point,polyInfo.canvasHeight,polyInfo.canvasWidth))return;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const aCells=cell.adjacentPos[RENDER_INFO.currentPoly].map(getCell);const isSelectedCell=MENU_CONFIG.showSelectedCell&&cell===selectedCell;cell.modifier=getStyleModifier(adjacentCells.findIndex((c)=>c.includes(cell)));addToTrackCount(cell.wall?.block||cell.block);if(cell.wall){const wallLayer=cell.layer+1;const shouldOffset=polyInfo.hasInverted&&!cell.isInverted;if(!wallLayers[wallLayer])wallLayers[wallLayer]=[];wallLayers[wallLayer].push(blockToWall(cell.wall,point,{layer:cell.layer,isInverted,modifier:cell.modifier,isSelectedCell,pos:cell.pos,borderMap:aCells.reduce((acc,c,i)=>{let index=i-RENDER_INFO.rotationTurns;if(shouldOffset)index=RENDER_INFO.currentPoly-1-index;acc[getMod(index,RENDER_INFO.currentPoly)]=!c?.wall;return acc;},[]),}));return;}if(!cell.block){const aFluid=aCells.find((c)=>c?.block?.isFluid);if(aFluid&&!filledThisRound.has(aFluid.pos)){filledThisRound.add(cell.pos);cell.block=aFluid.block;cell.color=aFluid.color;}}const drawable=({point,points,isInverted,pos:cell.pos,color:cell.color,modifier:cell.modifier,isSelectedCell,});if(cell.block?.isFluid)fluids.push(drawable);drawItem(context,drawable);if(cell.block===MINE_BLOCKS.MINES_LOW){const aCellsCorner=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);showMineValue(context,aCellsCorner.reduce((acc,c)=>(c.hasBomb?acc+1:acc),0),point,isInverted,polyInfo.ySide);}};const drawCircleOnCell=(cell,baseEntity)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(cell.pos,hasInverted&&cell.isInverted,baseEntity.cell);drawCircle(contextsLayers[0],point,ySide/4);};const start=()=>{addEntity(PLAYER_ENTITY);configPolys();resetGrid();resetBiomes();removeGeneratedEntities();updateCanvasCss();resetDirection();PLAYER_ENTITY.cell=findAccessibleCell(loadAndGetCell(INITIAL_POS),PLAYER_ENTITY);resetToolbar();resetMap();};const resetSize=debounce((newSize)=>{RENDER_INFO.cellHeight=newSize||RENDER_INFO.cellHeight;configPolys();resetToolbar();resetMap();});const CONTROLS_CONFIG={minZoom:12,maxZoom:120,};const CONTROLS_CONFIG={minZoom:12,maxZoom:120,};const addDebugBlockToPoint=({x,y})=>{if(!MENU_CONFIG.debugMode||RENDER_INFO.rotationTurns)return;if(MENU_CONFIG.usePerspective){x-=175;y+=60;}const cell=getCell(calculatePosBasedOnPoint({x,y}));const block=BLOCKS.ROCK;if(cell.wall)cell.wall=null;else placeBlock(cell,block,block.color);drawEveryCell(PLAYER_ENTITY);};const getJFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(x)=>(x-xSide)/(polySide/2);case KNOWN_POLYGONS.HEXAGON:return(x)=>(x-xSide)/(xSide+polySide/2);case KNOWN_POLYGONS.SQUARE:default:return(x)=>(x-xSide)/(xSide*2);}};const calcI=(y,ySide,shouldIntercalate,evenJ)=>{let dividend=y-ySide;if(shouldIntercalate){if(PLAYER_ENTITY.cell.pos.j%2&&!evenJ){dividend+=ySide;}else if(!(PLAYER_ENTITY.cell.pos.j%2)&&evenJ){dividend-=ySide;}}return dividend/(ySide*2);};const calculatePosBasedOnPoint=({x,y})=>{const{xSide,ySide,shouldIntercalate,polySide}=getPolyInfo();let j=getJFn(RENDER_INFO.currentPoly,polySide,xSide)(x);j=Math.round(j+(RENDER_INFO.jOffset||0));let i=calcI(y,ySide,shouldIntercalate,!!(j%2));i+=RENDER_INFO.iOffset||0;return{i:Math.round(i),j:j};};const MAZE_CANVAS_CONFIG={defaultColor:"#cdcdcd",};const drawMaze=(context,mazeObj)=>{for(const pos of mazeObj.iterateOverMaze()){drawCellMaze(context,mazeObj,mazeObj.getMazeCell(pos));}};const drawCellMaze=(context,mazeObj,cell,color)=>{context.fillStyle=color?getFillStyle(color):MAZE_CANVAS_CONFIG.defaultColor;if(cell.circleProps)drawCellMazeCircle(context,cell,mazeObj.getCirclePoint());else drawCellMazePolygon(context,mazeObj,cell);};const drawCellMazePolygon=(context,mazeObj,cell)=>{const polyInfo=mazeObj.getMazePolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const borders=polyInfo.hasInverted&&!cell.isInverted?cell.invertedBorders:cell.borders;fillPolygon(context,cell.point,points);applyBorders(context,cell.point,points,borders);if(MENU_CONFIG.showPos&&cell.pos)showPos(context,cell.pos,cell.point,isInverted,polyInfo.ySide);};const drawCellMazeCircle=(context,cell,circlePoint)=>{const{topRadius,bottomRadius,topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,}=cell.circleProps;context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.closePath();context.fill();if(cell.borders[0]){context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.stroke();}if(cell.borders[1]){context.beginPath();context.moveTo(topRightPoint.x,topRightPoint.y);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.stroke();}if(cell.borders[2]){context.beginPath();context.moveTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.stroke();}if(cell.borders[3]){context.beginPath();context.moveTo(bottomLeftPoint.x,bottomLeftPoint.y);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.stroke();}};const addDebugBlockToPoint=({x,y})=>{if(!MENU_CONFIG.debugMode||RENDER_INFO.rotationTurns)return;if(MENU_CONFIG.usePerspective){x-=175;y+=60;}const cell=getCell(calculatePosBasedOnPoint({x,y}));const block=BLOCKS.ROCK;if(cell.wall)cell.wall=null;else placeBlock(cell,block,block.color);drawEveryCell(PLAYER_ENTITY);};const getJFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(x)=>(x-xSide)/(polySide/2);case KNOWN_POLYGONS.HEXAGON:return(x)=>(x-xSide)/(xSide+polySide/2);case KNOWN_POLYGONS.SQUARE:default:return(x)=>(x-xSide)/(xSide*2);}};const calcI=(y,ySide,shouldIntercalate,evenJ)=>{let dividend=y-ySide;if(shouldIntercalate){if(PLAYER_ENTITY.cell.pos.j%2&&!evenJ){dividend+=ySide;}else if(!(PLAYER_ENTITY.cell.pos.j%2)&&evenJ){dividend-=ySide;}}return dividend/(ySide*2);};const calculatePosBasedOnPoint=({x,y})=>{const{xSide,ySide,shouldIntercalate,polySide}=getPolyInfo();let j=getJFn(RENDER_INFO.currentPoly,polySide,xSide)(x);j=Math.round(j+(RENDER_INFO.jOffset||0));let i=calcI(y,ySide,shouldIntercalate,!!(j%2));i+=RENDER_INFO.iOffset||0;return{i:Math.round(i),j:j};};(()=>{const SELECT_OPTIONS={mapGeneration:Object.entries(MAP_GENERATION),};document.querySelectorAll("#menu label").forEach((l)=>{const config=(l).htmlFor;const element=(document.getElementById(config));if(!element)return;if(element.type==="checkbox"){const check=(element);check.checked=MENU_CONFIG[config];check.onchange=()=>{MENU_CONFIG[config]=check.checked;updateCanvasCss();drawEveryCell(PLAYER_ENTITY);check.blur();};}else if(element.tagName==="SELECT"){const select=(element);SELECT_OPTIONS[config].forEach(([key,value])=>{const option=document.createElement("option");option.value=value;option.innerHTML=key;select.appendChild(option);});select.value=MENU_CONFIG[config];select.onchange=()=>{MENU_CONFIG[config]=select.value;start();select.blur();};}});const teleportationIElement=(document.getElementById("teleportation-i"));const teleportationJElement=(document.getElementById("teleportation-j"));const teleportationBtn=(document.getElementById("teleport"));teleportationBtn.onclick=()=>{const i=+teleportationIElement.value;const j=+teleportationJElement.value;move(loadAndGetCell({i,j}));teleportationBtn.blur();};const zoomSlider=(document.getElementById("zoom"));zoomSlider.value=`${RENDER_INFO.cellHeight}`;zoomSlider.min=`${CONTROLS_CONFIG.minZoom}`;zoomSlider.max=`${CONTROLS_CONFIG.maxZoom}`;zoomSlider.oninput=()=>{resetSize(+zoomSlider.value);zoomSlider.blur();};const musicVolumeSlider=(document.getElementById("musicVolume"));musicVolumeSlider.value=`50`;musicVolumeSlider.min=`0`;musicVolumeSlider.max=`100`;musicVolumeSlider.oninput=()=>{setMusicVolume(+musicVolumeSlider.value);musicVolumeSlider.blur();};setMusicVolume(+musicVolumeSlider.value);})();(()=>{const SELECT_OPTIONS={mapGeneration:Object.entries(MAP_GENERATION),};document.querySelectorAll("#menu label").forEach((l)=>{const config=(l).htmlFor;const element=(document.getElementById(config));if(!element)return;if(element.type==="checkbox"){const check=(element);check.checked=MENU_CONFIG[config];check.onchange=()=>{MENU_CONFIG[config]=check.checked;updateCanvasCss();drawEveryCell(PLAYER_ENTITY);check.blur();};}else if(element.tagName==="SELECT"){const select=(element);SELECT_OPTIONS[config].forEach(([key,value])=>{const option=document.createElement("option");option.value=value;option.innerHTML=key;select.appendChild(option);});select.value=MENU_CONFIG[config];select.onchange=()=>{MENU_CONFIG[config]=select.value;start();select.blur();};}});const teleportationIElement=(document.getElementById("teleportation-i"));const teleportationJElement=(document.getElementById("teleportation-j"));const teleportationBtn=(document.getElementById("teleport"));teleportationBtn.onclick=()=>{const i=+teleportationIElement.value;const j=+teleportationJElement.value;move(loadAndGetCell({i,j}));teleportationBtn.blur();};const zoomSlider=(document.getElementById("zoom"));zoomSlider.value=`${RENDER_INFO.cellHeight}`;zoomSlider.min=`${CONTROLS_CONFIG.minZoom}`;zoomSlider.max=`${CONTROLS_CONFIG.maxZoom}`;zoomSlider.oninput=()=>{resetSize(+zoomSlider.value);zoomSlider.blur();};const musicVolumeSlider=(document.getElementById("musicVolume"));musicVolumeSlider.value=`50`;musicVolumeSlider.min=`0`;musicVolumeSlider.max=`100`;musicVolumeSlider.oninput=()=>{setMusicVolume(+musicVolumeSlider.value);musicVolumeSlider.blur();};setMusicVolume(+musicVolumeSlider.value);})();(()=>{let mobileZoom=0;canvasContainer.ontouchstart=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];mobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);return;}};canvasContainer.ontouchmove=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];const nMobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);if(nMobileZoom>mobileZoom&&RENDER_INFO.cellHeight<CONTROLS_CONFIG.maxZoom){resetSize(RENDER_INFO.cellHeight+1);}else if(nMobileZoom<mobileZoom&&RENDER_INFO.cellHeight>CONTROLS_CONFIG.minZoom){resetSize(RENDER_INFO.cellHeight-1);}mobileZoom=nMobileZoom;}};canvasContainer.ontouchend=()=>{mobileZoom=0;};document.getElementById("change-poly").onclick=()=>{changePolySides();updatePolyImages();};document.getElementById("rotate-left").onclick=()=>rotate(-1);document.getElementById("rotate-right").onclick=()=>rotate(1);const currentPoly=(document.getElementById("current-poly"));const nextPoly=(document.getElementById("next-poly"));const updatePolyImages=()=>{setImagePos(currentPoly,POLYGONS_ENTITY_POS[RENDER_INFO.currentPoly]);setImagePos(nextPoly,POLYGONS_ENTITY_POS[getNextPolygon()]);};updatePolyImages();})();(()=>{let mobileZoom=0;canvasContainer.ontouchstart=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];mobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);return;}};canvasContainer.ontouchmove=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];const nMobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);if(nMobileZoom>mobileZoom&&RENDER_INFO.cellHeight<CONTROLS_CONFIG.maxZoom){resetSize(RENDER_INFO.cellHeight+1);}else if(nMobileZoom<mobileZoom&&RENDER_INFO.cellHeight>CONTROLS_CONFIG.minZoom){resetSize(RENDER_INFO.cellHeight-1);}mobileZoom=nMobileZoom;}};canvasContainer.ontouchend=()=>{mobileZoom=0;};document.getElementById("change-poly").onclick=()=>{changePolySides();updatePolyImages();};document.getElementById("rotate-left").onclick=()=>rotate(-1);document.getElementById("rotate-right").onclick=()=>rotate(1);const currentPoly=(document.getElementById("current-poly"));const nextPoly=(document.getElementById("next-poly"));const updatePolyImages=()=>{setImagePos(currentPoly,POLYGONS_ENTITY_POS[RENDER_INFO.currentPoly]);setImagePos(nextPoly,POLYGONS_ENTITY_POS[getNextPolygon()]);};updatePolyImages();})();const canvasLayers =([]);const contextsLayers =([]);for (let i =0;i <DRAW_CONFIG.maxLayer;i++){const canvas =document.createElement("canvas");canvasContainer.appendChild(canvas);canvasLayers.push(canvas);contextsLayers.push(canvas.getContext("2d"));}const setCanvasSize =(height,width)=>{drawContainer.style.setProperty("--canvas-height",`${height}px`);canvasLayers.forEach((canvas)=>(canvas.height =height));drawContainer.style.setProperty("--canvas-width",`${width}px`);canvasLayers.forEach((canvas)=>(canvas.width =width));};const setFavicon =()=>{const link =(document.querySelector("link[rel~='icon']"));link.href=POLYGONS_IMAGES[RENDER_INFO.currentPoly];};const updateConfigs=()=>{canvasContainer.classList[MENU_CONFIG.usePerspective?"add":"remove"]("perspective");};const clearCanvas=(canvas)=>{canvas.width=canvas.width;};const drawWall=(wall,context)=>{if(!wall.borderMap||wall.borderMap.find((b)=>!!b))drawItem(context,wall);};const drawWallTop=(wall,context)=>{drawItem(context,wall.topInfo);context.strokeStyle=wall.isSelectedCell?RENDER_CONFIG.selectedBorderColor:RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,wall.topInfo.point,wall.topInfo.points,wall.borderMap);};const drawItem=(context,{point,points,pos,isInverted,color,modifier,isSelectedCell})=>{context.fillStyle=color?getFillStyle(color,modifier):RENDER_CONFIG.emptyColor;fillPolygon(context,point,points);if(MENU_CONFIG.showPos&&pos)showPos(context,pos,point,isInverted,getPolyInfo().ySide);if(isSelectedCell){context.strokeStyle=RENDER_CONFIG.selectedBorderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}else if(MENU_CONFIG.showChunks&&pos)showChunks(context,pos,point,points);};const getFillStyle=(color,modifier=1)=>color===EMPTY_BLOCK.color?"transparent":`rgb(`+`${color.r *modifier},`+`${color.g *modifier},`+`${color.b *modifier})`;const getStyleModifier=(intensity)=>{if(!ENTITY_INFO.timeOfDay)return 1;let modifier=1-ENTITY_INFO.timeOfDay/100;if(intensity>=0)modifier=(1-modifier)/(intensity||1)+modifier;return modifier;};const fillPolygon=(context,{x,y},points)=>{context.beginPath();for(const point of points){context.lineTo(x+point.x,y+point.y);}context.closePath();context.fill();};const applyBorders=(context,{x,y},points,map,ignoreLast)=>{for(let i=0;i<points.length;i++){if(!map?.length||map[i]){const point=points[i];let nextPoint=points[i+1];if(!nextPoint){if(ignoreLast)return;nextPoint=points[0];}const pointA={x:x+point.x,y:y+point.y};const pointB={x:x+nextPoint.x,y:y+nextPoint.y};drawLine(context,pointA,pointB);}}};const drawLine=(context,pointA,pointB)=>{context.beginPath();context.moveTo(pointA.x,pointA.y);context.lineTo(pointB.x,pointB.y);context.stroke();};const showPos=(context,pos,point,isInverted,ySide)=>{context.fillStyle="black";context.font=`bold ${ySide /2}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${pos.i},${pos.j}`,point.x,isInverted?point.y+ySide/2:point.y);};const showChunks=(context,pos,point,points)=>{if(pos.i%GENERATION_CONFIG.chunkSize===0||pos.j%GENERATION_CONFIG.chunkSize===0){context.strokeStyle=RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}};const mineValueColors=["blue","green","red","darkblue","brown","darkred","black","grey",];const showMineValue=(context,value,point,isInverted,ySide)=>{if(value){context.fillStyle=mineValueColors[value-1];context.font=`bold ${ySide}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${value}`,point.x,isInverted?point.y+ySide/2:point.y);}};const drawCircle=(context,point,radius)=>{context.beginPath();context.arc(point.x,point.y,radius,0,2*Math.PI);context.fillStyle="black";context.fill();};(()=>{const SELECTION_STICK_CONFIG={touchThreshold:20,};const selectionStickLeft=document.getElementById("selection-stick-left");const selectionStickRight=document.getElementById("selection-stick-right");const SELECTION_STICK_INFO=(()=>{const maxPoint=selectionStickLeft.offsetWidth/1.25;const minPoint=selectionStickLeft.offsetWidth/5;const midPoint=minPoint+(maxPoint-minPoint)/2;const maxMidPoint=midPoint+SELECTION_STICK_CONFIG.touchThreshold;const minMidPoint=midPoint-SELECTION_STICK_CONFIG.touchThreshold;return{maxPoint,minPoint,midPoint,maxMidPoint,minMidPoint};})();const moveStick=(e,stickElement)=>{e=e||(window.event);e.preventDefault();e.stopPropagation();const{clientX,clientY}=e.touches[0];const stickRect=stickElement.getBoundingClientRect();let finalX=clientX-stickRect.left;let finalY=clientY-stickRect.top;finalX=Math.min(finalX,SELECTION_STICK_INFO.maxPoint);finalX=Math.max(finalX,SELECTION_STICK_INFO.minPoint);finalY=Math.min(finalY,SELECTION_STICK_INFO.maxPoint);finalY=Math.max(finalY,SELECTION_STICK_INFO.minPoint);stickElement.style.setProperty("--selection-stick-left",`${finalX}px`);stickElement.style.setProperty("--selection-stick-top",`${finalY}px`);let code=null;const useDiagonal=finalY>SELECTION_STICK_INFO.maxMidPoint;if(useDiagonal)code=MOVEMENT.DOWN;if(finalY<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.UP;if(finalX>SELECTION_STICK_INFO.maxMidPoint)code=MOVEMENT.RIGHT;if(finalX<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.LEFT;return{code,useDiagonal};};selectionStickLeft.ontouchstart=selectionStickLeft.ontouchmove=(e)=>{const{code,useDiagonal}=moveStick(e,selectionStickLeft);if(code)changeSelectedOnCode(code,useDiagonal);};let rightStickInfo=({});const updateRightStickInfo=(e)=>(rightStickInfo=moveStick(e,selectionStickRight));selectionStickRight.ontouchstart=(e)=>{clearInterval(rightStickInfo.interval);updateRightStickInfo(e);rightStickInfo.interval=setInterval(()=>{if(rightStickInfo.code)moveBaseOnCode(rightStickInfo.code,rightStickInfo.useDiagonal);else stopMoving();},100);};selectionStickRight.ontouchmove=updateRightStickInfo;document.ontouchend=()=>{selectionStickLeft?.style.removeProperty("--selection-stick-left");selectionStickLeft?.style.removeProperty("--selection-stick-top");selectionStickRight?.style.removeProperty("--selection-stick-left");selectionStickRight?.style.removeProperty("--selection-stick-top");stopMoving();clearInterval(rightStickInfo.interval);rightStickInfo={code:null,useDiagonal:null,interval:null};};})();(()=>{const SELECTION_STICK_CONFIG={touchThreshold:20,};const selectionStickLeft=document.getElementById("selection-stick-left");const selectionStickRight=document.getElementById("selection-stick-right");const SELECTION_STICK_INFO=(()=>{const maxPoint=selectionStickLeft.offsetWidth/1.25;const minPoint=selectionStickLeft.offsetWidth/5;const midPoint=minPoint+(maxPoint-minPoint)/2;const maxMidPoint=midPoint+SELECTION_STICK_CONFIG.touchThreshold;const minMidPoint=midPoint-SELECTION_STICK_CONFIG.touchThreshold;return{maxPoint,minPoint,midPoint,maxMidPoint,minMidPoint};})();const moveStick=(e,stickElement)=>{e=e||(window.event);e.preventDefault();e.stopPropagation();const{clientX,clientY}=e.touches[0];const stickRect=stickElement.getBoundingClientRect();let finalX=clientX-stickRect.left;let finalY=clientY-stickRect.top;finalX=Math.min(finalX,SELECTION_STICK_INFO.maxPoint);finalX=Math.max(finalX,SELECTION_STICK_INFO.minPoint);finalY=Math.min(finalY,SELECTION_STICK_INFO.maxPoint);finalY=Math.max(finalY,SELECTION_STICK_INFO.minPoint);stickElement.style.setProperty("--selection-stick-left",`${finalX}px`);stickElement.style.setProperty("--selection-stick-top",`${finalY}px`);let code=null;const useDiagonal=finalY>SELECTION_STICK_INFO.maxMidPoint;if(useDiagonal)code=MOVEMENT.DOWN;if(finalY<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.UP;if(finalX>SELECTION_STICK_INFO.maxMidPoint)code=MOVEMENT.RIGHT;if(finalX<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.LEFT;return{code,useDiagonal};};selectionStickLeft.ontouchstart=selectionStickLeft.ontouchmove=(e)=>{const{code,useDiagonal}=moveStick(e,selectionStickLeft);if(code)changeSelectedOnCode(code,useDiagonal);};let rightStickInfo=({});const updateRightStickInfo=(e)=>(rightStickInfo=moveStick(e,selectionStickRight));selectionStickRight.ontouchstart=(e)=>{clearInterval(rightStickInfo.interval);updateRightStickInfo(e);rightStickInfo.interval=setInterval(()=>{if(rightStickInfo.code)moveBaseOnCode(rightStickInfo.code,rightStickInfo.useDiagonal);else stopMoving();},100);};selectionStickRight.ontouchmove=updateRightStickInfo;document.ontouchend=()=>{selectionStickLeft?.style.removeProperty("--selection-stick-left");selectionStickLeft?.style.removeProperty("--selection-stick-top");selectionStickRight?.style.removeProperty("--selection-stick-left");selectionStickRight?.style.removeProperty("--selection-stick-top");stopMoving();clearInterval(rightStickInfo.interval);rightStickInfo={code:null,useDiagonal:null,interval:null};};})();(()=>{const KEY_MOVEMENT_MAP={["KeyW"]:MOVEMENT.UP,["KeyA"]:MOVEMENT.LEFT,["KeyS"]:MOVEMENT.DOWN,["KeyD"]:MOVEMENT.RIGHT,};const ARROW_MOVEMENT_MAP={["ArrowUp"]:MOVEMENT.UP,["ArrowLeft"]:MOVEMENT.LEFT,["ArrowDown"]:MOVEMENT.DOWN,["ArrowRight"]:MOVEMENT.RIGHT,};let selectedToolbarIndex=1;const TOOLBAR_ACTIONS=[undefined,document.getElementById("toolbar-dig"),document.getElementById("toolbar-place"),document.getElementById("toolbar-fishing"),document.getElementById("toolbar-boat"),document.getElementById("toolbar-gun"),document.getElementById("toolbar-map"),];const MOVEMENT_KEYS=Object.keys(KEY_MOVEMENT_MAP);const menuToggle=(document.getElementById("menuToggle"));const closeDebugMenu=()=>(menuToggle.checked=false);document.onkeydown=(e)=>{e=e||(window.event);const targetElement=(e.target);if(targetElement.tagName==="INPUT"&&targetElement.id!=="menuToggle")return;if(e.code==="KeyR")movePlaceBlocks(e.altKey?-1:1);if(e.code.startsWith("Arrow"))return moveBaseOnCode(ARROW_MOVEMENT_MAP[e.code],e.altKey);if(e.code.startsWith("Digit")||e.code.startsWith("Numpad"))return updateToolbarSelected(+e.code.replace(/Numpad|Digit/gi,""));if(MOVEMENT_KEYS.includes(e.code))return changeSelectedOnCode(KEY_MOVEMENT_MAP[e.code],e.altKey);if(e.code==="KeyQ")return rotate(-1);if(e.code==="KeyE")return rotate(1);if(e.code==="KeyF")return TOOLBAR_ACTIONS[selectedToolbarIndex].onclick(null);if(e.code.includes("Shift"))return changePolySides();if(e.code==="Space")return move();if(e.code==="Escape"){closeDebugMenu();useMap(false);}};document.onkeyup=()=>{stopMoving();};const updateToolbarSelected=(keyIndex)=>{const element=TOOLBAR_ACTIONS[keyIndex];if(!element)return;TOOLBAR_ACTIONS[selectedToolbarIndex].classList.remove("toolbar-selected");selectedToolbarIndex=keyIndex;element.classList.add("toolbar-selected");};document.onwheel=(e)=>{e=e||(window.event);updateToolbarSelected(e.deltaY<0?selectedToolbarIndex-1:selectedToolbarIndex+1);};updateToolbarSelected(selectedToolbarIndex);TOOLBAR_ACTIONS[1].onclick=()=>dig();const toolbarPlace=document.getElementById("toolbar-place");TOOLBAR_ACTIONS[2].onclick=(e)=>{if(e){const{top}=toolbarPlace.getBoundingClientRect();const y=e.clientY-top;if(y<0)return movePlaceBlocks(-1);if(y>toolbarPlace.offsetHeight)return movePlaceBlocks(1);}place();};TOOLBAR_ACTIONS[3].onclick=()=>useFishingRod();TOOLBAR_ACTIONS[4].onclick=()=>useBoat();TOOLBAR_ACTIONS[5].onclick=()=>useGun();TOOLBAR_ACTIONS[6].onclick=()=>useMap();canvasContainer.onclick=(e)=>{e=e||(window.event);if(MENU_CONFIG.debugMode){const{left,top}=canvasContainer.getBoundingClientRect();const x=e.clientX-left;const y=e.clientY-top;addDebugBlockToPoint({x,y});}closeDebugMenu();stopFishing();};})();const audios=({});let MUSIC_VOLUME=1;const TRACK_FILES={[TRACK_TYPES.TRACK1]:"sounds/blocks/track1.wav",[TRACK_TYPES.TRACK2]:"sounds/blocks/track2.wav",[TRACK_TYPES.TRACK3]:"sounds/blocks/track3.wav",[TRACK_TYPES.TRACK4]:"sounds/blocks/track4.wav",[TRACK_TYPES.TRACK5]:"sounds/blocks/track5.wav",[TRACK_TYPES.TRACK6]:"sounds/blocks/track6.wav",[TRACK_TYPES.TRACK7]:"sounds/blocks/track7.wav",[TRACK_TYPES.TRACK8]:"sounds/blocks/track8.wav",[TRACK_TYPES.TRACK11]:"sounds/blocks/track11.wav",[TRACK_TYPES.TRACK14]:"sounds/blocks/track14.wav",[TRACK_TYPES.TRACK15]:"sounds/blocks/track15.wav",[TRACK_TYPES.TRACK16]:"sounds/blocks/track16.wav",};Object.entries(TRACK_FILES).forEach(([track,path])=>{const pan=+track.replace("TRACK","")%2?-1:1;const ctx=new AudioContext();const srcNode=ctx.createBufferSource();const gainNode=ctx.createGain();gainNode.gain.value=0;gainNode.connect(ctx.destination);const ambientPan=ctx.createStereoPanner();ambientPan.pan.value=pan;ambientPan.connect(gainNode);audios[track]={srcNode,gainNode,volume:0};fetch(path,{mode:"cors"}).then((resp)=>resp.arrayBuffer()).then((buffer)=>ctx.decodeAudioData(buffer,(abuffer)=>{srcNode.buffer=abuffer;srcNode.connect(ambientPan);srcNode.loop=true;srcNode.loopEnd=35.99;}));});const audiosList=Object.values(audios);const TRACK_LIST=Object.keys(TRACK_FILES);let audioStarted=false;const updateTracks=(tracksCount)=>{if(MENU_CONFIG.music){const polyInfo=getPolyInfo();const max=polyInfo.rows*polyInfo.columns*1.2;TRACK_LIST.forEach((track)=>{const audio=audios[track];audio.volume=(tracksCount[track]||0)/max;updateTrackVolume(audio);if(!audioStarted)audio.srcNode.start();});audioStarted=true;}else{audiosList.forEach((a)=>(a.gainNode.gain.value=0));}};const setMusicVolume=(volume)=>{MUSIC_VOLUME=volume;TRACK_LIST.forEach((track)=>updateTrackVolume(audios[track]));};const updateTrackVolume=(audio)=>{const{gainNode,volume}=audio;gainNode.gain.value=(MUSIC_VOLUME*volume)/100;};start();window.onresize=()=>{resetSize();};(()=>{const KEY_MOVEMENT_MAP={["KeyW"]:MOVEMENT.UP,["KeyA"]:MOVEMENT.LEFT,["KeyS"]:MOVEMENT.DOWN,["KeyD"]:MOVEMENT.RIGHT,};const ARROW_MOVEMENT_MAP={["ArrowUp"]:MOVEMENT.UP,["ArrowLeft"]:MOVEMENT.LEFT,["ArrowDown"]:MOVEMENT.DOWN,["ArrowRight"]:MOVEMENT.RIGHT,};let selectedToolbarIndex=1;const TOOLBAR_ACTIONS=[undefined,document.getElementById("toolbar-dig"),document.getElementById("toolbar-place"),document.getElementById("toolbar-fishing"),document.getElementById("toolbar-boat"),document.getElementById("toolbar-gun"),document.getElementById("toolbar-map"),];const MOVEMENT_KEYS=Object.keys(KEY_MOVEMENT_MAP);const menuToggle=(document.getElementById("menuToggle"));const closeDebugMenu=()=>(menuToggle.checked=false);document.onkeydown=(e)=>{e=e||(window.event);const targetElement=(e.target);if(targetElement.tagName==="INPUT"&&targetElement.id!=="menuToggle")return;if(e.code==="KeyR")movePlaceBlocks(e.altKey?-1:1);if(e.code.startsWith("Arrow"))return moveBaseOnCode(ARROW_MOVEMENT_MAP[e.code],e.altKey);if(e.code.startsWith("Digit")||e.code.startsWith("Numpad"))return updateToolbarSelected(+e.code.replace(/Numpad|Digit/gi,""));if(MOVEMENT_KEYS.includes(e.code))return changeSelectedOnCode(KEY_MOVEMENT_MAP[e.code],e.altKey);if(e.code==="KeyQ")return rotate(-1);if(e.code==="KeyE")return rotate(1);if(e.code==="KeyF")return TOOLBAR_ACTIONS[selectedToolbarIndex].onclick(null);if(e.code.includes("Shift"))return changePolySides();if(e.code==="Space")return move();if(e.code==="Escape"){closeDebugMenu();useMap(false);}};document.onkeyup=()=>{stopMoving();};const updateToolbarSelected=(keyIndex)=>{const element=TOOLBAR_ACTIONS[keyIndex];if(!element)return;TOOLBAR_ACTIONS[selectedToolbarIndex].classList.remove("toolbar-selected");selectedToolbarIndex=keyIndex;element.classList.add("toolbar-selected");};document.onwheel=(e)=>{e=e||(window.event);updateToolbarSelected(e.deltaY<0?selectedToolbarIndex-1:selectedToolbarIndex+1);};updateToolbarSelected(selectedToolbarIndex);TOOLBAR_ACTIONS[1].onclick=()=>dig();const toolbarPlace=document.getElementById("toolbar-place");TOOLBAR_ACTIONS[2].onclick=(e)=>{if(e){const{top}=toolbarPlace.getBoundingClientRect();const y=e.clientY-top;if(y<0)return movePlaceBlocks(-1);if(y>toolbarPlace.offsetHeight)return movePlaceBlocks(1);}place();};TOOLBAR_ACTIONS[3].onclick=()=>useFishingRod();TOOLBAR_ACTIONS[4].onclick=()=>useBoat();TOOLBAR_ACTIONS[5].onclick=()=>useGun();TOOLBAR_ACTIONS[6].onclick=()=>useMap();canvasContainer.onclick=(e)=>{e=e||(window.event);if(MENU_CONFIG.debugMode){const{left,top}=canvasContainer.getBoundingClientRect();const x=e.clientX-left;const y=e.clientY-top;addDebugBlockToPoint({x,y});}closeDebugMenu();stopFishing();};})();start();window.onresize=()=>{resetSize();};const createMazeObj=(mazeInfos,mazeCircleInfos)=>{let MAZE_GRID=([]);const MAZE_POLYS_INFO=({});const getMazePolyInfo=()=>MAZE_POLYS_INFO[RENDER_INFO.currentPoly];const CIRCLE_INFO=({cellHeight:0,center:null,rows:0,columns:0,});const MAZE_INFO=({rows:0,columns:0,isCircle:false,currentCell:null,queue:[],});const getMazeCell=({i,j})=>MAZE_GRID[i]?.[j];function*iterateOverMaze(){const rows=getMazeRows();for(let i=0;i<rows;i++){const numCells=getNumCellsPerMazeRow(i);for(let j=0;j<numCells;j++){yield{i,j};}}}const createMazeGrid=()=>{MAZE_GRID=[];for(const{i,j}of iterateOverMaze()){MAZE_GRID[i]=MAZE_GRID[i]||[];MAZE_GRID[i][j]=createCellMaze({i,j});}};const createCellMaze=(pos)=>{const cell=(createCellProps(pos));cell.visited=false;cell.solved=false;cell.path=false;cell.borders=[...new Array(RENDER_INFO.currentPoly)].map(()=>true);if(MAZE_INFO.isCircle)createCircleCellMaze(cell);else cell.point=calculateMazePoint(pos);return cell;};const calculateMazePoint=({i,j})=>{const{calcX,calcY,ySide,shouldIntercalate}=getMazePolyInfo();const x=calcX(j);let y=calcY(i);if(shouldIntercalate&&j%2)y+=ySide;return{x,y};};const getMazeRows=()=>MAZE_INFO.isCircle?CIRCLE_INFO.rows:MAZE_INFO.rows;const getNumCellsPerMazeRow=(rowIndex)=>MAZE_INFO.isCircle?CIRCLE_INFO.columns-Math.floor((rowIndex+1)/2):MAZE_INFO.columns;const createCircleCellMaze=(cell)=>{const{i,j}=cell.pos;const topRadius=(CIRCLE_INFO.rows-i)*CIRCLE_INFO.cellHeight;const bottomRadius=topRadius-CIRCLE_INFO.cellHeight;const topAngle=Math.atan2(-topRadius,0);const bottomAngle=bottomRadius?topAngle:0;const numCells=getNumCellsPerMazeRow(i);const parts=(Math.PI*1.5-topAngle)/numCells;const leftBorder=j*parts;const rightBorder=(j+1)*parts;const topLeftAngle=topAngle+leftBorder;const topRightAngle=topAngle+rightBorder;const bottomLeftAngle=bottomAngle+leftBorder;const bottomRightAngle=bottomAngle+rightBorder;const topLeftPoint=getMazePoint(topRadius,topLeftAngle);const topRightPoint=getMazePoint(topRadius,topRightAngle);const bottomLeftPoint=getMazePoint(bottomRadius,bottomLeftAngle);const bottomRightPoint=getMazePoint(bottomRadius,bottomRightAngle);const points=[getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topLeftAngle),getMazePoint(topRadius+CIRCLE_INFO.cellHeight/2,topRightAngle),];const x=points.reduce((acc,p)=>acc+p.x,0)/points.length;const y=points.reduce((acc,p)=>acc+p.y,0)/points.length;cell.point={x,y};cell.circleProps={topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topRadius,bottomRadius,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,adjacentPos:cell.adjacentPos[KNOWN_POLYGONS.SQUARE].map((aPos)=>({i:aPos.i,j:aPos.j<0?numCells-1:aPos.j>=numCells?0:aPos.j,})),};};const getMazePoint=(radius,angle)=>({x:CIRCLE_INFO.center.x+Math.cos(angle)*radius,y:CIRCLE_INFO.center.y+Math.sin(angle)*radius,});const buildMaze=()=>{createMazeGrid();MAZE_INFO.queue=[];MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);const lastCell=getLastMazeCell();while(MAZE_INFO.currentCell)MAZE_INFO.currentCell=buildCellMaze(MAZE_INFO.currentCell,lastCell);if(!MAZE_INFO.isCircle&&lastCell){openBorderForCellMaze(lastCell,getMazeCell(getAdjPos(lastCell)[0]));lastCell.visited=true;}if(!MAZE_INFO.isCircle&&getMazePolyInfo().hasInverted){for(const pos of iterateOverMaze()){const cell=getMazeCell(pos);cell.invertedBorders=[...cell.borders].reverse();}}MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const openBorderForCellMaze=(cell,nextCell)=>{const adjacentIndex=getNextCellMazeAdjacentIndex(cell,nextCell);const nextAdjacentIndex=getNextCellMazeAdjacentIndex(nextCell,cell);cell.borders[adjacentIndex]=false;nextCell.borders[nextAdjacentIndex]=false;};const buildCellMaze=(cell,lastCell)=>{cell.visited=true;const nextCell=getNextCellMaze(cell,(c)=>!!c&&!c.visited&&c!==lastCell,true);if(!nextCell)return null;openBorderForCellMaze(cell,nextCell);return nextCell;};const getLastMazeCell=()=>getMazeCell({i:MAZE_INFO.rows-1,j:MAZE_INFO.columns-1});const isMazeSolved=()=>!MAZE_INFO.currentCell||(MAZE_INFO.isCircle?MAZE_INFO.currentCell.pos.i===CIRCLE_INFO.rows-1:MAZE_INFO.currentCell===getLastMazeCell());const solveMaze=()=>{while(!isMazeSolved())MAZE_INFO.currentCell=solveCellMaze(MAZE_INFO.currentCell);solveCellMaze(MAZE_INFO.currentCell);MAZE_INFO.currentCell=getMazeCell(INITIAL_POS);};const solveCellMaze=(cell)=>{if(!cell)return;cell.solved=true;cell.path=true;const prevLength=MAZE_INFO.queue.length;const nextCell=getNextCellMaze(cell,(c)=>{if(!c||c.solved)return false;const nextIndex=getNextCellMazeAdjacentIndex(cell,c);return!cell.borders[nextIndex];});if(prevLength>MAZE_INFO.queue.length)cell.path=false;return nextCell;};const getAdjPos=(cell)=>cell.circleProps?.adjacentPos||cell.adjacentPos[RENDER_INFO.currentPoly];const getNextCellMaze=(cell,cellFilter,isRandom=false)=>{const adjacentPos=getAdjPos(cell);const aCells=adjacentPos.map(getMazeCell).filter(cellFilter);if(!aCells.length){if(!MAZE_INFO.queue.length)return null;const prevPos=MAZE_INFO.queue.pop();return getMazeCell(prevPos);}MAZE_INFO.queue.push(cell.pos);return aCells[isRandom?getRandomInt(aCells.length):aCells.length-1];};const getNextCellMazeAdjacentIndex=(cell,nextCell)=>{let nextIndex=0;const adjacentPos=getAdjPos(cell);while(nextIndex<adjacentPos.length){const{i,j}=adjacentPos[nextIndex];if(nextCell.pos.i===i&&nextCell.pos.j===j)break;nextIndex++;}return nextIndex;};const mazeMove=(posIndex)=>{if(posIndex===undefined||MAZE_INFO.currentCell.borders[posIndex])return;const nextPos=getAdjPos(MAZE_INFO.currentCell)[posIndex];if(!nextPos)return;const nextCell=getMazeCell(nextPos);if(!nextCell)return;const oldCell=MAZE_INFO.currentCell;MAZE_INFO.currentCell=nextCell;const prevCell=MAZE_INFO.queue[MAZE_INFO.queue.length-1];if(nextCell.pos===prevCell){oldCell.path=false;MAZE_INFO.queue.pop();}else{oldCell.path=true;MAZE_INFO.queue.push(oldCell.pos);}return MAZE_INFO.currentCell;};const initMaze=()=>{for(const p of KNOWN_POLYGONS_VALUES){MAZE_POLYS_INFO[p]=configPoly(p,mazeInfos.cellHeight);}MAZE_INFO.rows=mazeInfos.rows;MAZE_INFO.columns=mazeInfos.columns;CIRCLE_INFO.cellHeight=mazeCircleInfos?.cellHeight||mazeInfos.cellHeight;CIRCLE_INFO.rows=mazeCircleInfos?.rows||MAZE_INFO.rows*2;CIRCLE_INFO.columns=mazeCircleInfos?.columns||MAZE_INFO.columns*2;const center=(CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2)/2;CIRCLE_INFO.center={x:center,y:center};};const getMazeSize=()=>{let{ySide,xSide,shouldIntercalate,hasInverted,polySide}=getMazePolyInfo();let height=MAZE_INFO.rows*mazeInfos.cellHeight;let width=MAZE_INFO.columns*(xSide*2);if(MAZE_INFO.isCircle)height=width=CIRCLE_INFO.rows*2*CIRCLE_INFO.cellHeight+2;else{if(hasInverted)width=(MAZE_INFO.columns*polySide)/2+polySide/2+2;if(shouldIntercalate){height+=ySide;width=width*0.8;}}return{height,width};};const setIsCircle=(isCircle)=>{MAZE_INFO.isCircle=isCircle;if(MAZE_INFO.isCircle)RENDER_INFO.currentPoly=KNOWN_POLYGONS.SQUARE;};initMaze();return{getMazeSize,mazeMove,buildMaze,solveMaze,isMazeSolved,setIsCircle,getCirclePoint:()=>CIRCLE_INFO.center,iterateOverMaze,getMazeCell,getCurrentMazeCell:()=>MAZE_INFO.currentCell,getLastMazeCell,getMazePolyInfo,};};const fishingCanvas=(document.getElementById("fishing-canvas"));const fishingContext=fishingCanvas.getContext("2d");const fishingLineCanvas=(document.getElementById("fishing-line-canvas"));const fishingLineContext=fishingLineCanvas.getContext("2d");fishingLineContext.strokeStyle="black";const fishingContainer=document.getElementById("fishing-container");const fishingRodImg=(document.getElementById("fishing-rod"));const fishingRodPos=({i:8,j:0});const fishingFishImg=(document.getElementById("fishing-fish"));const fishingFishPos=({i:2,j:1});const FISHING_CONFIG={mazeSize:7,cellHeight:45,circleMazeSize:5,circleCellHeight:30,isCircleProbability:0.05,secondsToFish:20,timerDelay:100,timer:null,};let fishingMazeObj=(null);let IS_FISHING_ACTIVE=false;let FISHING_IS_CIRCLE=false;const setFishingCanvasSize=({height,width})=>{fishingLineCanvas.height=fishingCanvas.height=height;fishingLineCanvas.width=fishingCanvas.width=width;};const getFishingRodPoint=()=>FISHING_IS_CIRCLE?fishingMazeObj.getCirclePoint():fishingMazeObj.getLastMazeCell().point;const drawFishingLine=()=>{fishingLineCanvas.height=fishingLineCanvas.height;const fishPoint=fishingMazeObj.getCurrentMazeCell().point;const rodPoint=getFishingRodPoint();fishingLineContext.moveTo(fishPoint.x,fishPoint.y);fishingLineContext.lineTo(rodPoint.x,rodPoint.y);fishingLineContext.stroke();};const initFishingImages=()=>{const{ySide}=fishingMazeObj.getMazePolyInfo();setImagePos(fishingRodImg,fishingRodPos);setEntityImageSize(fishingRodImg,ySide);setImagePoint(fishingRodImg,getFishingRodPoint(),true,ySide);setImagePos(fishingFishImg,fishingFishPos);setEntityImageSize(fishingFishImg,ySide);setImagePoint(fishingFishImg,fishingMazeObj.getCurrentMazeCell().point,true,ySide);drawFishingLine();};const stopFishing=()=>{clearInterval(FISHING_CONFIG.timer);fishingContainer.classList.add("hide");IS_FISHING_ACTIVE=false;};const initFishingMazeObj=()=>{if(!fishingMazeObj)fishingMazeObj=createMazeObj({cellHeight:FISHING_CONFIG.cellHeight,rows:FISHING_CONFIG.mazeSize,columns:FISHING_CONFIG.mazeSize,},{cellHeight:FISHING_CONFIG.circleCellHeight,rows:FISHING_CONFIG.circleMazeSize,columns:FISHING_CONFIG.circleMazeSize,});fishingMazeObj.setIsCircle(FISHING_IS_CIRCLE);fishingMazeObj.buildMaze();};const initFishingTimer=(height)=>{fishingContainer.style.setProperty("--fishing-progress-bar-init-height",`${height}px`);fishingContainer.style.setProperty("--fishing-progress-bar-height",`${height}px`);let currentHeight=height;const timerSteps=height/((FISHING_CONFIG.secondsToFish*1000)/FISHING_CONFIG.timerDelay);FISHING_CONFIG.timer=setInterval(()=>{currentHeight-=timerSteps;fishingContainer.style.setProperty("--fishing-progress-bar-height",`${currentHeight}px`);if(currentHeight<=0){stopFishing();hurtEntity(PLAYER_ENTITY,1);}},FISHING_CONFIG.timerDelay);};let fishingFluidInterval=null;const initFishingDraw=(mazeObj)=>{clearInterval(fishingFluidInterval);const cells=([]);for(const pos of mazeObj.iterateOverMaze()){const cell=mazeObj.getMazeCell(pos);cells.push(cell);drawCellMaze(fishingContext,mazeObj,cell,tweakColor(BLOCKS.WATER.color));}if(!cells.length)return;fishingFluidInterval=setInterval(()=>{cells.forEach((c)=>drawCellMaze(fishingContext,mazeObj,c,tweakColor(BLOCKS.WATER.color)));},DRAW_CONFIG.fluidSpeed);};const startFishing=()=>{if(IS_FISHING_ACTIVE)return stopFishing();IS_FISHING_ACTIVE=true;FISHING_IS_CIRCLE=Math.random()<FISHING_CONFIG.isCircleProbability;initFishingMazeObj();const size=fishingMazeObj.getMazeSize();size.height+=FISHING_CONFIG.cellHeight/9;setFishingCanvasSize(size);initFishingImages();fishingContainer.classList.remove("hide");initFishingTimer(size.height);initFishingDraw(fishingMazeObj);};let canMoveFishing=true;const moveFishing=(code,useDiagonal)=>{if(canMoveFishing){const{ySide,hasInverted,polySides}=fishingMazeObj.getMazePolyInfo();const currentCell=fishingMazeObj.getCurrentMazeCell();const aIndex=getMovementMap(currentCell,useDiagonal,0,polySides,!FISHING_IS_CIRCLE&&hasInverted)[code];const nextCell=fishingMazeObj.mazeMove(aIndex);if(!nextCell)return;if(fishingMazeObj.isMazeSolved()){stopFishing();giveItemToEntity(PLAYER_ENTITY,{imgPos:fishingFishPos,health:1});return;}setImagePoint(fishingFishImg,nextCell.point,true,ySide);drawFishingLine();canMoveFishing=false;setTimeout(()=>{canMoveFishing=true;},100);}};const MAP_CONFIG={currentPosRatio:5,posRatio:5,fullScreenPosRatio:50,playerColor:({r:212,g:172,b:156,}),xRatio:0,yRatio:0,};const mapCanvas=(document.getElementById("map-canvas"));const mapContext=mapCanvas.getContext("2d");const resetBiomeMap=()=>{let size=0;if(fullMap){size=Math.min(window.innerWidth,window.innerHeight)*0.96;MAP_CONFIG.currentPosRatio=MAP_CONFIG.fullScreenPosRatio;}else{size=mapCanvas.parentElement.offsetWidth;MAP_CONFIG.currentPosRatio=MAP_CONFIG.posRatio;}mapCanvas.width=size;mapCanvas.height=size;MAP_CONFIG.xRatio=mapCanvas.width/(MAP_CONFIG.currentPosRatio*2+1);MAP_CONFIG.yRatio=mapCanvas.height/(MAP_CONFIG.currentPosRatio*2+1);};const updateBiomeMap=()=>{clearCanvas(mapCanvas);const biomes=getBiomeMap();const iOffset=Math.round(RENDER_INFO.iOffset/GENERATION_CONFIG.chunkSize);const jOffset=Math.round(RENDER_INFO.jOffset/GENERATION_CONFIG.chunkSize);const iNegLimit=iOffset-MAP_CONFIG.currentPosRatio;const iPosLimit=iOffset+MAP_CONFIG.currentPosRatio+1;const jNegLimit=jOffset-MAP_CONFIG.currentPosRatio;const jPosLimit=jOffset+MAP_CONFIG.currentPosRatio+1;for(let i=iNegLimit;i<=iPosLimit;i++){const nI=i-iOffset;for(let j=jNegLimit;j<=jPosLimit;j++){const nJ=j-jOffset;const biome=biomes[i]?.[j];if(!biome)continue;createRect({i:nI,j:nJ},biome.mapColor);}}createRect({i:0,j:0},MAP_CONFIG.playerColor);};let fullMap=false;const toggleFullMap=(toggle=!fullMap)=>{fullMap=toggle;if(toggle){mapCanvas.classList.add("full-screen");resetBiomeMap();updateBiomeMap();}else{mapCanvas.classList.remove("full-screen");resetBiomeMap();updateBiomeMap();}};const createRect=(pos,color)=>{mapContext.fillStyle=getFillStyle(color);mapContext.fillRect((MAP_CONFIG.currentPosRatio+pos.j)*MAP_CONFIG.xRatio,(MAP_CONFIG.currentPosRatio+pos.i)*MAP_CONFIG.yRatio,MAP_CONFIG.xRatio,MAP_CONFIG.yRatio);};const areColorsEqual=(color1,color2)=>color1.r===color2.r&&color1.g===color2.g&&color1.b===color2.b;const PLACE_CONFIG={cellHeight:24,canvasNum:7,};const BLOCKS_LISTS=Object.values(BLOCKS).filter((b)=>!b.isFluid).filter((b,i,a)=>!a.find((b2,i2)=>areColorsEqual(b.color,b2.color)&&i<i2));PLACE_CONFIG.steps=360/PLACE_CONFIG.canvasNum;let PLACE_POLYS_INFO=(null);const placeContainer=document.getElementById("place-canvas-container");const placeCanvas=([]);const placeContexts=([]);for(let i=0;i<PLACE_CONFIG.canvasNum;i++){const canvas=document.createElement("canvas");canvas.style.setProperty("--place-rotate-canvas",`${PLACE_CONFIG.steps *i}deg`);placeContainer.appendChild(canvas);placeCanvas.push(canvas);placeContexts.push(canvas.getContext("2d"));}placeContainer.ontouchend=()=>{};const getSelectedBlockToPlace=()=>{const block=BLOCKS_LISTS[getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length)];return{block,color:block.color};};const resetPlace=()=>{placeCanvas.forEach((p)=>{p.width=placeContainer.parentElement.offsetWidth;p.height=placeContainer.parentElement.offsetHeight;});showSelectedPlaceBlocks();};const drawPlaceBlock=(context,block)=>{if(!PLACE_POLYS_INFO){PLACE_POLYS_INFO={};for(const p of KNOWN_POLYGONS_VALUES){PLACE_POLYS_INFO[p]=configPoly(p,PLACE_CONFIG.cellHeight);}}const polyInfo=PLACE_POLYS_INFO[RENDER_INFO.currentPoly];const wall=blockToWall({block,color:block.color},{x:placeContainer.parentElement.offsetWidth/2,y:placeContainer.parentElement.offsetHeight/1.75,},{isInverted:polyInfo.hasInverted},polyInfo);drawWall(wall,context);applyBorders(context,wall.point,wall.points,[],true);drawWallTop(wall,context);};let SELECTED_PLACE_BLOCKS=0;let PLACE_BLOCKS_DEG=0;const movePlaceBlocks=(orientation)=>{SELECTED_PLACE_BLOCKS=SELECTED_PLACE_BLOCKS+orientation;PLACE_BLOCKS_DEG+=orientation>0?PLACE_CONFIG.steps:-PLACE_CONFIG.steps;placeContainer.style.setProperty("--place-rotate-container",`${-PLACE_BLOCKS_DEG}deg`);showSelectedPlaceBlocks();};const showSelectedPlaceBlocks=()=>{const showIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS+1,PLACE_CONFIG.canvasNum),];const drawIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS+1,BLOCKS_LISTS.length),];placeCanvas.forEach((p,i)=>{p.classList[showIndexes.includes(i)?"add":"remove"]("active");});showIndexes.forEach((index,i)=>{clearCanvas(placeCanvas[index]);drawPlaceBlock(placeContexts[index],BLOCKS_LISTS[drawIndexes[i]]);});};const resetToolbar=()=>{resetBiomeMap();resetPlace();};const PERLIN_VECTORS={BIOME:Symbol("BIOME"),BLOCK:Symbol("BLOCK"),};const getValue=(()=>{const PERLIN_CONFIG={noiseResolutionBiome:75,noiseResolution:10,};const getSizeFromNoise=(size,resolution)=>{const numVectorsX=Math.floor(size/resolution)+1;const extraVectorX=size%resolution==0?0:1;return numVectorsX+extraVectorX;};const initializeVector=(vector)=>{return{width:getSizeFromNoise(vector.width,vector.resolution),height:getSizeFromNoise(vector.height,vector.resolution),vectors:[],resolution:vector.resolution,};};const vectors=({[PERLIN_VECTORS.BIOME]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolutionBiome,}),[PERLIN_VECTORS.BLOCK]:initializeVector({width:GENERATION_CONFIG.chunkSize,height:GENERATION_CONFIG.chunkSize,vectors:[],resolution:PERLIN_CONFIG.noiseResolution,}),});const updateVector=(i,j,vector)=>{const offsetPos=getChunkStart({i,j},vector.height,vector.width);for(let i=0;i<=vector.height-1;i++){const nI=i+offsetPos.i;vector.vectors[nI]=vector.vectors[nI]||[];for(let j=0;j<=vector.width-1;j++){const nJ=j+offsetPos.j;vector.vectors[nI][nJ]=getRandUnitVect();}}};const getRandUnitVect=()=>{const theta=Math.random()*2*Math.PI;return{x:Math.cos(theta),y:Math.sin(theta)};};const dotProduct=(vector,x,y,vx,vy)=>{if(!vector.vectors[vy]?.[vx])updateVector(vy,vx,vector);return dot({x:x-vx,y:y-vy},vector.vectors[vy][vx]);};const dot=(v1,v2)=>v1.x*v2.x+v1.y*v2.y;const lerp=(a,b,c)=>a+smootherstep(c)*(b-a);const smootherstep=(x)=>6*x**5-15*x**4+10*x**3;return(i,j,vectorType)=>{const vector=vectors[vectorType];const offset=0.5/vector.resolution;const x=i/vector.resolution+offset;const y=j/vector.resolution+offset;const xF=Math.floor(x);const yF=Math.floor(y);const tlv=dotProduct(vector,x,y,xF,yF);const trv=dotProduct(vector,x,y,xF+1,yF);const blv=dotProduct(vector,x,y,xF,yF+1);const brv=dotProduct(vector,x,y,xF+1,yF+1);const lerpTop=lerp(tlv,trv,x-xF);const lerpBottom=lerp(blv,brv,x-xF);const value=lerp(lerpTop,lerpBottom,y-yF);return value;};})();const DRAW_CONFIG={lightDepth:2,maxLayer:2,fluidSpeed:500,};const RENDER_CONFIG={selectedBorderColor:"white",borderColor:"black",emptyColor:"black",lineWidth:1,wallDarkness:0.5,};const CLOUDS_CONFIG={num:4,rows:3,columns:3,durationMult:30,offsetSize:6,offset:0,};const CLOUDS_DIRECTION_MAP={[MOVEMENT.RIGHT]:-CLOUDS_CONFIG.offsetSize,[MOVEMENT.LEFT]:CLOUDS_CONFIG.offsetSize,};const cloudsContainer=document.getElementById("clouds-container");let clouds=([]);const updateClouds=(direction)=>{if(MENU_CONFIG.clouds){if(!clouds.length){createClouds();offsetClouds(MOVEMENT.RIGHT);}setCloudShape();offsetClouds(direction);}else{cloudsContainer.classList.add("off");}};const setCloudShape=()=>{const{currentPoly,cellHeight}=RENDER_INFO;const size=Math.min(cellHeight*4,cloudsContainer.offsetWidth/(CLOUDS_CONFIG.num*CLOUDS_CONFIG.columns*1.5));cloudsContainer.className=`p${currentPoly}`;cloudsContainer.style.setProperty("--clouds-default-size",`${size}px`);};const offsetClouds=(direction)=>{const offsetSize=CLOUDS_DIRECTION_MAP[direction];if(!offsetSize)return;CLOUDS_CONFIG.offset+=offsetSize;const offsetLeft=getMod(CLOUDS_CONFIG.offset,cloudsContainer.offsetWidth);const width=cloudsContainer.offsetWidth/CLOUDS_CONFIG.num;const defaultOffsetLeft=cloudsContainer.offsetWidth/4;cloudsContainer.style.setProperty("--clouds-offset-left",`${getMod(CLOUDS_CONFIG.offset,width)-defaultOffsetLeft}px`);const offset=Math.floor(offsetLeft/width);for(let index=0;index<clouds.length;index++){clouds[index].style.setProperty("--clouds-order",`${getMod(index +offset,CLOUDS_CONFIG.num)+1}`);}};const createClouds=()=>{const min=1-CLOUDS_CONFIG.num/10;const max=Math.min(min+0.5,1);for(let i=0;i<CLOUDS_CONFIG.num;i++){const cloud=document.createElement("div");cloud.className="cloud";const scale=correctRoundError(getRandomFloat(min,max),2);const duration=Math.round(scale*CLOUDS_CONFIG.durationMult);cloud.style.setProperty("--clouds-scale",`${scale}`);cloud.style.setProperty("--clouds-animation-duration",`${duration}s`);cloudsContainer.appendChild(cloud);clouds.push(cloud);for(let j=0;j<CLOUDS_CONFIG.rows;j++){const cloudRow=document.createElement("div");cloudRow.className="cloud-row";cloud.appendChild(cloudRow);for(let z=0;z<CLOUDS_CONFIG.columns;z++){const cloudShape=document.createElement("div");cloudShape.className="cloud-shape";cloudRow.appendChild(cloudShape);}}}};const blockToWall=(block,point,wallParams={},polyInfo)=>{polyInfo=polyInfo||getPolyInfo();const points=wallParams.isInverted?polyInfo.invertedPoints:polyInfo.points;const layer=wallParams.layer||0;const wallLayer=layer+1;const wallPoints=wallParams.isInverted?polyInfo.wallInvertedPoints:polyInfo.wallPoints;const commonInfos={color:block.color,pos:wallParams.pos,isInverted:wallParams.isInverted,isSelectedCell:wallParams.isSelectedCell,};return{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*layer},points:wallPoints,topInfo:{...commonInfos,point:{x:point.x,y:point.y-polyInfo.ySide*wallLayer},points,modifier:wallParams.modifier,},borderMap:wallParams.borderMap,modifier:wallParams.modifier*RENDER_CONFIG.wallDarkness,};};const drawContainer=document.getElementById("draw-container");const canvasContainer=document.getElementById("canvas-container");const rainContainer =document.getElementById("rain-container");const BIOME_RAIN_MAP ={DEFAULT:"../images/weather/rain.gif",[BIOME_TYPES.SNOW]:"../images/weather/snow.gif",};const rainAudio =new Audio("sounds/weather/rain.mp3");rainAudio.volume =0.25;rainAudio.loop =true;const lightningAudio =new Audio("sounds/weather/lightning.mp3");lightningAudio.volume =0.25;let isRainOn =false;const updateRain =()=>{if (MENU_CONFIG.rain){if (!isRainOn){clearLightning();isRainOn =true;rainAudio.play();rainContainer.classList.remove("hide");const size =RENDER_INFO.cellHeight *10;rainContainer.style.setProperty("--rain-size",`${size}px`);createLightining();}updateRainImg();}else {if (isRainOn){clearLightning();isRainOn =false;rainAudio.pause();rainContainer.classList.add("hide");}}};let lightningInterval =null;const createLightining =()=>{clearTimeout(lightningInterval);const secs =getRandomFloat(10000,30000);lightningInterval =setTimeout(()=>{rainContainer.classList.remove("lightning");rainContainer.offsetHeight;rainContainer.classList.add("lightning");lightningAudio.play();createLightining();},secs);};const clearLightning =()=>{clearTimeout(lightningInterval);rainContainer.classList.remove("lightning");};const updateRainImg =()=>{const gif =`url("${BIOME_RAIN_MAP[PLAYER_ENTITY.cell.block.biomeType]||BIOME_RAIN_MAP.DEFAULT }")`;const currentGif=rainContainer.style.getPropertyValue("--rain-img");if(gif!==currentGif)rainContainer.style.setProperty("--rain-img",gif);};const updateWeather=(direction)=>{updateRain();updateClouds(direction);};const CLOCK_CONFIG={passHour:0.25,midNightHour:60,};const analogClock=document.getElementById("analog-clock");const digitalClock=document.getElementById("digital-clock");const hourTensSegments=document.querySelectorAll("#digital-clock-hours .digit-tens .segment");const hourUnitsSegments=document.querySelectorAll("#digital-clock-hours .digit-units .segment");const minuteTensSegments=document.querySelectorAll("#digital-clock-minutes .digit-tens .segment");const minuteUnitsSegments=document.querySelectorAll("#digital-clock-minutes .digit-units .segment");const updateClock=()=>{const{hour,hour24,minute}=getTime();if(MENU_CONFIG.digitalClock){digitalClock.classList.remove("hide");analogClock.classList.add("hide");setNumber(hourTensSegments,Math.floor(hour24/10));setNumber(hourUnitsSegments,Math.floor(hour24%10));setNumber(minuteTensSegments,Math.floor(minute/10));setNumber(minuteUnitsSegments,Math.floor(minute%10));}else{analogClock.classList.remove("hide");digitalClock.classList.add("hide");analogClock.style.setProperty("--clock-hour-rotate",`${hour *30 +minute *0.5}deg`);analogClock.style.setProperty("--clock-minute-rotate",`${minute *6}deg`);}};const passTime=()=>{ENTITY_INFO.timeOfDay+=CLOCK_CONFIG.passHour;if(ENTITY_INFO.timeOfDay>=CLOCK_CONFIG.midNightHour||ENTITY_INFO.timeOfDay<=0){CLOCK_CONFIG.passHour=-CLOCK_CONFIG.passHour;}updateClock();};const getTime=()=>{const hourRaw=(12*ENTITY_INFO.timeOfDay)/CLOCK_CONFIG.midNightHour;let hour=Math.floor(hourRaw);let minute=Math.round((hourRaw-hour)*100);minute=Math.floor(minute*0.6);minute=CLOCK_CONFIG.passHour>0?minute:60-minute;minute=getMod(minute,60);if(CLOCK_CONFIG.passHour<0)hour=Math.max((minute?11:12)-hour,0);const hour24=CLOCK_CONFIG.passHour>0?hour+12:hour;return{hour,hour24,minute};};const setNumber=(segments,value)=>{segments.forEach((el)=>{el.classList[el.classList.contains(`n${value}`)?"add":"remove"]("active");});};const compass=document.getElementById("compass");const COMPASS_CONFIG={rotateDelay:750,};const updateCompass=()=>{const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;compass.style.setProperty("--compass-rotate",`${-angle}deg`);};const entitiesContainer=document.getElementById("entities");const rotateCanvas=(deg,rotateDelay)=>{rotateElement(entitiesContainer,-deg,rotateDelay);rotateElement(drawContainer,deg,rotateDelay);};const resetRotateCanvas=()=>{rotateElement(entitiesContainer);rotateElement(drawContainer);};const rotateElement=(element,deg,rotateDelay)=>{if(rotateDelay)element.style.setProperty("--transition-duration",`${rotateDelay}ms`);if(deg)element.style.setProperty("--rotate-deg",`${deg}deg`);element.classList[deg?"add":"remove"]("rotate");element.classList[deg?"add":"remove"]("zoom-in");};const updateWidgets=()=>{updateClock();updateCompass();};const resetCanvas=()=>{const polyInfo=getPolyInfo();setCanvasSize(polyInfo.canvasHeight,polyInfo.canvasWidth);setFavicon();};const updateCanvasCss=()=>{updateConfigs();updateWeather();updateWidgets();};let filledThisRound=(new Set());let tracksCount=({});const addToTrackCount=(block)=>{if(block?.trackType)tracksCount[block.trackType]=(tracksCount[block.trackType]||0)+1;};const getAjacentCells=(cell,depth=1)=>{const result=[[cell]];for(let index=0;index<depth;index++){const cells=([]);const current=result[index];for(const element of current){if(!element)continue;const aCells=element.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);cells.push(...aCells.filter((c)=>!current.includes(c)&&!cells.includes(c)&&c!==cell));}result.push(cells);}return result;};const drawEveryCell=(baseEntity)=>{wallLayers=[];fluids=[];filledThisRound=new Set();tracksCount={};const offsetCell=baseEntity.cell.pos.j%2;const{rows,columns,shouldIntercalate}=getPolyInfo();const size=rows+columns;const adjacentCells=getAjacentCells(baseEntity.cell,DRAW_CONFIG.lightDepth);const selectedCell=getSelectedCell(baseEntity);for(let i=-columns;i<size;i++){const baseI=i+RENDER_INFO.iOffset;for(let j=-rows;j<size;j++){let nI=baseI;const nJ=j+RENDER_INFO.jOffset;const pos={i:nI,j:nJ};if(shouldIntercalate&&offsetCell&&nJ%2===0)nI=nI+1;drawCell(loadAndGetCell(pos),contextsLayers[0],baseEntity,adjacentCells,selectedCell);}}drawWalls();updateEntities();tweakFluids();updateBiomeMap();updateTracks(tracksCount);};let wallLayers=([]);const drawWalls=()=>{for(let i=1;i<DRAW_CONFIG.maxLayer;i++){const walls=wallLayers[i];clearCanvas(canvasLayers[i]);if(!walls)continue;walls.forEach((w)=>drawWall(w,contextsLayers[i]));walls.forEach((w)=>drawWallTop(w,contextsLayers[i]));}wallLayers=[];};let fluidInterval=null;let fluids=([]);const tweakFluids=debounce(()=>{clearInterval(fluidInterval);if(!fluids.length)return;const context=contextsLayers[0];fluidInterval=setInterval(()=>{fluids.forEach((fluid)=>{drawItem(context,{...fluid,color:tweakColor(fluid.color),});});},DRAW_CONFIG.fluidSpeed);},DRAW_CONFIG.fluidSpeed);const drawCell=(cell,context,baseEntity,adjacentCells,selectedCell)=>{const polyInfo=getPolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const point=calculatePointBasedOnPos(cell.pos,isInverted,baseEntity.cell);if(isPointOutside(point,polyInfo.canvasHeight,polyInfo.canvasWidth))return;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const aCells=cell.adjacentPos[RENDER_INFO.currentPoly].map(getCell);const isSelectedCell=MENU_CONFIG.showSelectedCell&&cell===selectedCell;cell.modifier=getStyleModifier(adjacentCells.findIndex((c)=>c.includes(cell)));addToTrackCount(cell.wall?.block||cell.block);if(cell.wall){const wallLayer=cell.layer+1;const shouldOffset=polyInfo.hasInverted&&!cell.isInverted;if(!wallLayers[wallLayer])wallLayers[wallLayer]=[];wallLayers[wallLayer].push(blockToWall(cell.wall,point,{layer:cell.layer,isInverted,modifier:cell.modifier,isSelectedCell,pos:cell.pos,borderMap:aCells.reduce((acc,c,i)=>{let index=i-RENDER_INFO.rotationTurns;if(shouldOffset)index=RENDER_INFO.currentPoly-1-index;acc[getMod(index,RENDER_INFO.currentPoly)]=!c?.wall;return acc;},[]),}));return;}if(!cell.block){const aFluid=aCells.find((c)=>c?.block?.isFluid);if(aFluid&&!filledThisRound.has(aFluid.pos)){filledThisRound.add(cell.pos);cell.block=aFluid.block;cell.color=aFluid.color;}}const drawable=({point,points,isInverted,pos:cell.pos,color:cell.color,modifier:cell.modifier,isSelectedCell,});if(cell.block?.isFluid)fluids.push(drawable);drawItem(context,drawable);if(cell.block===MINE_BLOCKS.MINES_LOW){const aCellsCorner=cell.adjacentPosWithCorners[RENDER_INFO.currentPoly].map(getCell);showMineValue(context,aCellsCorner.reduce((acc,c)=>(c.hasBomb?acc+1:acc),0),point,isInverted,polyInfo.ySide);}};const drawCircleOnCell=(cell,baseEntity)=>{const{hasInverted,ySide}=getPolyInfo();const point=calculatePointBasedOnPos(cell.pos,hasInverted&&cell.isInverted,baseEntity.cell);drawCircle(contextsLayers[0],point,ySide/4);};const MAZE_CANVAS_CONFIG={defaultColor:"#cdcdcd",};const drawMaze=(context,mazeObj)=>{for(const pos of mazeObj.iterateOverMaze()){drawCellMaze(context,mazeObj,mazeObj.getMazeCell(pos));}};const drawCellMaze=(context,mazeObj,cell,color)=>{context.fillStyle=color?getFillStyle(color):MAZE_CANVAS_CONFIG.defaultColor;if(cell.circleProps)drawCellMazeCircle(context,cell,mazeObj.getCirclePoint());else drawCellMazePolygon(context,mazeObj,cell);};const drawCellMazePolygon=(context,mazeObj,cell)=>{const polyInfo=mazeObj.getMazePolyInfo();const isInverted=polyInfo.hasInverted&&cell.isInverted;const points=isInverted?polyInfo.invertedPoints:polyInfo.points;const borders=polyInfo.hasInverted&&!cell.isInverted?cell.invertedBorders:cell.borders;fillPolygon(context,cell.point,points);applyBorders(context,cell.point,points,borders);if(MENU_CONFIG.showPos&&cell.pos)showPos(context,cell.pos,cell.point,isInverted,polyInfo.ySide);};const drawCellMazeCircle=(context,cell,circlePoint)=>{const{topRadius,bottomRadius,topLeftPoint,topRightPoint,bottomLeftPoint,bottomRightPoint,topLeftAngle,topRightAngle,bottomLeftAngle,bottomRightAngle,}=cell.circleProps;context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.closePath();context.fill();if(cell.borders[0]){context.beginPath();context.moveTo(topLeftPoint.x,topLeftPoint.y);context.arc(circlePoint.x,circlePoint.y,topRadius,topLeftAngle,topRightAngle);context.stroke();}if(cell.borders[1]){context.beginPath();context.moveTo(topRightPoint.x,topRightPoint.y);context.lineTo(bottomRightPoint.x,bottomRightPoint.y);context.stroke();}if(cell.borders[2]){context.beginPath();context.moveTo(bottomRightPoint.x,bottomRightPoint.y);context.arc(circlePoint.x,circlePoint.y,bottomRadius,bottomRightAngle,bottomLeftAngle,true);context.stroke();}if(cell.borders[3]){context.beginPath();context.moveTo(bottomLeftPoint.x,bottomLeftPoint.y);context.lineTo(topLeftPoint.x,topLeftPoint.y);context.stroke();}};const digAudio=new Audio("sounds/actions/dig.mp3");digAudio.volume=0.25;const punchAudio=new Audio("sounds/actions/punch.mp3");punchAudio.volume=0.25;const gunShotAudio=new Audio("sounds/actions/gun-shot.mp3");gunShotAudio.volume=1;const rotateAudio=new Audio("sounds/actions/rotate.mp3");rotateAudio.volume=0.25;let canRotate=true;const canDoActions=()=>PLAYER_ENTITY.health>0;const rotate=(orientation)=>{if(canRotate){canRotate=false;RENDER_INFO.rotationTurns=PLAYER_ENTITY.selectedCellIndex=getMod(RENDER_INFO.rotationTurns+orientation,RENDER_INFO.currentPoly);if(MENU_CONFIG.rotationAnimation){rotateCanvas((360/RENDER_INFO.currentPoly)*-orientation,COMPASS_CONFIG.rotateDelay);rotateAudio.play();}updateCompass();resetDirection();setTimeout(()=>{if(MENU_CONFIG.rotationAnimation)resetRotateCanvas();drawEveryCell(PLAYER_ENTITY);canRotate=true;},COMPASS_CONFIG.rotateDelay);}};const getNextCellIndexBasedOnCode=(code,useDiagonal)=>{const aIndex=getMovementMap(PLAYER_ENTITY.cell,useDiagonal)[code];if(aIndex===undefined)return;return getMod(aIndex,RENDER_INFO.currentPoly);};let isMoving=false;const moveBaseOnCode=(direction,useDiagonal)=>{if(!direction||!canDoActions())return;if(IS_FISHING_ACTIVE){moveFishing(direction,useDiagonal);return;}isMoving=true;makeEntityRun(PLAYER_ENTITY,direction);const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined)return;const nextPos=getPosByIndex(PLAYER_ENTITY.cell,aModI);if(!nextPos)return;const nextCell=getCell(nextPos);if(cellIsBlocked(nextCell,PLAYER_ENTITY))return;move(nextCell);updateWeather(direction);};const MOVEMENT_VALUES=Object.values(MOVEMENT);const stopMoving=()=>{if(!isMoving)return;let lastSelection=PLAYER_ENTITY.currentDirection;const movementMap=getMovementMap(PLAYER_ENTITY.cell);for(const movement of MOVEMENT_VALUES){if(movementMap[movement]===PLAYER_ENTITY.selectedCellIndex){lastSelection=movement;break;}}isMoving=false;updateEntityDirection(PLAYER_ENTITY,lastSelection);};const changeSelectedOnCode=(direction,useDiagonal)=>{if(!direction)return;const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined||aModI===PLAYER_ENTITY.selectedCellIndex)return;PLAYER_ENTITY.selectedCellIndex=aModI;if(MENU_CONFIG.showSelectedCell)drawEveryCell(PLAYER_ENTITY);updateEntityDirection(PLAYER_ENTITY,direction);};const getNextPolygon=()=>KNOWN_POLYGONS_VALUES[(KNOWN_POLYGONS_VALUES.indexOf(RENDER_INFO.currentPoly)+1)%KNOWN_POLYGONS_VALUES.length];const changePolySides=()=>{RENDER_INFO.currentPoly=getNextPolygon();RENDER_INFO.rotationTurns=0;PLAYER_ENTITY.selectedCellIndex=0;updateCompass();resetDirection();resetMap();};const resetDirection=()=>updateEntityDirection(PLAYER_ENTITY,MOVEMENT.UP);const updateAndGetSelectedCell=()=>{updateEntityDirection(PLAYER_ENTITY,PLAYER_ENTITY.currentDirection);return getSelectedCell(PLAYER_ENTITY);};const dig=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(!selectedCell?.block)return;if(selectedCell.entityType){makeEntityUse(PLAYER_ENTITY);const entities=getEntitiesFromCell(selectedCell);entities.forEach((e)=>hurtEntity(e,1));punchAudio.play();move();return;}if(selectedCell.block.isFluid)return;if(selectedCell.wall){if(selectedCell.wall.block.indestructible)return;}else if(selectedCell.block.indestructible)return;makeEntityUse(PLAYER_ENTITY);digAudio.play();if(selectedCell.wall){destroyWall(selectedCell);}else{selectedCell.block=null;selectedCell.color=null;}move();};const place=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.wall||selectedCell.entityType)return;makeEntityUse(PLAYER_ENTITY);placeBlock(selectedCell);move();};const placeBlock=(cell,block,color)=>{if(!cell||!!cell.entityType)return;if(!block){const cellBlock=getSelectedBlockToPlace();if(!cellBlock)return;block=cellBlock.block;color=cellBlock.color;}digAudio.play();if(cell.block&&!cell.block.isFluid){cell.wall={block:block,color:color};}else{cell.block=block;cell.color=color;}};const useBoat=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();const canMove=!selectedCell.wall&&selectedCell.block;if(PLAYER_ENTITY.connectedEntities[ENTITY_TYPES.BOAT]){if(!selectedCell?.block?.isFluid&&canMove){getOutBoat(PLAYER_ENTITY);move(selectedCell);}return;}if(selectedCell.entityType===ENTITY_TYPES.BOAT){getInBoat(PLAYER_ENTITY);move(selectedCell);}else if(canMove){makeEntityUse(PLAYER_ENTITY);addBoat(selectedCell,PLAYER_ENTITY);}};const useGun=()=>{const range=getPolyInfo().hasInverted?1:10;updateAndGetSelectedCell();gunShotAudio.currentTime=0;let{cell,selectedCellIndex}=PLAYER_ENTITY;for(let i=0;i<range;i++){const nextCell=getCell(getPosByIndex(cell,selectedCellIndex));if(nextCell.wall)break;cell=nextCell;drawCircleOnCell(cell,PLAYER_ENTITY);if(cell.entityType){const entities=getEntitiesFromCell(cell);entities.forEach((e)=>hurtEntity(e,1));break;}}gunShotAudio.play();move();};const useMap=(toggle)=>{if(IS_FISHING_ACTIVE||!canDoActions())return;toggleFullMap(toggle);};const useFishingRod=()=>{if(!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.block?.isFluid){makeEntityUse(PLAYER_ENTITY);startFishing();}};const resetMap=()=>{resetPlace();setEntitiesSize();resetCanvas();moveCurrentCell(getCenterCell(),PLAYER_ENTITY.cell);drawEveryCell(PLAYER_ENTITY);updateWeather();};const canvasLayers =([]);const contextsLayers =([]);for (let i =0;i <DRAW_CONFIG.maxLayer;i++){const canvas =document.createElement("canvas");canvasContainer.appendChild(canvas);canvasLayers.push(canvas);contextsLayers.push(canvas.getContext("2d"));}const setCanvasSize =(height,width)=>{drawContainer.style.setProperty("--canvas-height",`${height}px`);canvasLayers.forEach((canvas)=>(canvas.height =height));drawContainer.style.setProperty("--canvas-width",`${width}px`);canvasLayers.forEach((canvas)=>(canvas.width =width));};const setFavicon =()=>{const link =(document.querySelector("link[rel~='icon']"));link.href=POLYGONS_IMAGES[RENDER_INFO.currentPoly];};const updateConfigs=()=>{canvasContainer.classList[MENU_CONFIG.usePerspective?"add":"remove"]("perspective");};const clearCanvas=(canvas)=>{canvas.width=canvas.width;};const drawWall=(wall,context)=>{if(!wall.borderMap||wall.borderMap.find((b)=>!!b))drawItem(context,wall);};const drawWallTop=(wall,context)=>{drawItem(context,wall.topInfo);context.strokeStyle=wall.isSelectedCell?RENDER_CONFIG.selectedBorderColor:RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,wall.topInfo.point,wall.topInfo.points,wall.borderMap);};const drawItem=(context,{point,points,pos,isInverted,color,modifier,isSelectedCell})=>{context.fillStyle=color?getFillStyle(color,modifier):RENDER_CONFIG.emptyColor;fillPolygon(context,point,points);if(MENU_CONFIG.showPos&&pos)showPos(context,pos,point,isInverted,getPolyInfo().ySide);if(isSelectedCell){context.strokeStyle=RENDER_CONFIG.selectedBorderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}else if(MENU_CONFIG.showChunks&&pos)showChunks(context,pos,point,points);};const getFillStyle=(color,modifier=1)=>color===EMPTY_BLOCK.color?"transparent":`rgb(`+`${color.r *modifier},`+`${color.g *modifier},`+`${color.b *modifier})`;const getStyleModifier=(intensity)=>{if(!ENTITY_INFO.timeOfDay)return 1;let modifier=1-ENTITY_INFO.timeOfDay/100;if(intensity>=0)modifier=(1-modifier)/(intensity||1)+modifier;return modifier;};const fillPolygon=(context,{x,y},points)=>{context.beginPath();for(const point of points){context.lineTo(x+point.x,y+point.y);}context.closePath();context.fill();};const applyBorders=(context,{x,y},points,map,ignoreLast)=>{for(let i=0;i<points.length;i++){if(!map?.length||map[i]){const point=points[i];let nextPoint=points[i+1];if(!nextPoint){if(ignoreLast)return;nextPoint=points[0];}const pointA={x:x+point.x,y:y+point.y};const pointB={x:x+nextPoint.x,y:y+nextPoint.y};drawLine(context,pointA,pointB);}}};const drawLine=(context,pointA,pointB)=>{context.beginPath();context.moveTo(pointA.x,pointA.y);context.lineTo(pointB.x,pointB.y);context.stroke();};const showPos=(context,pos,point,isInverted,ySide)=>{context.fillStyle="black";context.font=`bold ${ySide /2}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${pos.i},${pos.j}`,point.x,isInverted?point.y+ySide/2:point.y);};const showChunks=(context,pos,point,points)=>{if(pos.i%GENERATION_CONFIG.chunkSize===0||pos.j%GENERATION_CONFIG.chunkSize===0){context.strokeStyle=RENDER_CONFIG.borderColor;context.lineWidth=RENDER_CONFIG.lineWidth;applyBorders(context,point,points);}};const mineValueColors=["blue","green","red","darkblue","brown","darkred","black","grey",];const showMineValue=(context,value,point,isInverted,ySide)=>{if(value){context.fillStyle=mineValueColors[value-1];context.font=`bold ${ySide}px Arial`;context.textAlign="center";context.textBaseline="middle";context.fillText(`${value}`,point.x,isInverted?point.y+ySide/2:point.y);}};const drawCircle=(context,point,radius)=>{context.beginPath();context.arc(point.x,point.y,radius,0,2*Math.PI);context.fillStyle="black";context.fill();};const MOVEMENT_CONFIG={velocity:10,};const getCleanPos=(pos)=>({i:pos?.i||0,j:pos?.j||0});const moveCurrentCell=(oldCell,nextCell)=>{const oldPos=getCleanPos(oldCell?.pos);const nextPos=getCleanPos(nextCell?.pos);RENDER_INFO.iOffset+=nextPos.i-oldPos.i;RENDER_INFO.jOffset+=nextPos.j-oldPos.j;moveEntityToCell(PLAYER_ENTITY,nextCell);};let canMove=true;const move=(nextCell)=>{if(canMove&&PLAYER_ENTITY.health>0){canMove=false;if(nextCell)moveCurrentCell(PLAYER_ENTITY.cell,nextCell);if(MENU_CONFIG.passTime)passTime();setTimeout(()=>{drawEveryCell(PLAYER_ENTITY);killEntitiesByTimeOfDay();moveEntities(PLAYER_ENTITY.cell);spawnEntities(PLAYER_ENTITY.cell);canMove=true;},1000/MOVEMENT_CONFIG.velocity);}};const findAccessibleCell=(cell,entity)=>{let accessibleCell=cell;while(cellIsBlocked(accessibleCell,entity)){accessibleCell=loadAndGetCell({i:accessibleCell.pos.i+1,j:accessibleCell.pos.j,});}return accessibleCell;};const audios=({});let MUSIC_VOLUME=1;const TRACK_FILES={[TRACK_TYPES.TRACK1]:"sounds/blocks/track1.wav",[TRACK_TYPES.TRACK2]:"sounds/blocks/track2.wav",[TRACK_TYPES.TRACK3]:"sounds/blocks/track3.wav",[TRACK_TYPES.TRACK4]:"sounds/blocks/track4.wav",[TRACK_TYPES.TRACK5]:"sounds/blocks/track5.wav",[TRACK_TYPES.TRACK6]:"sounds/blocks/track6.wav",[TRACK_TYPES.TRACK7]:"sounds/blocks/track7.wav",[TRACK_TYPES.TRACK8]:"sounds/blocks/track8.wav",[TRACK_TYPES.TRACK11]:"sounds/blocks/track11.wav",[TRACK_TYPES.TRACK14]:"sounds/blocks/track14.wav",[TRACK_TYPES.TRACK15]:"sounds/blocks/track15.wav",[TRACK_TYPES.TRACK16]:"sounds/blocks/track16.wav",};Object.entries(TRACK_FILES).forEach(([track,path])=>{const pan=+track.replace("TRACK","")%2?-1:1;const ctx=new AudioContext();const srcNode=ctx.createBufferSource();const gainNode=ctx.createGain();gainNode.gain.value=0;gainNode.connect(ctx.destination);const ambientPan=ctx.createStereoPanner();ambientPan.pan.value=pan;ambientPan.connect(gainNode);audios[track]={srcNode,gainNode,volume:0};fetch(path,{mode:"cors"}).then((resp)=>resp.arrayBuffer()).then((buffer)=>ctx.decodeAudioData(buffer,(abuffer)=>{srcNode.buffer=abuffer;srcNode.connect(ambientPan);srcNode.loop=true;srcNode.loopEnd=35.99;}));});const audiosList=Object.values(audios);const TRACK_LIST=Object.keys(TRACK_FILES);let audioStarted=false;const updateTracks=(tracksCount)=>{if(MENU_CONFIG.music){const polyInfo=getPolyInfo();const max=polyInfo.rows*polyInfo.columns*1.2;TRACK_LIST.forEach((track)=>{const audio=audios[track];audio.volume=(tracksCount[track]||0)/max;updateTrackVolume(audio);if(!audioStarted)audio.srcNode.start();});audioStarted=true;}else{audiosList.forEach((a)=>(a.gainNode.gain.value=0));}};const setMusicVolume=(volume)=>{MUSIC_VOLUME=volume;TRACK_LIST.forEach((track)=>updateTrackVolume(audios[track]));};const updateTrackVolume=(audio)=>{const{gainNode,volume}=audio;gainNode.gain.value=(MUSIC_VOLUME*volume)/100;};const start=()=>{addEntity(PLAYER_ENTITY);configPolys();resetGrid();resetBiomes();removeGeneratedEntities();updateCanvasCss();resetDirection();PLAYER_ENTITY.cell=findAccessibleCell(loadAndGetCell(INITIAL_POS),PLAYER_ENTITY);resetToolbar();resetMap();};const resetSize=debounce((newSize)=>{RENDER_INFO.cellHeight=newSize||RENDER_INFO.cellHeight;configPolys();resetToolbar();resetMap();});const CONTROLS_CONFIG={minZoom:12,maxZoom:120,};const addDebugBlockToPoint=({x,y})=>{if(!MENU_CONFIG.debugMode||RENDER_INFO.rotationTurns)return;if(MENU_CONFIG.usePerspective){x-=175;y+=60;}const cell=getCell(calculatePosBasedOnPoint({x,y}));const block=BLOCKS.ROCK;if(cell.wall)cell.wall=null;else placeBlock(cell,block,block.color);drawEveryCell(PLAYER_ENTITY);};const getJFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(x)=>(x-xSide)/(polySide/2);case KNOWN_POLYGONS.HEXAGON:return(x)=>(x-xSide)/(xSide+polySide/2);case KNOWN_POLYGONS.SQUARE:default:return(x)=>(x-xSide)/(xSide*2);}};const calcI=(y,ySide,shouldIntercalate,evenJ)=>{let dividend=y-ySide;if(shouldIntercalate){if(PLAYER_ENTITY.cell.pos.j%2&&!evenJ){dividend+=ySide;}else if(!(PLAYER_ENTITY.cell.pos.j%2)&&evenJ){dividend-=ySide;}}return dividend/(ySide*2);};const calculatePosBasedOnPoint=({x,y})=>{const{xSide,ySide,shouldIntercalate,polySide}=getPolyInfo();let j=getJFn(RENDER_INFO.currentPoly,polySide,xSide)(x);j=Math.round(j+(RENDER_INFO.jOffset||0));let i=calcI(y,ySide,shouldIntercalate,!!(j%2));i+=RENDER_INFO.iOffset||0;return{i:Math.round(i),j:j};};(()=>{const SELECT_OPTIONS={mapGeneration:Object.entries(MAP_GENERATION),};document.querySelectorAll("#menu label").forEach((l)=>{const config=(l).htmlFor;const element=(document.getElementById(config));if(!element)return;if(element.type==="checkbox"){const check=(element);check.checked=MENU_CONFIG[config];check.onchange=()=>{MENU_CONFIG[config]=check.checked;updateCanvasCss();drawEveryCell(PLAYER_ENTITY);check.blur();};}else if(element.tagName==="SELECT"){const select=(element);SELECT_OPTIONS[config].forEach(([key,value])=>{const option=document.createElement("option");option.value=value;option.innerHTML=key;select.appendChild(option);});select.value=MENU_CONFIG[config];select.onchange=()=>{MENU_CONFIG[config]=select.value;start();select.blur();};}});const teleportationIElement=(document.getElementById("teleportation-i"));const teleportationJElement=(document.getElementById("teleportation-j"));const teleportationBtn=(document.getElementById("teleport"));teleportationBtn.onclick=()=>{const i=+teleportationIElement.value;const j=+teleportationJElement.value;move(loadAndGetCell({i,j}));teleportationBtn.blur();};const zoomSlider=(document.getElementById("zoom"));zoomSlider.value=`${RENDER_INFO.cellHeight}`;zoomSlider.min=`${CONTROLS_CONFIG.minZoom}`;zoomSlider.max=`${CONTROLS_CONFIG.maxZoom}`;zoomSlider.oninput=()=>{resetSize(+zoomSlider.value);zoomSlider.blur();};const musicVolumeSlider=(document.getElementById("musicVolume"));musicVolumeSlider.value=`50`;musicVolumeSlider.min=`0`;musicVolumeSlider.max=`100`;musicVolumeSlider.oninput=()=>{setMusicVolume(+musicVolumeSlider.value);musicVolumeSlider.blur();};setMusicVolume(+musicVolumeSlider.value);})();const fishingCanvas=(document.getElementById("fishing-canvas"));const fishingContext=fishingCanvas.getContext("2d");const fishingLineCanvas=(document.getElementById("fishing-line-canvas"));const fishingLineContext=fishingLineCanvas.getContext("2d");fishingLineContext.strokeStyle="black";const fishingContainer=document.getElementById("fishing-container");const fishingRodImg=(document.getElementById("fishing-rod"));const fishingRodPos=({i:8,j:0});const fishingFishImg=(document.getElementById("fishing-fish"));const fishingFishPos=({i:2,j:1});const FISHING_CONFIG={mazeSize:7,cellHeight:45,circleMazeSize:5,circleCellHeight:30,isCircleProbability:0.05,secondsToFish:20,timerDelay:100,timer:null,};let fishingMazeObj=(null);let IS_FISHING_ACTIVE=false;let FISHING_IS_CIRCLE=false;const setFishingCanvasSize=({height,width})=>{fishingLineCanvas.height=fishingCanvas.height=height;fishingLineCanvas.width=fishingCanvas.width=width;};const getFishingRodPoint=()=>FISHING_IS_CIRCLE?fishingMazeObj.getCirclePoint():fishingMazeObj.getLastMazeCell().point;const drawFishingLine=()=>{fishingLineCanvas.height=fishingLineCanvas.height;const fishPoint=fishingMazeObj.getCurrentMazeCell().point;const rodPoint=getFishingRodPoint();fishingLineContext.moveTo(fishPoint.x,fishPoint.y);fishingLineContext.lineTo(rodPoint.x,rodPoint.y);fishingLineContext.stroke();};const initFishingImages=()=>{const{ySide}=fishingMazeObj.getMazePolyInfo();setImagePos(fishingRodImg,fishingRodPos);setEntityImageSize(fishingRodImg,ySide);setImagePoint(fishingRodImg,getFishingRodPoint(),true,ySide);setImagePos(fishingFishImg,fishingFishPos);setEntityImageSize(fishingFishImg,ySide);setImagePoint(fishingFishImg,fishingMazeObj.getCurrentMazeCell().point,true,ySide);drawFishingLine();};const stopFishing=()=>{clearInterval(FISHING_CONFIG.timer);fishingContainer.classList.add("hide");IS_FISHING_ACTIVE=false;};const initFishingMazeObj=()=>{if(!fishingMazeObj)fishingMazeObj=createMazeObj({cellHeight:FISHING_CONFIG.cellHeight,rows:FISHING_CONFIG.mazeSize,columns:FISHING_CONFIG.mazeSize,},{cellHeight:FISHING_CONFIG.circleCellHeight,rows:FISHING_CONFIG.circleMazeSize,columns:FISHING_CONFIG.circleMazeSize,});fishingMazeObj.setIsCircle(FISHING_IS_CIRCLE);fishingMazeObj.buildMaze();};const initFishingTimer=(height)=>{fishingContainer.style.setProperty("--fishing-progress-bar-init-height",`${height}px`);fishingContainer.style.setProperty("--fishing-progress-bar-height",`${height}px`);let currentHeight=height;const timerSteps=height/((FISHING_CONFIG.secondsToFish*1000)/FISHING_CONFIG.timerDelay);FISHING_CONFIG.timer=setInterval(()=>{currentHeight-=timerSteps;fishingContainer.style.setProperty("--fishing-progress-bar-height",`${currentHeight}px`);if(currentHeight<=0){stopFishing();hurtEntity(PLAYER_ENTITY,1);}},FISHING_CONFIG.timerDelay);};let fishingFluidInterval=null;const initFishingDraw=(mazeObj)=>{clearInterval(fishingFluidInterval);const cells=([]);for(const pos of mazeObj.iterateOverMaze()){const cell=mazeObj.getMazeCell(pos);cells.push(cell);drawCellMaze(fishingContext,mazeObj,cell,tweakColor(BLOCKS.WATER.color));}if(!cells.length)return;fishingFluidInterval=setInterval(()=>{cells.forEach((c)=>drawCellMaze(fishingContext,mazeObj,c,tweakColor(BLOCKS.WATER.color)));},DRAW_CONFIG.fluidSpeed);};const startFishing=()=>{if(IS_FISHING_ACTIVE)return stopFishing();IS_FISHING_ACTIVE=true;FISHING_IS_CIRCLE=Math.random()<FISHING_CONFIG.isCircleProbability;initFishingMazeObj();const size=fishingMazeObj.getMazeSize();size.height+=FISHING_CONFIG.cellHeight/9;setFishingCanvasSize(size);initFishingImages();fishingContainer.classList.remove("hide");initFishingTimer(size.height);initFishingDraw(fishingMazeObj);};let canMoveFishing=true;const moveFishing=(code,useDiagonal)=>{if(canMoveFishing){const{ySide,hasInverted,polySides}=fishingMazeObj.getMazePolyInfo();const currentCell=fishingMazeObj.getCurrentMazeCell();const aIndex=getMovementMap(currentCell,useDiagonal,0,polySides,!FISHING_IS_CIRCLE&&hasInverted)[code];const nextCell=fishingMazeObj.mazeMove(aIndex);if(!nextCell)return;if(fishingMazeObj.isMazeSolved()){stopFishing();giveItemToEntity(PLAYER_ENTITY,{imgPos:fishingFishPos,health:1});return;}setImagePoint(fishingFishImg,nextCell.point,true,ySide);drawFishingLine();canMoveFishing=false;setTimeout(()=>{canMoveFishing=true;},100);}};(()=>{let mobileZoom=0;canvasContainer.ontouchstart=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];mobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);return;}};canvasContainer.ontouchmove=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];const nMobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);if(nMobileZoom>mobileZoom&&RENDER_INFO.cellHeight<CONTROLS_CONFIG.maxZoom){resetSize(RENDER_INFO.cellHeight+1);}else if(nMobileZoom<mobileZoom&&RENDER_INFO.cellHeight>CONTROLS_CONFIG.minZoom){resetSize(RENDER_INFO.cellHeight-1);}mobileZoom=nMobileZoom;}};canvasContainer.ontouchend=()=>{mobileZoom=0;};document.getElementById("change-poly").onclick=()=>{changePolySides();updatePolyImages();};document.getElementById("rotate-left").onclick=()=>rotate(-1);document.getElementById("rotate-right").onclick=()=>rotate(1);const currentPoly=(document.getElementById("current-poly"));const nextPoly=(document.getElementById("next-poly"));const updatePolyImages=()=>{setImagePos(currentPoly,POLYGONS_ENTITY_POS[RENDER_INFO.currentPoly]);setImagePos(nextPoly,POLYGONS_ENTITY_POS[getNextPolygon()]);};updatePolyImages();})();const MAP_CONFIG={currentPosRatio:5,posRatio:5,fullScreenPosRatio:50,playerColor:({r:212,g:172,b:156,}),xRatio:0,yRatio:0,};const mapCanvas=(document.getElementById("map-canvas"));const mapContext=mapCanvas.getContext("2d");const resetBiomeMap=()=>{let size=0;if(fullMap){size=Math.min(window.innerWidth,window.innerHeight)*0.96;MAP_CONFIG.currentPosRatio=MAP_CONFIG.fullScreenPosRatio;}else{size=mapCanvas.parentElement.offsetWidth;MAP_CONFIG.currentPosRatio=MAP_CONFIG.posRatio;}mapCanvas.width=size;mapCanvas.height=size;MAP_CONFIG.xRatio=mapCanvas.width/(MAP_CONFIG.currentPosRatio*2+1);MAP_CONFIG.yRatio=mapCanvas.height/(MAP_CONFIG.currentPosRatio*2+1);};const updateBiomeMap=()=>{clearCanvas(mapCanvas);const biomes=getBiomeMap();const iOffset=Math.round(RENDER_INFO.iOffset/GENERATION_CONFIG.chunkSize);const jOffset=Math.round(RENDER_INFO.jOffset/GENERATION_CONFIG.chunkSize);const iNegLimit=iOffset-MAP_CONFIG.currentPosRatio;const iPosLimit=iOffset+MAP_CONFIG.currentPosRatio+1;const jNegLimit=jOffset-MAP_CONFIG.currentPosRatio;const jPosLimit=jOffset+MAP_CONFIG.currentPosRatio+1;for(let i=iNegLimit;i<=iPosLimit;i++){const nI=i-iOffset;for(let j=jNegLimit;j<=jPosLimit;j++){const nJ=j-jOffset;const biome=biomes[i]?.[j];if(!biome)continue;createRect({i:nI,j:nJ},biome.mapColor);}}createRect({i:0,j:0},MAP_CONFIG.playerColor);};let fullMap=false;const toggleFullMap=(toggle=!fullMap)=>{fullMap=toggle;if(toggle){mapCanvas.classList.add("full-screen");resetBiomeMap();updateBiomeMap();}else{mapCanvas.classList.remove("full-screen");resetBiomeMap();updateBiomeMap();}};const createRect=(pos,color)=>{mapContext.fillStyle=getFillStyle(color);mapContext.fillRect((MAP_CONFIG.currentPosRatio+pos.j)*MAP_CONFIG.xRatio,(MAP_CONFIG.currentPosRatio+pos.i)*MAP_CONFIG.yRatio,MAP_CONFIG.xRatio,MAP_CONFIG.yRatio);};const areColorsEqual=(color1,color2)=>color1.r===color2.r&&color1.g===color2.g&&color1.b===color2.b;const PLACE_CONFIG={cellHeight:24,canvasNum:7,};const BLOCKS_LISTS=Object.values(BLOCKS).filter((b)=>!b.isFluid).filter((b,i,a)=>!a.find((b2,i2)=>areColorsEqual(b.color,b2.color)&&i<i2));PLACE_CONFIG.steps=360/PLACE_CONFIG.canvasNum;let PLACE_POLYS_INFO=(null);const placeContainer=document.getElementById("place-canvas-container");const placeCanvas=([]);const placeContexts=([]);for(let i=0;i<PLACE_CONFIG.canvasNum;i++){const canvas=document.createElement("canvas");canvas.style.setProperty("--place-rotate-canvas",`${PLACE_CONFIG.steps *i}deg`);placeContainer.appendChild(canvas);placeCanvas.push(canvas);placeContexts.push(canvas.getContext("2d"));}placeContainer.ontouchend=()=>{};const getSelectedBlockToPlace=()=>{const block=BLOCKS_LISTS[getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length)];return{block,color:block.color};};const resetPlace=()=>{placeCanvas.forEach((p)=>{p.width=placeContainer.parentElement.offsetWidth;p.height=placeContainer.parentElement.offsetHeight;});showSelectedPlaceBlocks();};const drawPlaceBlock=(context,block)=>{if(!PLACE_POLYS_INFO){PLACE_POLYS_INFO={};for(const p of KNOWN_POLYGONS_VALUES){PLACE_POLYS_INFO[p]=configPoly(p,PLACE_CONFIG.cellHeight);}}const polyInfo=PLACE_POLYS_INFO[RENDER_INFO.currentPoly];const wall=blockToWall({block,color:block.color},{x:placeContainer.parentElement.offsetWidth/2,y:placeContainer.parentElement.offsetHeight/1.75,},{isInverted:polyInfo.hasInverted},polyInfo);drawWall(wall,context);applyBorders(context,wall.point,wall.points,[],true);drawWallTop(wall,context);};let SELECTED_PLACE_BLOCKS=0;let PLACE_BLOCKS_DEG=0;const movePlaceBlocks=(orientation)=>{SELECTED_PLACE_BLOCKS=SELECTED_PLACE_BLOCKS+orientation;PLACE_BLOCKS_DEG+=orientation>0?PLACE_CONFIG.steps:-PLACE_CONFIG.steps;placeContainer.style.setProperty("--place-rotate-container",`${-PLACE_BLOCKS_DEG}deg`);showSelectedPlaceBlocks();};const showSelectedPlaceBlocks=()=>{const showIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS,PLACE_CONFIG.canvasNum),getMod(SELECTED_PLACE_BLOCKS+1,PLACE_CONFIG.canvasNum),];const drawIndexes=[getMod(SELECTED_PLACE_BLOCKS-1,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS,BLOCKS_LISTS.length),getMod(SELECTED_PLACE_BLOCKS+1,BLOCKS_LISTS.length),];placeCanvas.forEach((p,i)=>{p.classList[showIndexes.includes(i)?"add":"remove"]("active");});showIndexes.forEach((index,i)=>{clearCanvas(placeCanvas[index]);drawPlaceBlock(placeContexts[index],BLOCKS_LISTS[drawIndexes[i]]);});};(()=>{const SELECTION_STICK_CONFIG={touchThreshold:20,};const selectionStickLeft=document.getElementById("selection-stick-left");const selectionStickRight=document.getElementById("selection-stick-right");const SELECTION_STICK_INFO=(()=>{const maxPoint=selectionStickLeft.offsetWidth/1.25;const minPoint=selectionStickLeft.offsetWidth/5;const midPoint=minPoint+(maxPoint-minPoint)/2;const maxMidPoint=midPoint+SELECTION_STICK_CONFIG.touchThreshold;const minMidPoint=midPoint-SELECTION_STICK_CONFIG.touchThreshold;return{maxPoint,minPoint,midPoint,maxMidPoint,minMidPoint};})();const moveStick=(e,stickElement)=>{e=e||(window.event);e.preventDefault();e.stopPropagation();const{clientX,clientY}=e.touches[0];const stickRect=stickElement.getBoundingClientRect();let finalX=clientX-stickRect.left;let finalY=clientY-stickRect.top;finalX=Math.min(finalX,SELECTION_STICK_INFO.maxPoint);finalX=Math.max(finalX,SELECTION_STICK_INFO.minPoint);finalY=Math.min(finalY,SELECTION_STICK_INFO.maxPoint);finalY=Math.max(finalY,SELECTION_STICK_INFO.minPoint);stickElement.style.setProperty("--selection-stick-left",`${finalX}px`);stickElement.style.setProperty("--selection-stick-top",`${finalY}px`);let code=null;const useDiagonal=finalY>SELECTION_STICK_INFO.maxMidPoint;if(useDiagonal)code=MOVEMENT.DOWN;if(finalY<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.UP;if(finalX>SELECTION_STICK_INFO.maxMidPoint)code=MOVEMENT.RIGHT;if(finalX<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.LEFT;return{code,useDiagonal};};selectionStickLeft.ontouchstart=selectionStickLeft.ontouchmove=(e)=>{const{code,useDiagonal}=moveStick(e,selectionStickLeft);if(code)changeSelectedOnCode(code,useDiagonal);};let rightStickInfo=({});const updateRightStickInfo=(e)=>(rightStickInfo=moveStick(e,selectionStickRight));selectionStickRight.ontouchstart=(e)=>{clearInterval(rightStickInfo.interval);updateRightStickInfo(e);rightStickInfo.interval=setInterval(()=>{if(rightStickInfo.code)moveBaseOnCode(rightStickInfo.code,rightStickInfo.useDiagonal);else stopMoving();},100);};selectionStickRight.ontouchmove=updateRightStickInfo;document.ontouchend=()=>{selectionStickLeft?.style.removeProperty("--selection-stick-left");selectionStickLeft?.style.removeProperty("--selection-stick-top");selectionStickRight?.style.removeProperty("--selection-stick-left");selectionStickRight?.style.removeProperty("--selection-stick-top");stopMoving();clearInterval(rightStickInfo.interval);rightStickInfo={code:null,useDiagonal:null,interval:null};};})();const resetToolbar=()=>{resetBiomeMap();resetPlace();};const CLOUDS_CONFIG={num:4,rows:3,columns:3,durationMult:30,offsetSize:6,offset:0,};const CLOUDS_DIRECTION_MAP={[MOVEMENT.RIGHT]:-CLOUDS_CONFIG.offsetSize,[MOVEMENT.LEFT]:CLOUDS_CONFIG.offsetSize,};const cloudsContainer=document.getElementById("clouds-container");let clouds=([]);const updateClouds=(direction)=>{if(MENU_CONFIG.clouds){if(!clouds.length){createClouds();offsetClouds(MOVEMENT.RIGHT);}setCloudShape();offsetClouds(direction);}else{cloudsContainer.classList.add("off");}};const setCloudShape=()=>{const{currentPoly,cellHeight}=RENDER_INFO;const size=Math.min(cellHeight*4,cloudsContainer.offsetWidth/(CLOUDS_CONFIG.num*CLOUDS_CONFIG.columns*1.5));cloudsContainer.className=`p${currentPoly}`;cloudsContainer.style.setProperty("--clouds-default-size",`${size}px`);};const offsetClouds=(direction)=>{const offsetSize=CLOUDS_DIRECTION_MAP[direction];if(!offsetSize)return;CLOUDS_CONFIG.offset+=offsetSize;const offsetLeft=getMod(CLOUDS_CONFIG.offset,cloudsContainer.offsetWidth);const width=cloudsContainer.offsetWidth/CLOUDS_CONFIG.num;const defaultOffsetLeft=cloudsContainer.offsetWidth/4;cloudsContainer.style.setProperty("--clouds-offset-left",`${getMod(CLOUDS_CONFIG.offset,width)-defaultOffsetLeft}px`);const offset=Math.floor(offsetLeft/width);for(let index=0;index<clouds.length;index++){clouds[index].style.setProperty("--clouds-order",`${getMod(index +offset,CLOUDS_CONFIG.num)+1}`);}};const createClouds=()=>{const min=1-CLOUDS_CONFIG.num/10;const max=Math.min(min+0.5,1);for(let i=0;i<CLOUDS_CONFIG.num;i++){const cloud=document.createElement("div");cloud.className="cloud";const scale=correctRoundError(getRandomFloat(min,max),2);const duration=Math.round(scale*CLOUDS_CONFIG.durationMult);cloud.style.setProperty("--clouds-scale",`${scale}`);cloud.style.setProperty("--clouds-animation-duration",`${duration}s`);cloudsContainer.appendChild(cloud);clouds.push(cloud);for(let j=0;j<CLOUDS_CONFIG.rows;j++){const cloudRow=document.createElement("div");cloudRow.className="cloud-row";cloud.appendChild(cloudRow);for(let z=0;z<CLOUDS_CONFIG.columns;z++){const cloudShape=document.createElement("div");cloudShape.className="cloud-shape";cloudRow.appendChild(cloudShape);}}}};(()=>{const KEY_MOVEMENT_MAP={["KeyW"]:MOVEMENT.UP,["KeyA"]:MOVEMENT.LEFT,["KeyS"]:MOVEMENT.DOWN,["KeyD"]:MOVEMENT.RIGHT,};const ARROW_MOVEMENT_MAP={["ArrowUp"]:MOVEMENT.UP,["ArrowLeft"]:MOVEMENT.LEFT,["ArrowDown"]:MOVEMENT.DOWN,["ArrowRight"]:MOVEMENT.RIGHT,};let selectedToolbarIndex=1;const TOOLBAR_ACTIONS=[undefined,document.getElementById("toolbar-dig"),document.getElementById("toolbar-place"),document.getElementById("toolbar-fishing"),document.getElementById("toolbar-boat"),document.getElementById("toolbar-gun"),document.getElementById("toolbar-map"),];const MOVEMENT_KEYS=Object.keys(KEY_MOVEMENT_MAP);const menuToggle=(document.getElementById("menuToggle"));const closeDebugMenu=()=>(menuToggle.checked=false);document.onkeydown=(e)=>{e=e||(window.event);const targetElement=(e.target);if(targetElement.tagName==="INPUT"&&targetElement.id!=="menuToggle")return;if(e.code==="KeyR")movePlaceBlocks(e.altKey?-1:1);if(e.code.startsWith("Arrow"))return moveBaseOnCode(ARROW_MOVEMENT_MAP[e.code],e.altKey);if(e.code.startsWith("Digit")||e.code.startsWith("Numpad"))return updateToolbarSelected(+e.code.replace(/Numpad|Digit/gi,""));if(MOVEMENT_KEYS.includes(e.code))return changeSelectedOnCode(KEY_MOVEMENT_MAP[e.code],e.altKey);if(e.code==="KeyQ")return rotate(-1);if(e.code==="KeyE")return rotate(1);if(e.code==="KeyF")return TOOLBAR_ACTIONS[selectedToolbarIndex].onclick(null);if(e.code.includes("Shift"))return changePolySides();if(e.code==="Space")return move();if(e.code==="Escape"){closeDebugMenu();useMap(false);}};document.onkeyup=()=>{stopMoving();};const updateToolbarSelected=(keyIndex)=>{const element=TOOLBAR_ACTIONS[keyIndex];if(!element)return;TOOLBAR_ACTIONS[selectedToolbarIndex].classList.remove("toolbar-selected");selectedToolbarIndex=keyIndex;element.classList.add("toolbar-selected");};document.onwheel=(e)=>{e=e||(window.event);updateToolbarSelected(e.deltaY<0?selectedToolbarIndex-1:selectedToolbarIndex+1);};updateToolbarSelected(selectedToolbarIndex);TOOLBAR_ACTIONS[1].onclick=()=>dig();const toolbarPlace=document.getElementById("toolbar-place");TOOLBAR_ACTIONS[2].onclick=(e)=>{if(e){const{top}=toolbarPlace.getBoundingClientRect();const y=e.clientY-top;if(y<0)return movePlaceBlocks(-1);if(y>toolbarPlace.offsetHeight)return movePlaceBlocks(1);}place();};TOOLBAR_ACTIONS[3].onclick=()=>useFishingRod();TOOLBAR_ACTIONS[4].onclick=()=>useBoat();TOOLBAR_ACTIONS[5].onclick=()=>useGun();TOOLBAR_ACTIONS[6].onclick=()=>useMap();canvasContainer.onclick=(e)=>{e=e||(window.event);if(MENU_CONFIG.debugMode){const{left,top}=canvasContainer.getBoundingClientRect();const x=e.clientX-left;const y=e.clientY-top;addDebugBlockToPoint({x,y});}closeDebugMenu();stopFishing();};})();const rainContainer =document.getElementById("rain-container");const BIOME_RAIN_MAP ={DEFAULT:"../images/weather/rain.gif",[BIOME_TYPES.SNOW]:"../images/weather/snow.gif",};const rainAudio =new Audio("sounds/weather/rain.mp3");rainAudio.volume =0.25;rainAudio.loop =true;const lightningAudio =new Audio("sounds/weather/lightning.mp3");lightningAudio.volume =0.25;let isRainOn =false;const updateRain =()=>{if (MENU_CONFIG.rain){if (!isRainOn){clearLightning();isRainOn =true;rainAudio.play();rainContainer.classList.remove("hide");const size =RENDER_INFO.cellHeight *10;rainContainer.style.setProperty("--rain-size",`${size}px`);createLightining();}updateRainImg();}else {if (isRainOn){clearLightning();isRainOn =false;rainAudio.pause();rainContainer.classList.add("hide");}}};let lightningInterval =null;const createLightining =()=>{clearTimeout(lightningInterval);const secs =getRandomFloat(10000,30000);lightningInterval =setTimeout(()=>{rainContainer.classList.remove("lightning");rainContainer.offsetHeight;rainContainer.classList.add("lightning");lightningAudio.play();createLightining();},secs);};const clearLightning =()=>{clearTimeout(lightningInterval);rainContainer.classList.remove("lightning");};const updateRainImg =()=>{const gif =`url("${BIOME_RAIN_MAP[PLAYER_ENTITY.cell.block.biomeType]||BIOME_RAIN_MAP.DEFAULT }")`;const currentGif=rainContainer.style.getPropertyValue("--rain-img");if(gif!==currentGif)rainContainer.style.setProperty("--rain-img",gif);};start();window.onresize=()=>{resetSize();};const updateWeather=(direction)=>{updateRain();updateClouds(direction);};const CLOCK_CONFIG={passHour:0.25,midNightHour:60,};const analogClock=document.getElementById("analog-clock");const digitalClock=document.getElementById("digital-clock");const hourTensSegments=document.querySelectorAll("#digital-clock-hours .digit-tens .segment");const hourUnitsSegments=document.querySelectorAll("#digital-clock-hours .digit-units .segment");const minuteTensSegments=document.querySelectorAll("#digital-clock-minutes .digit-tens .segment");const minuteUnitsSegments=document.querySelectorAll("#digital-clock-minutes .digit-units .segment");const updateClock=()=>{const{hour,hour24,minute}=getTime();if(MENU_CONFIG.digitalClock){digitalClock.classList.remove("hide");analogClock.classList.add("hide");setNumber(hourTensSegments,Math.floor(hour24/10));setNumber(hourUnitsSegments,Math.floor(hour24%10));setNumber(minuteTensSegments,Math.floor(minute/10));setNumber(minuteUnitsSegments,Math.floor(minute%10));}else{analogClock.classList.remove("hide");digitalClock.classList.add("hide");analogClock.style.setProperty("--clock-hour-rotate",`${hour *30 +minute *0.5}deg`);analogClock.style.setProperty("--clock-minute-rotate",`${minute *6}deg`);}};const passTime=()=>{ENTITY_INFO.timeOfDay+=CLOCK_CONFIG.passHour;if(ENTITY_INFO.timeOfDay>=CLOCK_CONFIG.midNightHour||ENTITY_INFO.timeOfDay<=0){CLOCK_CONFIG.passHour=-CLOCK_CONFIG.passHour;}updateClock();};const getTime=()=>{const hourRaw=(12*ENTITY_INFO.timeOfDay)/CLOCK_CONFIG.midNightHour;let hour=Math.floor(hourRaw);let minute=Math.round((hourRaw-hour)*100);minute=Math.floor(minute*0.6);minute=CLOCK_CONFIG.passHour>0?minute:60-minute;minute=getMod(minute,60);if(CLOCK_CONFIG.passHour<0)hour=Math.max((minute?11:12)-hour,0);const hour24=CLOCK_CONFIG.passHour>0?hour+12:hour;return{hour,hour24,minute};};const setNumber=(segments,value)=>{segments.forEach((el)=>{el.classList[el.classList.contains(`n${value}`)?"add":"remove"]("active");});};const compass=document.getElementById("compass");const COMPASS_CONFIG={rotateDelay:750,};const updateCompass=()=>{const angle=(360/RENDER_INFO.currentPoly)*RENDER_INFO.rotationTurns;compass.style.setProperty("--compass-rotate",`${-angle}deg`);};const entitiesContainer=document.getElementById("entities");const rotateCanvas=(deg,rotateDelay)=>{rotateElement(entitiesContainer,-deg,rotateDelay);rotateElement(drawContainer,deg,rotateDelay);};const resetRotateCanvas=()=>{rotateElement(entitiesContainer);rotateElement(drawContainer);};const rotateElement=(element,deg,rotateDelay)=>{if(rotateDelay)element.style.setProperty("--transition-duration",`${rotateDelay}ms`);if(deg)element.style.setProperty("--rotate-deg",`${deg}deg`);element.classList[deg?"add":"remove"]("rotate");element.classList[deg?"add":"remove"]("zoom-in");};const updateWidgets=()=>{updateClock();updateCompass();};const digAudio=new Audio("sounds/actions/dig.mp3");digAudio.volume=0.25;const punchAudio=new Audio("sounds/actions/punch.mp3");punchAudio.volume=0.25;const gunShotAudio=new Audio("sounds/actions/gun-shot.mp3");gunShotAudio.volume=1;const rotateAudio=new Audio("sounds/actions/rotate.mp3");rotateAudio.volume=0.25;let canRotate=true;const canDoActions=()=>PLAYER_ENTITY.health>0;const rotate=(orientation)=>{if(canRotate){canRotate=false;RENDER_INFO.rotationTurns=PLAYER_ENTITY.selectedCellIndex=getMod(RENDER_INFO.rotationTurns+orientation,RENDER_INFO.currentPoly);if(MENU_CONFIG.rotationAnimation){rotateCanvas((360/RENDER_INFO.currentPoly)*-orientation,COMPASS_CONFIG.rotateDelay);rotateAudio.play();}updateCompass();resetDirection();setTimeout(()=>{if(MENU_CONFIG.rotationAnimation)resetRotateCanvas();drawEveryCell(PLAYER_ENTITY);canRotate=true;},COMPASS_CONFIG.rotateDelay);}};const getNextCellIndexBasedOnCode=(code,useDiagonal)=>{const aIndex=getMovementMap(PLAYER_ENTITY.cell,useDiagonal)[code];if(aIndex===undefined)return;return getMod(aIndex,RENDER_INFO.currentPoly);};let isMoving=false;const moveBaseOnCode=(direction,useDiagonal)=>{if(!direction||!canDoActions())return;if(IS_FISHING_ACTIVE){moveFishing(direction,useDiagonal);return;}isMoving=true;makeEntityRun(PLAYER_ENTITY,direction);const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined)return;const nextPos=getPosByIndex(PLAYER_ENTITY.cell,aModI);if(!nextPos)return;const nextCell=getCell(nextPos);if(cellIsBlocked(nextCell,PLAYER_ENTITY))return;move(nextCell);updateWeather(direction);};const MOVEMENT_VALUES=Object.values(MOVEMENT);const stopMoving=()=>{if(!isMoving)return;let lastSelection=PLAYER_ENTITY.currentDirection;const movementMap=getMovementMap(PLAYER_ENTITY.cell);for(const movement of MOVEMENT_VALUES){if(movementMap[movement]===PLAYER_ENTITY.selectedCellIndex){lastSelection=movement;break;}}isMoving=false;updateEntityDirection(PLAYER_ENTITY,lastSelection);};const changeSelectedOnCode=(direction,useDiagonal)=>{if(!direction)return;const aModI=getNextCellIndexBasedOnCode(direction,useDiagonal);if(aModI===undefined||aModI===PLAYER_ENTITY.selectedCellIndex)return;PLAYER_ENTITY.selectedCellIndex=aModI;if(MENU_CONFIG.showSelectedCell)drawEveryCell(PLAYER_ENTITY);updateEntityDirection(PLAYER_ENTITY,direction);};const getNextPolygon=()=>KNOWN_POLYGONS_VALUES[(KNOWN_POLYGONS_VALUES.indexOf(RENDER_INFO.currentPoly)+1)%KNOWN_POLYGONS_VALUES.length];const changePolySides=()=>{RENDER_INFO.currentPoly=getNextPolygon();RENDER_INFO.rotationTurns=0;PLAYER_ENTITY.selectedCellIndex=0;updateCompass();resetDirection();resetMap();};const resetDirection=()=>updateEntityDirection(PLAYER_ENTITY,MOVEMENT.UP);const updateAndGetSelectedCell=()=>{updateEntityDirection(PLAYER_ENTITY,PLAYER_ENTITY.currentDirection);return getSelectedCell(PLAYER_ENTITY);};const dig=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(!selectedCell?.block)return;if(selectedCell.entityType){makeEntityUse(PLAYER_ENTITY);const entities=getEntitiesFromCell(selectedCell);entities.forEach((e)=>hurtEntity(e,1));punchAudio.play();move();return;}if(selectedCell.block.isFluid)return;if(selectedCell.wall){if(selectedCell.wall.block.indestructible)return;}else if(selectedCell.block.indestructible)return;makeEntityUse(PLAYER_ENTITY);digAudio.play();if(selectedCell.wall){destroyWall(selectedCell);}else{selectedCell.block=null;selectedCell.color=null;}move();};const place=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.wall||selectedCell.entityType)return;makeEntityUse(PLAYER_ENTITY);placeBlock(selectedCell);move();};const placeBlock=(cell,block,color)=>{if(!cell||!!cell.entityType)return;if(!block){const cellBlock=getSelectedBlockToPlace();if(!cellBlock)return;block=cellBlock.block;color=cellBlock.color;}digAudio.play();if(cell.block&&!cell.block.isFluid){cell.wall={block:block,color:color};}else{cell.block=block;cell.color=color;}};const useBoat=()=>{if(IS_FISHING_ACTIVE||!canDoActions())return;const selectedCell=updateAndGetSelectedCell();const canMove=!selectedCell.wall&&selectedCell.block;if(PLAYER_ENTITY.connectedEntities[ENTITY_TYPES.BOAT]){if(!selectedCell?.block?.isFluid&&canMove){getOutBoat(PLAYER_ENTITY);move(selectedCell);}return;}if(selectedCell.entityType===ENTITY_TYPES.BOAT){getInBoat(PLAYER_ENTITY);move(selectedCell);}else if(canMove){makeEntityUse(PLAYER_ENTITY);addBoat(selectedCell,PLAYER_ENTITY);}};const useGun=()=>{const range=getPolyInfo().hasInverted?1:10;updateAndGetSelectedCell();gunShotAudio.currentTime=0;let{cell,selectedCellIndex}=PLAYER_ENTITY;for(let i=0;i<range;i++){const nextCell=getCell(getPosByIndex(cell,selectedCellIndex));if(nextCell.wall)break;cell=nextCell;drawCircleOnCell(cell,PLAYER_ENTITY);if(cell.entityType){const entities=getEntitiesFromCell(cell);entities.forEach((e)=>hurtEntity(e,1));break;}}gunShotAudio.play();move();};const useMap=(toggle)=>{if(IS_FISHING_ACTIVE||!canDoActions())return;toggleFullMap(toggle);};const useFishingRod=()=>{if(!canDoActions())return;const selectedCell=updateAndGetSelectedCell();if(selectedCell?.block?.isFluid){makeEntityUse(PLAYER_ENTITY);startFishing();}};const resetMap=()=>{resetPlace();setEntitiesSize();resetCanvas();moveCurrentCell(getCenterCell(),PLAYER_ENTITY.cell);drawEveryCell(PLAYER_ENTITY);updateWeather();};const MOVEMENT_CONFIG={velocity:10,};const getCleanPos=(pos)=>({i:pos?.i||0,j:pos?.j||0});const moveCurrentCell=(oldCell,nextCell)=>{const oldPos=getCleanPos(oldCell?.pos);const nextPos=getCleanPos(nextCell?.pos);RENDER_INFO.iOffset+=nextPos.i-oldPos.i;RENDER_INFO.jOffset+=nextPos.j-oldPos.j;moveEntityToCell(PLAYER_ENTITY,nextCell);};let canMove=true;const move=(nextCell)=>{if(canMove&&PLAYER_ENTITY.health>0){canMove=false;if(nextCell)moveCurrentCell(PLAYER_ENTITY.cell,nextCell);if(MENU_CONFIG.passTime)passTime();setTimeout(()=>{drawEveryCell(PLAYER_ENTITY);killEntitiesByTimeOfDay();moveEntities(PLAYER_ENTITY.cell);spawnEntities(PLAYER_ENTITY.cell);canMove=true;},1000/MOVEMENT_CONFIG.velocity);}};const findAccessibleCell=(cell,entity)=>{let accessibleCell=cell;while(cellIsBlocked(accessibleCell,entity)){accessibleCell=loadAndGetCell({i:accessibleCell.pos.i+1,j:accessibleCell.pos.j,});}return accessibleCell;};const start=()=>{addEntity(PLAYER_ENTITY);configPolys();resetGrid();resetBiomes();removeGeneratedEntities();updateCanvasCss();resetDirection();PLAYER_ENTITY.cell=findAccessibleCell(loadAndGetCell(INITIAL_POS),PLAYER_ENTITY);resetToolbar();resetMap();};const resetSize=debounce((newSize)=>{RENDER_INFO.cellHeight=newSize||RENDER_INFO.cellHeight;configPolys();resetToolbar();resetMap();});const CONTROLS_CONFIG={minZoom:12,maxZoom:120,};const addDebugBlockToPoint=({x,y})=>{if(!MENU_CONFIG.debugMode||RENDER_INFO.rotationTurns)return;if(MENU_CONFIG.usePerspective){x-=175;y+=60;}const cell=getCell(calculatePosBasedOnPoint({x,y}));const block=BLOCKS.ROCK;if(cell.wall)cell.wall=null;else placeBlock(cell,block,block.color);drawEveryCell(PLAYER_ENTITY);};const getJFn=(polySides,polySide,xSide)=>{switch(polySides){case KNOWN_POLYGONS.TRIANGLE:return(x)=>(x-xSide)/(polySide/2);case KNOWN_POLYGONS.HEXAGON:return(x)=>(x-xSide)/(xSide+polySide/2);case KNOWN_POLYGONS.SQUARE:default:return(x)=>(x-xSide)/(xSide*2);}};const calcI=(y,ySide,shouldIntercalate,evenJ)=>{let dividend=y-ySide;if(shouldIntercalate){if(PLAYER_ENTITY.cell.pos.j%2&&!evenJ){dividend+=ySide;}else if(!(PLAYER_ENTITY.cell.pos.j%2)&&evenJ){dividend-=ySide;}}return dividend/(ySide*2);};const calculatePosBasedOnPoint=({x,y})=>{const{xSide,ySide,shouldIntercalate,polySide}=getPolyInfo();let j=getJFn(RENDER_INFO.currentPoly,polySide,xSide)(x);j=Math.round(j+(RENDER_INFO.jOffset||0));let i=calcI(y,ySide,shouldIntercalate,!!(j%2));i+=RENDER_INFO.iOffset||0;return{i:Math.round(i),j:j};};(()=>{const SELECT_OPTIONS={mapGeneration:Object.entries(MAP_GENERATION),};document.querySelectorAll("#menu label").forEach((l)=>{const config=(l).htmlFor;const element=(document.getElementById(config));if(!element)return;if(element.type==="checkbox"){const check=(element);check.checked=MENU_CONFIG[config];check.onchange=()=>{MENU_CONFIG[config]=check.checked;updateCanvasCss();drawEveryCell(PLAYER_ENTITY);check.blur();};}else if(element.tagName==="SELECT"){const select=(element);SELECT_OPTIONS[config].forEach(([key,value])=>{const option=document.createElement("option");option.value=value;option.innerHTML=key;select.appendChild(option);});select.value=MENU_CONFIG[config];select.onchange=()=>{MENU_CONFIG[config]=select.value;start();select.blur();};}});const teleportationIElement=(document.getElementById("teleportation-i"));const teleportationJElement=(document.getElementById("teleportation-j"));const teleportationBtn=(document.getElementById("teleport"));teleportationBtn.onclick=()=>{const i=+teleportationIElement.value;const j=+teleportationJElement.value;move(loadAndGetCell({i,j}));teleportationBtn.blur();};const zoomSlider=(document.getElementById("zoom"));zoomSlider.value=`${RENDER_INFO.cellHeight}`;zoomSlider.min=`${CONTROLS_CONFIG.minZoom}`;zoomSlider.max=`${CONTROLS_CONFIG.maxZoom}`;zoomSlider.oninput=()=>{resetSize(+zoomSlider.value);zoomSlider.blur();};const musicVolumeSlider=(document.getElementById("musicVolume"));musicVolumeSlider.value=`50`;musicVolumeSlider.min=`0`;musicVolumeSlider.max=`100`;musicVolumeSlider.oninput=()=>{setMusicVolume(+musicVolumeSlider.value);musicVolumeSlider.blur();};setMusicVolume(+musicVolumeSlider.value);})();(()=>{let mobileZoom=0;canvasContainer.ontouchstart=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];mobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);return;}};canvasContainer.ontouchmove=(e)=>{e=e||(window.event);const{screenX,screenY}=e.touches[0];if(e.touches.length===2){const secondTouch=e.touches[1];const nMobileZoom=Math.hypot(screenX-secondTouch.screenX,screenY-secondTouch.screenY);if(nMobileZoom>mobileZoom&&RENDER_INFO.cellHeight<CONTROLS_CONFIG.maxZoom){resetSize(RENDER_INFO.cellHeight+1);}else if(nMobileZoom<mobileZoom&&RENDER_INFO.cellHeight>CONTROLS_CONFIG.minZoom){resetSize(RENDER_INFO.cellHeight-1);}mobileZoom=nMobileZoom;}};canvasContainer.ontouchend=()=>{mobileZoom=0;};document.getElementById("change-poly").onclick=()=>{changePolySides();updatePolyImages();};document.getElementById("rotate-left").onclick=()=>rotate(-1);document.getElementById("rotate-right").onclick=()=>rotate(1);const currentPoly=(document.getElementById("current-poly"));const nextPoly=(document.getElementById("next-poly"));const updatePolyImages=()=>{setImagePos(currentPoly,POLYGONS_ENTITY_POS[RENDER_INFO.currentPoly]);setImagePos(nextPoly,POLYGONS_ENTITY_POS[getNextPolygon()]);};updatePolyImages();})();(()=>{const SELECTION_STICK_CONFIG={touchThreshold:20,};const selectionStickLeft=document.getElementById("selection-stick-left");const selectionStickRight=document.getElementById("selection-stick-right");const SELECTION_STICK_INFO=(()=>{const maxPoint=selectionStickLeft.offsetWidth/1.25;const minPoint=selectionStickLeft.offsetWidth/5;const midPoint=minPoint+(maxPoint-minPoint)/2;const maxMidPoint=midPoint+SELECTION_STICK_CONFIG.touchThreshold;const minMidPoint=midPoint-SELECTION_STICK_CONFIG.touchThreshold;return{maxPoint,minPoint,midPoint,maxMidPoint,minMidPoint};})();const moveStick=(e,stickElement)=>{e=e||(window.event);e.preventDefault();e.stopPropagation();const{clientX,clientY}=e.touches[0];const stickRect=stickElement.getBoundingClientRect();let finalX=clientX-stickRect.left;let finalY=clientY-stickRect.top;finalX=Math.min(finalX,SELECTION_STICK_INFO.maxPoint);finalX=Math.max(finalX,SELECTION_STICK_INFO.minPoint);finalY=Math.min(finalY,SELECTION_STICK_INFO.maxPoint);finalY=Math.max(finalY,SELECTION_STICK_INFO.minPoint);stickElement.style.setProperty("--selection-stick-left",`${finalX}px`);stickElement.style.setProperty("--selection-stick-top",`${finalY}px`);let code=null;const useDiagonal=finalY>SELECTION_STICK_INFO.maxMidPoint;if(useDiagonal)code=MOVEMENT.DOWN;if(finalY<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.UP;if(finalX>SELECTION_STICK_INFO.maxMidPoint)code=MOVEMENT.RIGHT;if(finalX<SELECTION_STICK_INFO.minMidPoint)code=MOVEMENT.LEFT;return{code,useDiagonal};};selectionStickLeft.ontouchstart=selectionStickLeft.ontouchmove=(e)=>{const{code,useDiagonal}=moveStick(e,selectionStickLeft);if(code)changeSelectedOnCode(code,useDiagonal);};let rightStickInfo=({});const updateRightStickInfo=(e)=>(rightStickInfo=moveStick(e,selectionStickRight));selectionStickRight.ontouchstart=(e)=>{clearInterval(rightStickInfo.interval);updateRightStickInfo(e);rightStickInfo.interval=setInterval(()=>{if(rightStickInfo.code)moveBaseOnCode(rightStickInfo.code,rightStickInfo.useDiagonal);else stopMoving();},100);};selectionStickRight.ontouchmove=updateRightStickInfo;document.ontouchend=()=>{selectionStickLeft?.style.removeProperty("--selection-stick-left");selectionStickLeft?.style.removeProperty("--selection-stick-top");selectionStickRight?.style.removeProperty("--selection-stick-left");selectionStickRight?.style.removeProperty("--selection-stick-top");stopMoving();clearInterval(rightStickInfo.interval);rightStickInfo={code:null,useDiagonal:null,interval:null};};})();(()=>{const KEY_MOVEMENT_MAP={["KeyW"]:MOVEMENT.UP,["KeyA"]:MOVEMENT.LEFT,["KeyS"]:MOVEMENT.DOWN,["KeyD"]:MOVEMENT.RIGHT,};const ARROW_MOVEMENT_MAP={["ArrowUp"]:MOVEMENT.UP,["ArrowLeft"]:MOVEMENT.LEFT,["ArrowDown"]:MOVEMENT.DOWN,["ArrowRight"]:MOVEMENT.RIGHT,};let selectedToolbarIndex=1;const TOOLBAR_ACTIONS=[undefined,document.getElementById("toolbar-dig"),document.getElementById("toolbar-place"),document.getElementById("toolbar-fishing"),document.getElementById("toolbar-boat"),document.getElementById("toolbar-gun"),document.getElementById("toolbar-map"),];const MOVEMENT_KEYS=Object.keys(KEY_MOVEMENT_MAP);const menuToggle=(document.getElementById("menuToggle"));const closeDebugMenu=()=>(menuToggle.checked=false);document.onkeydown=(e)=>{e=e||(window.event);const targetElement=(e.target);if(targetElement.tagName==="INPUT"&&targetElement.id!=="menuToggle")return;if(e.code==="KeyR")movePlaceBlocks(e.altKey?-1:1);if(e.code.startsWith("Arrow"))return moveBaseOnCode(ARROW_MOVEMENT_MAP[e.code],e.altKey);if(e.code.startsWith("Digit")||e.code.startsWith("Numpad"))return updateToolbarSelected(+e.code.replace(/Numpad|Digit/gi,""));if(MOVEMENT_KEYS.includes(e.code))return changeSelectedOnCode(KEY_MOVEMENT_MAP[e.code],e.altKey);if(e.code==="KeyQ")return rotate(-1);if(e.code==="KeyE")return rotate(1);if(e.code==="KeyF")return TOOLBAR_ACTIONS[selectedToolbarIndex].onclick(null);if(e.code.includes("Shift"))return changePolySides();if(e.code==="Space")return move();if(e.code==="Escape"){closeDebugMenu();useMap(false);}};document.onkeyup=()=>{stopMoving();};const updateToolbarSelected=(keyIndex)=>{const element=TOOLBAR_ACTIONS[keyIndex];if(!element)return;TOOLBAR_ACTIONS[selectedToolbarIndex].classList.remove("toolbar-selected");selectedToolbarIndex=keyIndex;element.classList.add("toolbar-selected");};document.onwheel=(e)=>{e=e||(window.event);updateToolbarSelected(e.deltaY<0?selectedToolbarIndex-1:selectedToolbarIndex+1);};updateToolbarSelected(selectedToolbarIndex);TOOLBAR_ACTIONS[1].onclick=()=>dig();const toolbarPlace=document.getElementById("toolbar-place");TOOLBAR_ACTIONS[2].onclick=(e)=>{if(e){const{top}=toolbarPlace.getBoundingClientRect();const y=e.clientY-top;if(y<0)return movePlaceBlocks(-1);if(y>toolbarPlace.offsetHeight)return movePlaceBlocks(1);}place();};TOOLBAR_ACTIONS[3].onclick=()=>useFishingRod();TOOLBAR_ACTIONS[4].onclick=()=>useBoat();TOOLBAR_ACTIONS[5].onclick=()=>useGun();TOOLBAR_ACTIONS[6].onclick=()=>useMap();canvasContainer.onclick=(e)=>{e=e||(window.event);if(MENU_CONFIG.debugMode){const{left,top}=canvasContainer.getBoundingClientRect();const x=e.clientX-left;const y=e.clientY-top;addDebugBlockToPoint({x,y});}closeDebugMenu();stopFishing();};})();start();window.onresize=()=>{resetSize();};